<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-12-06T08:14:37-06:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Aaron Smith</title><subtitle>Personal website and blog of Aaron Smith</subtitle><author><name>Aaron Smith</name></author><entry><title type="html">Advent of Code: Day 6</title><link href="http://localhost:4000/blog/advent-of-code-day-06/" rel="alternate" type="text/html" title="Advent of Code: Day 6" /><published>2020-12-06T00:00:00-06:00</published><updated>2020-12-06T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-06</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-06/">&lt;p&gt;Well, our old pal &lt;a href=&quot;https://en.wikipedia.org/wiki/Set_theory&quot;&gt;set theory&lt;/a&gt; reared its &lt;del&gt;ugly&lt;/del&gt; beautiful head again today. I’m very happy with the middle ground I found between conciseness and readability with this challenge; only about 11 lines overall for both parts 1 and 2!&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;On &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-04/&quot;&gt;day four&lt;/a&gt; we helped out airport security with their passport scanner, and &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-05/&quot;&gt;yesterday&lt;/a&gt; we wrote a program to find our seat on the airplane after losing our boarding pass. Today we are about to land, and it’s time to fill out customs declaration form.&lt;/p&gt;

&lt;p&gt;This form has 26 yes or no questions marked “A” through “Z.” We fill ours out quickly and notice the family next to us having some issues with theirs; they ask us for help. Pretty soon we have offered to help everyone on the plane, and we end up with a file that looks like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abc

a
b
c

ab
ac

a
a
a
a

b
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Where each family is distinguished by a blank space, and each person’s answers are on their own line, and the presence of a letter means that person answered “yes.” Additionally, we only count a “yes” once per family. So the above could be interpreted as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The first group contains one person who answered “yes” to 3 questions: a, b, and c&lt;/li&gt;
  &lt;li&gt;The second group contains three people; combined, they answered “yes” to 3 questions: a, b, and c&lt;/li&gt;
  &lt;li&gt;The third group contains two people; combined, they answered “yes” to 3 questions: a, b, and c&lt;/li&gt;
  &lt;li&gt;The fourth group contains four people; combined, they answered “yes” to only 1 question, a&lt;/li&gt;
  &lt;li&gt;The last group contains one person who answered “yes” to only 1 question, b&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The sum of these counts is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3 + 3 + 3 + 1 + 1 = 11&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Our job is to find the sum of distinct “yes” answers (one per question per family) for the entire plane.&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/06/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($file) {
    say [+] $file.IO
              .lines(:nl-in(&quot;\n\n&quot;))                        # [1]
              .map(-&amp;gt; $group {
                (set $group.subst(&quot;\n&quot;, '', :g).comb).elems # [2]
              });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
6809
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;This one is short and sweet due to the tools Raku gives us. First, we read the file in and split it into families (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:nl-in(&quot;\n\n&quot;)&lt;/code&gt;; see below for details). Then, for each family, we combine everyone’s answers into one line, convert it to a list, then convert it to a set (which removes duplicates). We then count the number of elements in each set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.elems&lt;/code&gt; and sum &lt;em&gt;all&lt;/em&gt; the sets using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[+]&lt;/code&gt; metaoperator.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;By default &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.lines&lt;/code&gt; will split the input file on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\n&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\r\n&lt;/code&gt; newline characters. But Raku gives us the tools to tell it to split on whatever we want. In this case, we tell it to split on 2 newline characters, which delineate our families. Additionally, as opposed to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.slurp&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.lines&lt;/code&gt; is lazy, so it does not pull the whole file into memory; something to think about if we had a large file.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subst&lt;/code&gt; is Raku’s string replacement method (not to be confused with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;substr&lt;/code&gt;, its substring method). What’s important here is the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:g&lt;/code&gt; flag we pass in, which say to replace all newlines in the string rather than just the first one.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;As soon as we finished processing everyone’s customs forms, we realize we misread the instructions! We don’t want to count where &lt;em&gt;anyone&lt;/em&gt; answered yes, we want to count where &lt;em&gt;everyone&lt;/em&gt; answered yes. We need to tweak our solution quickly before we land!&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/06/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub part-one($group) {
    (set $group.subst(&quot;\n&quot;, '', :g).comb).elems;
}

sub part-two($group) {
    [∩] $group.split(&quot;\n&quot;).map(-&amp;gt; $entry { set $entry.comb }); # [1]
}

sub MAIN($file, Bool :$p2 = False) {
    say [+] $file.IO.lines(:nl-in(&quot;\n\n&quot;)).map($p2 ?? &amp;amp;part-two !! &amp;amp;part-one);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
6809

# Part 2
$ raku main.raku --p2 input.txt
3394
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;So the first obvious difference is we refactored our part one solution to its own subroutine, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;part-one&lt;/code&gt;, but the logic is the same. Then we added the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;part-two&lt;/code&gt; with the new logic.&lt;/p&gt;

&lt;p&gt;In &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;part-two&lt;/code&gt;, rather than combine the whole family’s input, we split them into individual people &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.split(&quot;\n&quot;)&lt;/code&gt;, and then convert each person’s answers to a set. Finally, we use reduction metaoperator (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[&amp;lt;operator&amp;gt;]&lt;/code&gt;) to apply the &lt;a href=&quot;https://en.wikipedia.org/wiki/Intersection_(set_theory)&quot;&gt;set intersection&lt;/a&gt; operator to all the sets in the family.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;Once again, we use the Unicode operator (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;∩&lt;/code&gt;) as opposed to the ASCII operator (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&amp;amp;)&lt;/code&gt;). You may have seen me use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[+]&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[*]&lt;/code&gt; metaoperators, but this is a new one. The actual operator here is the bracket pair. Basically, when Raku sees the bracket pair, it just applies the operator inside it to all items in the list. So, in this case, it does something like the following:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[∩] (Set(a b c), Set(b c d), Set(c d e)) == Set(a b c) ∩ Set(b c d) ∩ Set(c d e) == Set(c)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Nothing much to add to this one today. A short and sweet question with a short and sweet answer!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Well, our old pal set theory reared its ugly beautiful head again today. I’m very happy with the middle ground I found between conciseness and readability with this challenge; only about 11 lines overall for both parts 1 and 2!</summary></entry><entry><title type="html">Advent of Code: Day 5</title><link href="http://localhost:4000/blog/advent-of-code-day-05/" rel="alternate" type="text/html" title="Advent of Code: Day 5" /><published>2020-12-05T00:00:00-06:00</published><updated>2020-12-05T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-05</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-05/">&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;Binary search&lt;/a&gt; is a well-known algorithm for searching already sorted lists. I liken it to searching for a book at a book store. If the author’s last name starts with “S,” you will start somewhere on the right-hand side of the shelf, then narrow down your search from there. This is obviously more efficient than searching from the left-hand side of the bookshelf.&lt;/p&gt;

&lt;p&gt;That was our task with today’s problem. Yet again, we get to bust out our old friend recursion to solve this problem fairly easily in a functional manner.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;After &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-04/&quot;&gt;yesterday’s fiasco&lt;/a&gt; of just getting through the airport, we find ourselves on the plane. Lo and behold, we dropped our boarding pass, but they still let us on the plane with the holiday rush.&lt;/p&gt;

&lt;p&gt;Luckily, we use our phone to scan &lt;em&gt;all&lt;/em&gt; the boarding passes nearby into a file full of lines that look like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FBFBBFFRLR
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first seven characters define what row (0 through 127, inclusive) everyone’s seat is in, and the last three characters refer to that seat’s column (0 through 7, inclusive). For example, given the above input:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Start by considering the whole range, rows 0 through 127&lt;/li&gt;
  &lt;li&gt;F means to take the lower half, keeping rows 0 through 63&lt;/li&gt;
  &lt;li&gt;B means to take the upper half, keeping rows 32 through 63&lt;/li&gt;
  &lt;li&gt;F means to take the lower half, keeping rows 32 through 47&lt;/li&gt;
  &lt;li&gt;B means to take the upper half, keeping rows 40 through 47&lt;/li&gt;
  &lt;li&gt;B keeps rows 44 through 47&lt;/li&gt;
  &lt;li&gt;F keeps rows 44 through 45&lt;/li&gt;
  &lt;li&gt;The final F keeps the lower of the two, row 44&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Similarly, for the columns:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Start by considering the whole range, columns 0 through 7&lt;/li&gt;
  &lt;li&gt;R means to take the upper half, keeping columns 4 through 7&lt;/li&gt;
  &lt;li&gt;L means to take the lower half, keeping columns 4 through 5&lt;/li&gt;
  &lt;li&gt;The final R keeps the upper of the two, column 5&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And finally, to find someone’s seat number, we have the following calculation:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(row_number * seats_in_row) + column_number = seat_number
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Which yields:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(44 * 8) + 5 = 357
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our task is to find the maximum seat number in the list of scanned boarding passes.&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/05/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub binary-search(@list, @possible-rows, $lower-symbol) {
    if @possible-rows.elems == 1 {
        @possible-rows.head;
    } else {
        my ($first-item, @rest-of-list) := @list[0,1..*];                                  # [1][2]
        my $half-way-point = @possible-rows.elems div 2;                                   # [3]
        if $first-item eq $lower-symbol {                                                  # [4]
            binary-search(@rest-of-list, @possible-rows[^$half-way-point], $lower-symbol); # [5]
        } else {
            binary-search(@rest-of-list, @possible-rows[$half-way-point..*], $lower-symbol);
        }
    }
}

sub find-seat($boarding-pass) {
    my (@row-definition, @column-definition) := $boarding-pass.comb.rotor(7, :partial); # [6]
    my $row = binary-search(@row-definition, (^128), 'F');
    my $column = binary-search(@column-definition, (^8), 'L');
    ($row * 8) + $column;
}

sub MAIN($file) {
    say $file.IO.lines.map(&amp;amp;find-seat).max;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
828
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binary-search&lt;/code&gt; subroutine itself is fairly straight forward. It takes the list of characters (something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(F, B, F, B, B, F, F)&lt;/code&gt;), the list of possible rows/columns (something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(0..127)&lt;/code&gt;), and what character means “lower half” (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt; for front or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;L&lt;/code&gt; for left).&lt;/p&gt;

&lt;p&gt;If there is only one item in the list of remaining rows/columns, that’s our answer, and we return. Otherwise, we check if we are keeping the left half or right half and call the function again with the smaller input.&lt;/p&gt;

&lt;p&gt;We wrap this function in a helper function called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find-seat&lt;/code&gt; which includes the multiplication logic, then map it over our input lines. Finally, we call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;max&lt;/code&gt; to find the max seat number.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;When unpacking a list in this manner, the left-hand side is normally one or more scalars (denoted by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt; sigil). When unpacking using a list on the left-hand side, we have to use the special &lt;a href=&quot;https://docs.raku.org/language/operators#index-entry-Binding_operator&quot;&gt;binding&lt;/a&gt; operator (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:=&lt;/code&gt;) or everything will get “slurped” (Raku’s terminology, not mine) into the list instead of being split between the list and scalar.&lt;/li&gt;
  &lt;li&gt;I used some special Hash syntax yesterday to extract multiple keys at the same time. This is the equivalent List syntax (comma-separated instead of space-separated).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;div&lt;/code&gt; is Raku’s integer division operator. Even though we know our input will always be a multiple of two, it never hurts to use best practices!&lt;/li&gt;
  &lt;li&gt;In the past few posts for string comparison I was using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$x cmp $y == Same&lt;/code&gt;. I finally stumbled upon the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eq&lt;/code&gt; operator and no longer have that code smell!&lt;/li&gt;
  &lt;li&gt;This line (and others) contain special range syntax. Basically &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^$half-way-point&lt;/code&gt; is the same as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(0..^$half-way-point)&lt;/code&gt;, meaning everything from zero to the half-way point, exclusive.&lt;/li&gt;
  &lt;li&gt;This line splits the input into a list of characters and then uses the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rotor&lt;/code&gt; function to split it into groups of 7. Since our second group (the column definition) is of size 3, we need to pass the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:partial&lt;/code&gt; parameter in, or else it will get dropped for being too small. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:partial&lt;/code&gt; is special syntax to pass in a boolean flag named &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;partial&lt;/code&gt; as true. This is the equivalent of passing in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;partial =&amp;gt; True&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;Now that we’ve found the maximum seat, the flight attendants are asking us to take our seat! Our seat is the only seat number not in the list of boarding passes we scanned. And of course instead of just looking around the plane and finding the empty seat, we sit in the aisle and tweak our program to tell us where to go.&lt;/p&gt;

&lt;p&gt;As a caveat, the seat numbers do &lt;em&gt;not&lt;/em&gt; start at 1, so we have to take that into consideration.&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/05/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub binary-search(@list, @possible-rows, $lower-symbol) {
    if @possible-rows.elems == 1 {
        @possible-rows.head;
    } else {
        my ($first-item, @rest-of-list) := @list[0,1..*];
        my $half-way-point = @possible-rows.elems div 2;
        if $first-item eq $lower-symbol {
            binary-search(@rest-of-list, @possible-rows[^$half-way-point], $lower-symbol);
        } else {
            binary-search(@rest-of-list, @possible-rows[$half-way-point..*], $lower-symbol);
        }
    }
}

sub find-seat($boarding-pass) {
    my (@row-definition, @column-definition) := $boarding-pass.comb.rotor(7, :partial);
    my $row = binary-search(@row-definition, (^128), 'F');
    my $column = binary-search(@column-definition, (^8), 'L');
    ($row * 8) + $column;
}

sub MAIN($file, Bool :$p2 = False) {
    my @seats =  $file.IO.lines.map(&amp;amp;find-seat);
    my $max-seat = @seats.max;
    if $p2 {
        my $min-seat = @seats.min;
        my $all-seats = set ($min-seat..$max-seat);
        my @missing-seats = ($all-seats ⊖ set @seats).keys; # [1]
        say @missing-seats.head;
    } else {
        say $max-seat;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
828

# Part 2
$ raku main.raku --p2 input.txt
565
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;You’ll notice all we did was tweak our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; method a bit. We still find all the seat numbers, and if the user doesn’t specify &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p2&lt;/code&gt;, we print the maximum.&lt;/p&gt;

&lt;p&gt;If the user &lt;em&gt;does&lt;/em&gt; specify &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p2&lt;/code&gt;, we also calculate our minimum seat number (since the seats don’t start at 1). We then find the set of &lt;em&gt;all&lt;/em&gt; seats (being the range from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$min-seat&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$max-seat&lt;/code&gt;). We then use our handy dandy &lt;a href=&quot;https://en.wikipedia.org/wiki/Symmetric_difference&quot;&gt;symmetric difference&lt;/a&gt; operator to find the difference between all possible seats, and the list of seats we scanned. The difference, of course, being our seat. We find it just in time before the flight attendants drag us out. Phew!&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;A set is a scalar instead of a collection in Raku (note the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt; sigil instead of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@&lt;/code&gt; sigil), so we have to convert it to a list using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.keys&lt;/code&gt; method. Of course, there is only one thing in it, so we then call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.head&lt;/code&gt; to get that item.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;This exercise has me diving more and more into &lt;a href=&quot;https://en.wikipedia.org/wiki/Set_theory&quot;&gt;set theory&lt;/a&gt;. It’s awesome that Raku allows (and encourages) use of the Unicode operators found in math textbooks. Their reasoning for this is that it is easier to take an algorithm from paper to code when you are allowed to use the same notation in each place. Now to find a keyboard to be able to type these symbols!&lt;/p&gt;

&lt;p&gt;So far we are 5 for 5 with pure functional solutions. 20% of the way there!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Binary search is a well-known algorithm for searching already sorted lists. I liken it to searching for a book at a book store. If the author’s last name starts with “S,” you will start somewhere on the right-hand side of the shelf, then narrow down your search from there. This is obviously more efficient than searching from the left-hand side of the bookshelf.</summary></entry><entry><title type="html">Advent of Code: Day 4</title><link href="http://localhost:4000/blog/advent-of-code-day-04/" rel="alternate" type="text/html" title="Advent of Code: Day 4" /><published>2020-12-04T00:00:00-06:00</published><updated>2020-12-04T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-04</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-04/">&lt;p&gt;Today’s challenge was a rough one for me. Not because of the challenge itself, but because I fell into a trap in the Raku language that was giving me an off-by-one error. See Part 2 for details!&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;This problem may require a little more back-story than my previous posts.&lt;/p&gt;

&lt;p&gt;We’re traveling for the holidays, but realized we forgot our passport! Luckily, we have our North Pole Credentials that have all the same information except Country ID (you know, the thing that makes a passport useful). A passport contains the following fields:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;byr (Birth Year)
iyr (Issue Year)
eyr (Expiration Year)
hgt (Height)
hcl (Hair Color)
ecl (Eye Color)
pid (Passport ID)
cid (Country ID
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Unfortunately we are stuck in a long line because the passport scanner is down. Apparently it is having trouble detecting which passports have all the required fields. We’re nice folks though, so we’re going to offer our skills up to the border agents to fix their passport scanner (and maybe we can slip in a “bug” to ignore the fact that we don’t have a passport?).&lt;/p&gt;

&lt;p&gt;We are given a batch file of passport information as our input. Each passport is separated by a blank line, and each item in the passport is separated by either a newline or a space. Example:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ecl:gry pid:860033327 eyr:2020 hcl:#fffffd
byr:1937 iyr:2017 cid:147 hgt:183cm

iyr:2013 ecl:amb cid:350 eyr:2023 pid:028048884
hcl:#cfa07d byr:1929

hcl:#ae17e1 iyr:2013
eyr:2024
ecl:brn pid:760753108 byr:1931
hgt:179cm

hcl:#cfa07d eyr:2025 pid:166559648
iyr:2011 ecl:brn hgt:59in
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Passport 1 is valid because it has all required fields&lt;/li&gt;
  &lt;li&gt;Passport 2 is invalid because it is missing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hgt&lt;/code&gt; field&lt;/li&gt;
  &lt;li&gt;Passport 3 is “valid” because it contains everything but &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cid&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Passport 4 is invalid because it is missing both the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cid&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;byr&lt;/code&gt; fields&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Our job is to find how many passports are either valid or “valid”&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/04/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub is-valid(%credentials) {
    my $passport-keys = set &amp;lt;byr iyr eyr hgt hcl ecl pid cid&amp;gt;;   # [1]
    my $north-pole-credentials = $passport-keys ⊖ 'cid';         # [2]

    my $keys = set %credentials.keys;

    $keys ~~ $passport-keys || $keys ~~ $north-pole-credentials; # [3]
}

sub MAIN($file) {
    say $file.IO
          .slurp
          .split(/\n\n/)
          .map(-&amp;gt; $entry {
              $entry
                .split(/&amp;lt;space&amp;gt;/)
                .map(*.split(':'))
                .map(-&amp;gt; ($key, $value) { $key.trim =&amp;gt; $value.trim })
                .Hash
          })
          .map(&amp;amp;is-valid)
          .grep(* == True)
          .elems;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
237
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;The hardest part to step one was getting our data out of the batch file and into a data structure (in this case, a list of hashes). You’ll notice this time we use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.slurp&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.lines&lt;/code&gt; to pull all the data into one string to manipulate it ourselves. Once we have the file as a string, we apply the following steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Split the data on 2 newlines (aka, a blank line between entries)&lt;/li&gt;
  &lt;li&gt;Then for each passport entry split on the the &lt;a href=&quot;https://docs.raku.org/language/regexes#Predefined_character_classes&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;space&amp;gt;&lt;/code&gt;&lt;/a&gt; character (which is an alias for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\s&lt;/code&gt;), giving us an inner list containing colon-separated key-value pairs&lt;/li&gt;
  &lt;li&gt;For each key-value pair, we split on the comma&lt;/li&gt;
  &lt;li&gt;We then take all our pairs and turn them into actual &lt;a href=&quot;https://docs.raku.org/type/Pair&quot;&gt;Pair&lt;/a&gt; objects&lt;/li&gt;
  &lt;li&gt;We use the Pair objects as an interim to convert each entry to a &lt;a href=&quot;https://docs.raku.org/type/Hash&quot;&gt;Hash&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;At this point, our sample input above would look something like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(
  {byr =&amp;gt; 1937, cid =&amp;gt; 147, ecl =&amp;gt; gry, eyr =&amp;gt; 2020, hcl =&amp;gt; #fffffd, hgt =&amp;gt; 183cm, iyr =&amp;gt; 2017, pid =&amp;gt; 860033327},
  {byr =&amp;gt; 1929, cid =&amp;gt; 350, ecl =&amp;gt; amb, eyr =&amp;gt; 2023, hcl =&amp;gt; #cfa07d, iyr =&amp;gt; 2013, pid =&amp;gt; 028048884},
  {byr =&amp;gt; 1931, ecl =&amp;gt; brn, eyr =&amp;gt; 2024, hcl =&amp;gt; #ae17e1, hgt =&amp;gt; 179cm, iyr =&amp;gt; 2013, pid =&amp;gt; 760753108},
  {ecl =&amp;gt; brn, eyr =&amp;gt; 2025, hcl =&amp;gt; #cfa07d, hgt =&amp;gt; 59in, iyr =&amp;gt; 2011, pid =&amp;gt; 166559648}
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We then map our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is-valid&lt;/code&gt; function over this list of hashes and count how many &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;s we get&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;...&amp;gt;&lt;/code&gt; syntax is a special way of making a list of strings. It implicitly quotes each space-separated entry. We then cast this list to a set.&lt;/li&gt;
  &lt;li&gt;Raku is big on Unicode operators, and I try to use them where I can. In this case, we are using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Symmetric_difference&quot;&gt;set difference&lt;/a&gt; operator commonly seen in mathematics classes. It gives us a new set containing everything except &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cid&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Now we have our valid and “valid” (entries that contain everything except Country ID) sets, so we just check if our current passport entry matches either one using the &lt;a href=&quot;https://docs.raku.org/language/operators#index-entry-smartmatch_operator&quot;&gt;smartmatch&lt;/a&gt; operator.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;So, after helping security out with their passport issue, now they’re starting to get suspicious that &lt;em&gt;too&lt;/em&gt; many people are getting through, so we need to tighten up our script.&lt;/p&gt;

&lt;p&gt;Now it needs to check both keys and values with the following stipulations:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Birth Year - Must be a 4-digit number between 1920 and 2002 (inclusive)&lt;/li&gt;
  &lt;li&gt;Issue Year - Must be a 4-digit number between 2010 and 2020 (inclusive)&lt;/li&gt;
  &lt;li&gt;Expiration Year - Must be a 4-digit number between 2020 and 2030 (inclusive)&lt;/li&gt;
  &lt;li&gt;Height - A number followed by either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cm&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt;, height must be between 59 and 76 (inclusive)&lt;/li&gt;
      &lt;li&gt;If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cm&lt;/code&gt;, height must be between 150 and 193 (inclusive)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Hair Color - Must be a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#&lt;/code&gt; character followed by exactly 6 characters &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0-9&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a-f&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Eye Color - Must be one of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;amb, blu, brn, grn, gry, hzl, oth&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Passport ID - 9-digit number including leading zeroes&lt;/li&gt;
  &lt;li&gt;Country ID - We still want to ignore this, or we won’t get through&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/04/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub is-valid(%credentials, $check-values) {
    my $passport-keys = set &amp;lt;byr iyr eyr hgt hcl ecl pid cid&amp;gt;;
    my $north-pole-credentials = $passport-keys ⊖ 'cid';

    my $keys = set %credentials.keys;
    my $valid-keys = $keys ~~ $passport-keys || $keys ~~ $north-pole-credentials;

    if $valid-keys &amp;amp;&amp;amp; $check-values {
        my ($byr, $iyr, $eyr, $hgt, $hcl, $ecl, $pid) = %credentials&amp;lt;byr iyr eyr hgt hcl ecl pid&amp;gt;.map(*.Str); # [1]

        my $valid-byr = so $byr ~~ /^&amp;lt;digit&amp;gt; ** 4$/ &amp;amp;&amp;amp; $byr.Int ∈ set (1920..2002); # [2][3]
        my $valid-iyr = so $iyr ~~ /^&amp;lt;digit&amp;gt; ** 4$/ &amp;amp;&amp;amp; $iyr.Int ∈ set (2010..2020);
        my $valid-eyr = so $eyr ~~ /^&amp;lt;digit&amp;gt; ** 4$/ &amp;amp;&amp;amp; $eyr.Int ∈ set (2020..2030);
        my $valid-hgt = gather {
            given $hgt {
                when /^(&amp;lt;digit&amp;gt;+)'in'$/ { take $/[0].Int ∈ set (59..76) }
                when /^(&amp;lt;digit&amp;gt;+)'cm'$/ { take $/[0].Int ∈ set (150..193) }
                default                 { take False }
            }
        }.head;
        my $valid-hcl = so $hcl ~~ /^'#'&amp;lt;xdigit&amp;gt; ** 6$/;                             # [4]
        my $valid-ecl = $ecl ∈ set &amp;lt;amb blu brn gry grn hzl oth&amp;gt;;
        my $valid-pid = so $pid ~~ /^&amp;lt;digit&amp;gt; ** 9$/;
        $valid-byr &amp;amp;&amp;amp; $valid-iyr &amp;amp;&amp;amp; $valid-eyr &amp;amp;&amp;amp; $valid-hgt &amp;amp;&amp;amp; $valid-hcl &amp;amp;&amp;amp; $valid-ecl &amp;amp;&amp;amp; $valid-pid;
    } else {
        $valid-keys;
    }
}

sub MAIN($file, Bool :$p2 = False) {
    say $file.IO
          .slurp
          .split(/\n\n/)
          .map(-&amp;gt; $entry {
              $entry
                .split(/&amp;lt;space&amp;gt;/)
                .map(*.split(':'))
                .map(-&amp;gt; ($key, $value) { $key.trim =&amp;gt; $value.trim })
                .Hash
          })
          .map(&amp;amp;is-valid.assuming(*, $p2)) # [5]
          .grep(* == True)
          .elems;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
237

# Part 2
$ raku main.raku --p2 input.txt
172
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;This solution could be faster by &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;short-circuiting&lt;/a&gt; after each check, but I was going for readability here, so it works.&lt;/p&gt;

&lt;p&gt;All that really changed from part 1 is our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is-valid&lt;/code&gt; check, and I feel the logic is fairly straight forward. We basically just unpack the items from our passport (assuming it has all the keys), then test the for validity using a combination of regexes and set containment operators. If all conditions are met, we return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;, else &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Because it is so straight forward, it was even more maddening when I was off by one. See #2 below for the trap I was falling into!&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;Hashes have a special syntax where you can provide multiple space-separated keys, and it will return all the values as a list. We then map these entries to strings and unpack them. Again, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;...&amp;gt;&lt;/code&gt; automatically quotes our keys, so we don’t have to.&lt;/li&gt;
  &lt;li&gt;Originally this line (along with the rest) looked like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(59..76).contains($byr.Int)&lt;/code&gt;. The logic is exactly the same, but this is apparently a &lt;a href=&quot;https://docs.raku.org/language/traps#Lists_become_strings,_so_beware_.contains()&quot;&gt;well-documented trap&lt;/a&gt;. Basically &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.contains&lt;/code&gt; does not test for presence of an element. It converts the list to a string and checks if the given substring exists within it. I don’t fully know which item was erroneously getting matched here, but it caused the outcome to be 173 instead of 172.&lt;/li&gt;
  &lt;li&gt;The solution to the above trap is to use set containment operators as shown here. Once again, we are using the Unicode operator, this time we use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Element_(mathematics)#Notation_and_terminology&quot;&gt;“is an element of”&lt;/a&gt; set operator.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;xdigit&amp;gt;&lt;/code&gt; is a built-in metacharacter for the characters &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0-9&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a-f&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A-F&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The way Raku handles &lt;a href=&quot;https://en.wikipedia.org/wiki/Partial_function&quot;&gt;partial functions&lt;/a&gt; is the &lt;a href=&quot;https://docs.raku.org/routine/assuming&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;assuming&lt;/code&gt;&lt;/a&gt; method, which allows you to fix one or more parameters when calling a subroutine.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I had a hard time tracking down that bug! I eventually got help from someone on the &lt;a href=&quot;http://reddit.com/r/rakulang&quot;&gt;Raku subreddit&lt;/a&gt; who was able to point me in the right direction.&lt;/p&gt;

&lt;p&gt;With that being said, I am really learning a lot through this exercise. In fact, I am noticing mistakes (or rather, code smells) in my previous solutions! I am not planning on editing them out though; it’s always good to see where you came from to remember how far you’ve come!&lt;/p&gt;

&lt;p&gt;See y’all for day 5!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Today’s challenge was a rough one for me. Not because of the challenge itself, but because I fell into a trap in the Raku language that was giving me an off-by-one error. See Part 2 for details!</summary></entry><entry><title type="html">Advent of Code: Day 3</title><link href="http://localhost:4000/blog/advent-of-code-day-03/" rel="alternate" type="text/html" title="Advent of Code: Day 3" /><published>2020-12-03T00:00:00-06:00</published><updated>2020-12-03T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-03</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-03/">&lt;p&gt;Today was the first problem that I felt lent itself naturally to a for-loop. While there is nothing wrong with a &lt;a href=&quot;https://two-wrongs.com/myth-of-the-day-functional-programmers-dont-use-loops&quot;&gt;for-loop in functional programming programming&lt;/a&gt;, I wanted to used one of the common substitutes in the functional programmer’s tool belt: recursion.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;We are going sledding this week! Our job is to get to the bottom of the mountain following a specific path, and to count how many trees we would run into along the way.&lt;/p&gt;

&lt;p&gt;Given a file that looks like the diagram below, we are to start in the top left of this file and traverse right three spaces and down one space until we hit the bottom, counting the number of hash signs (trees) we encounter.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...#..............#.#....#..#..
...#..#..#..............#..#...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Additionally, this is a magic mountain, so the pattern on each row repeats out to the right infinitely, and we have to account for that.&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/03/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub traverse(@mountain, $trees-encountered = 0, $i = 0, $j = 0) {
    if $i &amp;gt; @mountain.elems - 1 {
        $trees-encountered;
    } else {
        my $tree-hit = @mountain[$i][$j] cmp '#' == Same ?? 1 !! 0;
        if $i == @mountain.elems - 1 {
            $trees-encountered + $tree-hit;
        } else {
            traverse(@mountain, $trees-encountered + $tree-hit, $i + 1, $j + 3);
        }
    }
}

sub MAIN($file) {
    say traverse($file.IO.lines.map(-&amp;gt; $line { |$line.comb xx * })); # [1][2][3][4]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
191
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;Other than the below comments, I feel like this reads fairly easily. Basically, we turn our file into a list of infinite lists (described below) and then call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traverse&lt;/code&gt; on that outer list. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traverse&lt;/code&gt; is a &lt;a href=&quot;https://www.geeksforgeeks.org/tail-recursion/&quot;&gt;tail-recursive&lt;/a&gt; function with fairly simple logic:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If we have already passed the bottom, return the number of trees we hit&lt;/li&gt;
  &lt;li&gt;If we are at the bottom of the mountain, see if we are currently hitting a tree and then return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$trees-encountered&lt;/code&gt; with the last tree included&lt;/li&gt;
  &lt;li&gt;Otherwise, add the current tree hit to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$trees-encountered&lt;/code&gt; and go down one row and to the right three columns&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt; has a special meaning when used in front of a list. It flattens any inner lists to the top level. So, for example, if we had &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|((1, 2), (3, 4))&lt;/code&gt;, that would equal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 2, 3, 4)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Reminder that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.comb&lt;/code&gt; splits the input into a list of characters.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xx&lt;/code&gt; is a special operator that takes the input list and concatenates it to itself &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; times (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N = *&lt;/code&gt; here; see below). So, for example, if we had &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 2) xx 2&lt;/code&gt;, that would yield &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((1, 2), (1, 2))&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xx&lt;/code&gt; allows the &lt;a href=&quot;https://docs.raku.org/type/Whatever&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Whatever&lt;/code&gt;&lt;/a&gt; character (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;) on the right-hand side, and in that case it returns a lazy, infinite concatenation of the left-hand side.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So, to summarize the above comments, we take the line and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comb&lt;/code&gt; it to a list. Then, we concatenate that list infinitely to have a list of lists, which we flatten using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt; operator. Since this happens in a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;, it applies to each line, so we have one finite outer list containing multiple infinite lists. We then traverse the outer list.&lt;/p&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;Given the same file as before, we want to tackle it with five different traversals:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Right 1, down 1&lt;/li&gt;
  &lt;li&gt;Right 3, down 1 (This is the slope we already checked)&lt;/li&gt;
  &lt;li&gt;Right 5, down 1&lt;/li&gt;
  &lt;li&gt;Right 7, down 1&lt;/li&gt;
  &lt;li&gt;Right 1, down 2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then, we must find the product of all the trees we hit with each traversal&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/03/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub traverse(@mountain, $i-increment, $j-increment, $trees-encountered = 0, $i = 0, $j = 0) {
    if $i &amp;gt; @mountain.elems - 1 {
        $trees-encountered;
    } else {
        my $tree-hit = @mountain[$i][$j] cmp '#' == Same ?? 1 !! 0;
        if $i == @mountain.elems - 1 {
            $trees-encountered + $tree-hit;
        } else {
            traverse(
                @mountain,
                $i-increment,
                $j-increment,
                $trees-encountered + $tree-hit,
                $i + $i-increment,
                $j + $j-increment
            );
        }
    }
}

sub MAIN($file, Bool :$p2 = False) {
    my @traversals = $p2 ?? (
        (1, 1),
        (1, 3),
        (1, 5),
        (1, 7),
        (2, 1)      # [1]
    ) !! ((1, 3),); # [2]
    say [*] @traversals.map(-&amp;gt; ($i-increment, $j-increment) {
        traverse($file.IO.lines.map(-&amp;gt; $line { |$line.comb xx * }), $i-increment, $j-increment)
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
191

# Part 2
$ raku main.raku --p2 input.txt
1478615040
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;Again, we are able to tweak our code slightly and handle both parts one and two in one block. In this case, we added two arguments to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traverse&lt;/code&gt; to tell it the row step-size and column step-size. We then just add the list of lists corresponding to the five traversals noted above, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; over them and calculate the product using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[*]&lt;/code&gt; operator! In the case of part one, it is a list of size one, so &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[*]&lt;/code&gt; will just return the single element.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;The input file has 323 lines, so we will hit the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$i &amp;gt; @mountain.elems - 1&lt;/code&gt; case with this traversal, so it is a good thing we generalized it in the previous step!&lt;/li&gt;
  &lt;li&gt;Need this to be a list of lists to map over it, so we need the comma to denote the outer list is of size one.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I felt this problem came very serendipitously; I was &lt;em&gt;just&lt;/em&gt; reading about the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xx&lt;/code&gt; operators last night, so I am glad I got to put them to use. Recursion (and more specifically tail recursion) is always a fun approach, and it let us tackle this problem functionally. 3 for 3! Let’s see what tomorrow brings.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Today was the first problem that I felt lent itself naturally to a for-loop. While there is nothing wrong with a for-loop in functional programming programming, I wanted to used one of the common substitutes in the functional programmer’s tool belt: recursion.</summary></entry><entry><title type="html">Advent of Code: Day 2</title><link href="http://localhost:4000/blog/advent-of-code-day-02/" rel="alternate" type="text/html" title="Advent of Code: Day 2" /><published>2020-12-02T00:00:00-06:00</published><updated>2020-12-02T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-02</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-02/">&lt;p&gt;We’re back again with another functional Raku solution! This problem requires some text parsing as well, which is where Raku (and its older brother Perl) really shine, so that was quite a bit of fun to utilize. Let’s dive right in!&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;Given a file full of lines that look like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1-3 a: ababa
10-14 q: qqqqqqqqq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Which can be interpreted as a password policy that reads as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The password &quot;ababa&quot; must contain between 1 and 3 (inclusive) &quot;a&quot; characters
The password &quot;qqqqqqqqqq&quot; must contain between 10 and 14 (inclusive) &quot;q&quot; characters
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our job is to find how many passwords are &lt;strong&gt;valid&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/02/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;grammar PasswordEntry {
    token TOP { ^(&amp;lt;digit&amp;gt;+)'-'(&amp;lt;digit&amp;gt;+) &amp;lt;.ws&amp;gt; (&amp;lt;[a..z]&amp;gt;)':' &amp;lt;.ws&amp;gt; (&amp;lt;[a..z]&amp;gt;+)$ } # [1]
}

grammar PasswordEntryActions {
    method TOP($/) {                                                          # [2]
        my $range-start  = $/[0].Int;
        my $range-end    = $/[1].Int;
        my $target       = $/[2].Str;
        my $password     = $/[3].Str;
        my $target-count = $password.comb($target).elems;                     # [3]
        make so $range-start &amp;lt;= $target-count &amp;amp;&amp;amp; $target-count &amp;lt;= $range-end;
    }
}

sub MAIN($file) {
    my $actions = PasswordEntryActions.new;
    say $file.IO.lines
          .map(-&amp;gt; $row { PasswordEntry.parse($row, :$actions).made }) # [4]
          .grep(* == True)                                            # [5]
          .elems;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
393
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;We do a couple of things here:&lt;/p&gt;

&lt;p&gt;First we pull in all the lines in the file, then parse them using our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PasswordEntry&lt;/code&gt; grammar. See below for the explanation on the grammar.&lt;/p&gt;

&lt;p&gt;When we parse each line, we specify what actions should take place with the parsed text (in this case, we pass it to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PasswordEntryActions&lt;/code&gt; to do post-processing). &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PasswordEntryActions&lt;/code&gt; takes the input (a &lt;a href=&quot;https://docs.raku.org/type/Match&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Match&lt;/code&gt;&lt;/a&gt; object), and determines if the parsed password contains the right number of target characters.&lt;/p&gt;

&lt;p&gt;These are then filtered down to only those that &lt;em&gt;do&lt;/em&gt; contain the right number of characters (valid passwords) and counted.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;We could just define a regex like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;my $regex = /pattern/&lt;/code&gt;, but I wanted to combine the parse step &lt;em&gt;and&lt;/em&gt; the business logic of determining if it is a valid password; we will get into that second part below.
    &lt;ul&gt;
      &lt;li&gt;When defining a grammar, you always have to define a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TOP&lt;/code&gt; token the encompasses everything. If I had a more complex grammar, I could define subtokens that could be used in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TOP&lt;/code&gt; token (or any other defined tokens).&lt;/li&gt;
      &lt;li&gt;For the non-regex folks, the way this reads is:
        &lt;ul&gt;
          &lt;li&gt;Start of line&lt;/li&gt;
          &lt;li&gt;An integer (captured group, see below)&lt;/li&gt;
          &lt;li&gt;Followed by a dash&lt;/li&gt;
          &lt;li&gt;Followed by an integer (captured group, see below)&lt;/li&gt;
          &lt;li&gt;Followed by a space&lt;/li&gt;
          &lt;li&gt;Followed by a single lowercase letter (captured group, see below)&lt;/li&gt;
          &lt;li&gt;Followed by a colon&lt;/li&gt;
          &lt;li&gt;Followed by a space&lt;/li&gt;
          &lt;li&gt;Followed by one or more lowercase letters (captured group, see below)&lt;/li&gt;
          &lt;li&gt;End of line&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Additionally, you’ll notice the four sets of parentheses that define &lt;em&gt;capture groups&lt;/em&gt;, meaning when this grammar parses a line successfully, it will return the four groups in an array.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;When we use the parser (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PasswordEntry.parse&lt;/code&gt;), we are able to supply this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;actions&lt;/code&gt; class that has methods corresponding to the tokens in the parser. This is where any business logic should take place. For example, any type casting or object creation to be used in the outer scope. In this case, like I said above, we want to parse and reduce to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt; in one pass. So what our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TOP&lt;/code&gt; method does is take the match &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$/&lt;/code&gt; (this is a special variable, I would never name something like this), extract the four groups defined in the grammar, and cast them to the correct types. We then count the number of times the target appears in the password and see if it is in range.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comb&lt;/code&gt; takes a string and turns it into a list of characters. When supplied with a string argument (in this case, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$target&lt;/code&gt;), it turns the string into a list &lt;em&gt;and&lt;/em&gt; filters it down to elements that equal the supplied character.&lt;/li&gt;
  &lt;li&gt;There is some special syntax happening on this line. I could have written &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PasswordEntry.parse($row, actions =&amp;gt; $actions)&lt;/code&gt;, and used &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$actions&lt;/code&gt; as a named keyword. But, since my variable has the same name as the target argument, I am able to pass it in as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:$actions&lt;/code&gt;. It reminds me of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;**kwargs&lt;/code&gt; in Python.&lt;/li&gt;
  &lt;li&gt;I &lt;em&gt;hate&lt;/em&gt; that I have to say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;* == True&lt;/code&gt;, but &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt; would not work otherwise, so I guess that is just an edge case.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;Given the same file as before, the interpretation of the lines has changed. Given the same lines as above, the interpretation should now be:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The password &quot;ababa&quot; must contain an &quot;a&quot; character in position 1 or 3 (but not both)
The password &quot;qqqqqqqqqq&quot; must contain a &quot;q&quot; character in position 10 or 14 (but not both)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; These strings are 1-indexed instead of 0-indexed, so we have to account for that.&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/02/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;grammar PasswordEntry {
    token TOP { ^(&amp;lt;digit&amp;gt;+)'-'(&amp;lt;digit&amp;gt;+) &amp;lt;.ws&amp;gt; (&amp;lt;[a..z]&amp;gt;)':' &amp;lt;.ws&amp;gt; (&amp;lt;[a..z]&amp;gt;+)$ }
}

class PartOneActions {
    method TOP($/) {
        my $range-start  = $/[0].Int;
        my $range-end    = $/[1].Int;
        my $target       = $/[2].Str;
        my $password     = $/[3].Str;
        my $target-count = $password.comb($target).elems;
        make so $range-start &amp;lt;= $target-count &amp;amp;&amp;amp; $target-count &amp;lt;= $range-end;
    }
}

class PartTwoActions {
    method TOP($/) {
        my $position-one = $/[0].Int - 1;
        my $position-two = $/[1].Int - 1;
        my $target       = $/[2].Str;
        my @password     = $/[3].Str.comb;
        make so (
            (@password[$position-one] cmp $target) == Same # [1][2]
            xor                                            # [3]
            (@password[$position-two] cmp $target) == Same
        );
    }
}

sub MAIN($file, Bool :$p2 = False) {
    my $actions = $p2 ?? PartTwoActions.new !! PartOneActions.new;
    say $file.IO.lines
          .map(-&amp;gt; $row { PasswordEntry.parse($row, :$actions).made })
          .grep(* == True)
          .elems;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
393

# Part 2
$ raku main.raku --p2 input.txt
690
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;Similarly to &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-01/&quot;&gt;day 1&lt;/a&gt;, we can utilize the code already written and tweak it a little bit. In this case, the grammar stays the same, but the actions taken on each line need to change.&lt;/p&gt;

&lt;p&gt;Again, we provide the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--p2&lt;/code&gt; flag, and then add the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PartTwoActions&lt;/code&gt; class to handle the business logic for the new interpretation of the password policy.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;I had to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmp&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt; here to get proper string comparison (otherwise, Raku tries to cast strings to hexadecimal).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmp&lt;/code&gt; returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Less&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;More&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Same&lt;/code&gt; instead of a boolean. I couldn’t find a way to cast &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Same&lt;/code&gt; to a boolean, because it casts it as such &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Same -&amp;gt; 0 -&amp;gt; False&lt;/code&gt;, when what we really want is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;, so I had to add the ugly &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;== Same&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt; is a junction operator in Raku, so it has the handy dandy &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xor&lt;/code&gt; operator utilized here.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Another functional and (in my opinion) beautiful solution! In my day job, I actually maintain a grammar defined using &lt;a href=&quot;https://www.antlr.org/&quot;&gt;ANTLR&lt;/a&gt;, so it is fun to see tools with the same concepts in other languages. Looking forward to getting to use grammars more in Raku. See y’all tomorrow!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">We’re back again with another functional Raku solution! This problem requires some text parsing as well, which is where Raku (and its older brother Perl) really shine, so that was quite a bit of fun to utilize. Let’s dive right in!</summary></entry><entry><title type="html">Advent of Code: Day 1</title><link href="http://localhost:4000/blog/advent-of-code-day-01/" rel="alternate" type="text/html" title="Advent of Code: Day 1" /><published>2020-12-01T00:00:00-06:00</published><updated>2020-12-01T07:40:30-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-01</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-01/">&lt;p&gt;Turns out I started blogging just in time for the &lt;a href=&quot;https://adventofcode.com/&quot;&gt;Advent of Code&lt;/a&gt;, an annual series of daily challenges that run from December 1st to December 25th.&lt;/p&gt;

&lt;p&gt;These problems remind me a lot of &lt;a href=&quot;https://projecteuler.net/&quot;&gt;Project Euler&lt;/a&gt;, because they are not concerned with the readability or speed of your code, just the output. That means that any goals one wishes to accomplish should be set personally (there &lt;em&gt;is&lt;/em&gt; technically a leaderboard, but I find you have to be online very late at night to catch the posts, and it is not worth the stress during the holiday season).&lt;/p&gt;

&lt;p&gt;My goal, as you may have guessed from my previous posts, is to complete these challenges in &lt;em&gt;at least&lt;/em&gt; Raku and to do so utilizing a functional programming paradigm. Let’s dive into day 1 and see if I can do it!&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;p&gt;I am not going to copy and paste the explanation of the problem here like I do for the Perl Weekly Challenge, because it is &lt;em&gt;so&lt;/em&gt; long, and I want to encourage users to go attempt the challenge themselves! Instead, I will write a summary of what the challenge is and my solution.&lt;/p&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;Given a file full of integers (one per line), find the single pair of integers that adds up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2020&lt;/code&gt;, then find the product of those two numbers.&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/01/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($file) {
    say $file.IO.lines                           # [1]
          .combinations(2)                       # [2]
          .grep(-&amp;gt; ($a, $b) { $a + $b == 2020 }) # [3]
          .map(-&amp;gt; ($a, $b) { $a * $b })          # [4]
          .head;                                 # [5]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
1020036
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;This is fairly straight forward, and I feel Raku reads very cleanly. Basically, we read the entire file into a list (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.lines&lt;/code&gt;), then find all the pairs in that list, filter those pairs down to where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a + $b == 2020&lt;/code&gt;, then multiply those two numbers together!&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;I’m a sucker for good IO. I feel reading/writing files in languages like Java or Scala is so cumbersome that I try to avoid it at all costs. Languages like Raku were &lt;em&gt;built&lt;/em&gt; for text manipulation, so it makes sense that the IO is great, but I just wanted to call out how easy it is to get the lines of a file in a list.&lt;/li&gt;
  &lt;li&gt;As I said in my &lt;a href=&quot;https://aaronreidsmith.github.io/blog/perl-weekly-challenge-089/#specific-comments&quot;&gt;previous post&lt;/a&gt;, I see the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;combinations&lt;/code&gt; feature coming back a lot in these puzzles. I love that it is built right in.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt; is familiar to most &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*nix&lt;/code&gt; users, and it is the equivalent of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter&lt;/code&gt; in more traditional functional languages. In this case, we are filtering down to only pairs that add up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2020&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;At this point this list looks like this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(($a, $b))&lt;/code&gt;, so we still want to map over the outer list and multiply the pair together.&lt;/li&gt;
  &lt;li&gt;Since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; returns a list, we need to grab the first item from that list for pretty printing.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;Given the same file as before, find the &lt;em&gt;3&lt;/em&gt; numbers that add up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2020&lt;/code&gt; and find their product.&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/01/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($file, Bool :$p2 = False) {                # [1]
    say $file.IO.lines
          .combinations($p2 ?? 3 !! 2)              # [2]
          .grep(-&amp;gt; @combo { ([+] @combo) == 2020 }) # [3]
          .map(-&amp;gt; @combo { [*] @combo })
          .head;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
1020036

# Part 2
$ raku main.raku --p2 input.txt
286977330
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;Since it is basically the same problem, it only makes sense to modify the script we have already written rather than starting from scratch. Basically, everywhere where we hardcoded &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a, $b&lt;/code&gt; needs to be generalized to some list. In this case, we added a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p2&lt;/code&gt; CLI flag that allows the users to specify if they are doing part 1 or part 2. If they are doing part 2 we find trios instead of pairs, then perform the same “business logic” on that collection.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;Using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:$p2&lt;/code&gt; notation says to Raku “create a command line flag called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--p2&lt;/code&gt; and assign it to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$p2&lt;/code&gt; with a default of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;”. Creating command line interfaces can be kind of a pain in a lot of languages, so I am happy that is built right into the language.&lt;/li&gt;
  &lt;li&gt;This is the check to see if we are doing part 1 or part 2. Raku’s ternary operator is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;condition ?? true !! false&lt;/code&gt; rather than the traditional &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;condition ? true : false&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Since we have to remove all the pair hard-coding, we can generalize it as a list called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@combo&lt;/code&gt; and then just find the sum of the entire combo using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[+]&lt;/code&gt; meta operator. We perform a similar generalization for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; step.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;So far so good with my goal to write Raku solutions functionally! Check my &lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code&quot;&gt;GitHub&lt;/a&gt; to see any other solutions (and any other languages, if I get around to them). This was a fun little dip into the Advent of Code, and I am looking forward to the rest of the month!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Turns out I started blogging just in time for the Advent of Code, an annual series of daily challenges that run from December 1st to December 25th.</summary></entry><entry><title type="html">Perl Weekly Challenge 89</title><link href="http://localhost:4000/blog/perl-weekly-challenge-089/" rel="alternate" type="text/html" title="Perl Weekly Challenge 89" /><published>2020-11-30T00:00:00-06:00</published><updated>2020-12-01T07:40:30-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-089</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-089/">&lt;p&gt;Back again with challenge 89! I was able to tackle this one the day it was released, but I doubt that will be the case going forward.&lt;/p&gt;

&lt;p&gt;Once again, it seems the first task can be tackled easily in a functional way, and the second one ends up being more imperative. Hoping I can try to do more things functionally in the future!&lt;/p&gt;

&lt;h2 id=&quot;task-1-gcd-sum&quot;&gt;Task 1: GCD Sum&lt;/h2&gt;

&lt;p&gt;You are given a positive integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to sum &lt;a href=&quot;https://en.wikipedia.org/wiki/Greatest_common_divisor&quot;&gt;GCD&lt;/a&gt; of all possible unique pairs between 1 and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 3
Output: 3

gcd(1,2) + gcd(1,3) + gcd(2,3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 4
Output: 7

gcd(1,2) + gcd(1,3) + gcd(1,4) + gcd(2,3) + gcd(2,4) + gcd(3,4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-089/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($N where $N ~~ Int &amp;amp;&amp;amp; $N &amp;gt; 0) {
    my @pairs = (1..$N).combinations(2);                    # [1]
    say [+] @pairs.map(-&amp;gt; @pair { @pair[0] gcd @pair[1] }); # [2][3]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 3
3

$ raku ch-1.raku 4
7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The thought process here is pretty straight forward:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Find all pairs from 1 to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Find the GCD of each pair&lt;/li&gt;
  &lt;li&gt;Sum the GCDs produced in step 2&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You’ll see my functional programming background bubbling up again. In fact, this could honestly be a one-liner if I weren’t going for readability:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;say [+] (1..$N).combinations(2).map(-&amp;gt; @pair { @pair[0] gcd @pair[1] });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Raku provided a great subroutine to find all the pairs in a list (&lt;a href=&quot;https://docs.raku.org/routine/combinations&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;combinations&lt;/code&gt;&lt;/a&gt;). In fact, it is generalized such that you can take more than just pairs (if I didn’t provide a number, it would find &lt;em&gt;all&lt;/em&gt; combinations from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size=0&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size=$N&lt;/code&gt;), so it may come back in future problems!&lt;/li&gt;
  &lt;li&gt;This was an interesting one for me. In Scala, since it is so strongly and statically typed, we know that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@pairs&lt;/code&gt; list contains lists itself, so you could just say: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pairs.map(_._1 gcd _._2)&lt;/code&gt;. In Raku, I had to use the &lt;a href=&quot;https://docs.raku.org/language/functions#Blocks_and_lambdas&quot;&gt;pointy block&lt;/a&gt; notation to give the mapped items a name and, more importantly, a sigil to treat it as a list.&lt;/li&gt;
  &lt;li&gt;I &lt;em&gt;love&lt;/em&gt; that a lot of simple things (like &lt;a href=&quot;https://docs.raku.org/routine/gcd&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gcd&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.raku.org/routine/is-prime&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is-prime&lt;/code&gt;&lt;/a&gt;) are built right into Raku. It saves a lot of boilerplate code and potentially bad implementation of these functions.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-magic-matrix&quot;&gt;Task 2: Magic Matrix&lt;/h2&gt;

&lt;p&gt;Write a script to display matrix as below with numbers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 - 9&lt;/code&gt;. Please make sure numbers are used once.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ a b c ]
[ d e f ]
[ g h i ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So that it satisfies the following:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a + b + c = 15
d + e + f = 15
g + h + i = 15
a + d + g = 15
b + e + h = 15
c + f + i = 15
a + e + i = 15
c + e + g = 15
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-089/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset OddPositiveInt of Int where { $_ ~~ Int &amp;amp;&amp;amp; $_ &amp;gt; 0 &amp;amp;&amp;amp; !($_ %% 2) }

sub MAIN($side-length where $side-length ~~ OddPositiveInt = 3, $debug where $debug ~~ Bool = False) {
    my @matrix = generate-matrix($side-length);
    my @filled-in-matrix = fill-in-matrix(@matrix, $side-length);
    for @filled-in-matrix -&amp;gt; @row {
        say '[ ' ~ @row.join(' ') ~ ' ]';
    }
    if $debug {
        print &quot;\n&quot;;
        validate-matrix(@filled-in-matrix, $side-length);
    }
}

# Generate a 2D matrix that we can fill in with the proper numbers.
# For 3x3 it would output:
#  [0 0 0]
#  [0 0 0]
#  [0 0 0]
sub generate-matrix($side-length) {
    my @matrix = Array.new;
    for ^$side-length -&amp;gt; $i {
        my @row = Array.new;
        for (($i * $side-length) + 1..($i * $side-length) + $side-length) {
            @row.push(0);
        }
        @matrix.push(@row);
    }
    @matrix
}

# Actual business logic here. It takes the empty array and fills it in to be &quot;magic&quot;
# Such that all rows, columns, and the two diagonals add up to $side-length * ($side-length² + 1) / 2
sub fill-in-matrix(@matrix, $side-length) {
    my $num = 1;
    my $row = floor($side-length / 2);
    my $col = $side-length - 1;

    while $num &amp;lt;= $side-length² {                # [1]
        if $row == -1 &amp;amp;&amp;amp; $col == $side-length {  # Condition 3 (see below)
            $col = $side-length - 2;
            $row = 0;
        } else {
            if $col == $side-length {            # Condition 1 (see below)
                $col = 0;
            }
            if $row &amp;lt; 0 {
                $row = $side-length - 1;
            }
        }
        if @matrix[$row][$col] != 0 {           # Condition 2 (see below)
            $col -= 2;
            $row++;
        } else {
            @matrix[$row][$col] = $num;
            $num++;
            $col++;
            $row--;
        }
    }
    @matrix;
}

# Helper function to validate output matrix and print the validation
sub validate-matrix(@matrix, $side-length) {
    my @rows = @matrix;
    my @columns = [Z] @matrix;                                                   # [2]
    my @diagonal = @matrix.kv.map(-&amp;gt; $i, @row { @row[$i] });
    my @counter-diagonal = @matrix.kv.map(-&amp;gt; $i, @row { @row[*-$i-1] });

    my $target = ($side-length * ($side-length² + 1) / 2).Int;

    my $valid-rows = so @rows.map(-&amp;gt; @row { [+] @row }).all == $target;          # [3]
    my $valid-cols = so @columns.map(-&amp;gt; @column { [+] @column }).all == $target;
    my $valid-diag = so ([+] @diagonal) == $target;
    my $valid-counter-diag = so ([+] @counter-diagonal) == $target;

    if $valid-rows &amp;amp;&amp;amp; $valid-cols &amp;amp;&amp;amp; $valid-diag &amp;amp;&amp;amp; $valid-counter-diag {
        for @rows -&amp;gt; @row {
            say @row.join(' + ') ~ ' = ' ~ $target;
        }
        for @columns -&amp;gt; @column {
            say @column.join(' + ') ~ ' = ' ~ $target;
        }
        say @diagonal.join(' + ') ~ ' = ' ~ $target;
        say @counter-diagonal.join(' + ') ~ ' = ' ~ $target;
    } else {
        die &quot;Not a valid magic matrix&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku
[ 2 7 6 ]
[ 9 5 1 ]
[ 4 3 8 ]

# There is an optional `debug` parameter that can be supplied, but the `side-length` argument must also be provided
$ raku ch-2.raku 3 True
[ 2 7 6 ]
[ 9 5 1 ]
[ 4 3 8 ]

2 + 7 + 6 = 15
9 + 5 + 1 = 15
4 + 3 + 8 = 15
2 + 9 + 4 = 15
7 + 5 + 3 = 15
6 + 1 + 8 = 15
2 + 5 + 8 = 15
6 + 5 + 4 = 15
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It should be noted this program only works with odd side-length squares&lt;/p&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Full disclosure, I have done this problem before, so I basically just ported some old code. There are two steps to this problem before we even get to implementation:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Find the pattern for what the sum is
    &lt;ul&gt;
      &lt;li&gt;As seen in the code, you will find it is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N(N²+1)/2&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Draw some “magic matrices” to see if you can find any patterns&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You will find 3 patterns hold true (I am copying these from &lt;a href=&quot;https://www.geeksforgeeks.org/magic-square/&quot;&gt;Geeks for Geeks&lt;/a&gt;):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The position of next number is calculated by decrementing row number of the previous number by 1, and incrementing the column number of the previous number by 1. At any time, if the calculated row position becomes -1, it will wrap around to n-1. Similarly, if the calculated column position becomes n, it will wrap around to 0.&lt;/li&gt;
  &lt;li&gt;If the magic square already contains a number at the calculated position, calculated column position will be decremented by 2, and calculated row position will be incremented by 1.&lt;/li&gt;
  &lt;li&gt;If the calculated row position is -1 &amp;amp; calculated column position is n, the new position would be: (0, n-2).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Basically, we just start in the middle right square and apply the above criteria iteratively, and it works for any odd-side-lengthed square.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Raku supports Unicode, so you’ll notice I used &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$side-length²&lt;/code&gt; rather than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$side-length ** 2&lt;/code&gt;. It’s a small feature that I find helps readabilty (but can be hard to write)!&lt;/li&gt;
  &lt;li&gt;This has been called out as a &lt;a href=&quot;https://docs.raku.org/language/traps#Using_[%E2%80%A6]_metaoperator_with_a_list_of_lists&quot;&gt;trick to avoid&lt;/a&gt; because it fails when you get a matrix with 1 row. Since it is being used in a debugging function and if we &lt;em&gt;did&lt;/em&gt; get a 1-row matrix it would be 1x1, so I think it is safe to use here&lt;/li&gt;
  &lt;li&gt;I don’t really like that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;so&lt;/code&gt; is the subroutine used to cast input to a boolean, so I just wanted to call out that (a) that is what these lines are doing and (b) I don’t like the terminology.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I’m really glad I decided to start doing these challenges weekly, and I may even go back and attempt old challenges if I have time.&lt;/p&gt;

&lt;p&gt;With that being said, I am kind of disappointed in myself for just copying old code for task two. For one, I have grown as a programmer since writing that, and two, it seems past-me just copied that code from somewhere on the internet. While it was kind of challenging porting it to Raku, I feel like it was the lazy way out.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Back again with challenge 89! I was able to tackle this one the day it was released, but I doubt that will be the case going forward.</summary></entry><entry><title type="html">Perl Weekly Challenge 88</title><link href="http://localhost:4000/blog/perl-weekly-challenge-088/" rel="alternate" type="text/html" title="Perl Weekly Challenge 88" /><published>2020-11-29T00:00:00-06:00</published><updated>2020-12-01T07:40:30-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-088</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-088/">&lt;p&gt;I have always been a fan of Perl (and its younger brother Raku), but, since leaving the Bioinformatics world, have not found any real-world scenarios to flex those muscles.&lt;/p&gt;

&lt;p&gt;I recently stumbled upon the &lt;a href=&quot;https://perlweeklychallenge.org/&quot;&gt;Perl Weekly Challenge&lt;/a&gt; and decided it would be a great way to keep up-to-date with the community. I participated for the first time this week and thought it would be fun to do a write-up of how I approached the problems. In the future, I will start publishing my blogs earlier in the week so that I can include a link to it in my PR.&lt;/p&gt;

&lt;p&gt;So, without further ado, let’s dive in.&lt;/p&gt;

&lt;h2 id=&quot;task-1-array-of-product&quot;&gt;Task 1: Array of Product&lt;/h2&gt;

&lt;p&gt;You are given an array of positive integers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to return an array &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@M&lt;/code&gt; where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$M[i]&lt;/code&gt; is the product of all elements of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt; except the index &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N[i]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    @N = (5, 2, 1, 4, 3)
Output:
    @M = (24, 60, 120, 30, 40)

    $M[0] = 2 x 1 x 4 x 3 = 24
    $M[1] = 5 x 1 x 4 x 3 = 60
    $M[2] = 5 x 2 x 4 x 3 = 120
    $M[3] = 5 x 2 x 1 x 3 = 30
    $M[4] = 5 x 2 x 1 x 4 = 40
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    @N = (2, 1, 4, 3)
Output:
    @M = (12, 24, 6, 8)

    $M[0] = 1 x 4 x 3 = 12
    $M[1] = 2 x 4 x 3 = 24
    $M[2] = 2 x 1 x 3 = 6
    $M[3] = 2 x 1 x 4 = 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset PositiveInt of Int where { $_ ~~ Int &amp;amp;&amp;amp; $_ &amp;gt; 0 } # [1]

sub MAIN(*@N where all(@N) ~~ PositiveInt &amp;amp;&amp;amp; @N.elems &amp;gt; 0) {
    my $product = [*] @N;         # [2]
    my @M = @N.map: $product / *; # [3]
    say @M;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 5 2 1 4 3
[24 60 120 30 40]

$ raku ch-1.raku 2 1 4 3
[12 24 6 8]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;My day job is 100% Scala, so I try to approach everything with an immutable and functional approach, ideally with only one pass through the input list.&lt;/p&gt;

&lt;p&gt;The approach I took reminded me of multiplying fractions by the unit fraction to remove the denominator. For example &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1/4 x 4/4 = 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is the approach applied to example 1 above:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$M[0] = (5 x 2 x 1 x 4 x 3) / 5 = 24
$M[1] = (5 x 2 x 1 x 4 x 3) / 2 = 60
$M[2] = (5 x 2 x 1 x 4 x 3) / 1 = 120
$M[3] = (5 x 2 x 1 x 4 x 3) / 4 = 30
$M[4] = (5 x 2 x 1 x 4 x 3) / 3 = 40
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The problem states we are given an array of positive integers, but it never hurts to validate. Raku gives us the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subset&lt;/code&gt; keyword to easily define subsets of other types. In this case, the element has to be an integer and must be greater than 0. We then use this subset in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; subroutine’s signature.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As we can see from the modifications to example 1 above, we will always have the product of all items in the numerator and current item in the denominator. We just want to calculate that once, and Raku gives us a simple way of doing that through it’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[*]&lt;/code&gt; operator.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This line shows my functional programming background bubbling up. Basically, for each item in the list, we want &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$product / $item&lt;/code&gt;, and we want the output collected into a list. This is a &lt;em&gt;textbook&lt;/em&gt; case for a map function, so you can see that is what I went with.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;To a non-Raku user, this may be a little confusing because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; in a map &lt;em&gt;literally&lt;/em&gt; means &lt;a href=&quot;https://docs.raku.org/type/Whatever&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;whatever&lt;/code&gt;&lt;/a&gt; (more specifically, “whatever input I received”) and &lt;em&gt;not&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multiply&lt;/code&gt;. The Scala equivalent would be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N.map(item =&amp;gt; product / item)&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-spiral-matrix&quot;&gt;Task 2: Spiral Matrix&lt;/h2&gt;

&lt;p&gt;You are given &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m x n&lt;/code&gt; matrix of positive integers.&lt;/p&gt;

&lt;p&gt;Write a script to print spiral matrix as list.&lt;/p&gt;

&lt;h3 id=&quot;example-1-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    [ 1, 2, 3 ]
    [ 4, 5, 6 ]
    [ 7, 8, 9 ]
Ouput:
    [ 1, 2, 3, 6, 9, 8, 7, 4, 5 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2-1&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    [  1,  2,  3,  4 ]
    [  5,  6,  7,  8 ]
    [  9, 10, 11, 12 ]
    [ 13, 14, 15, 16 ]
Output:
    [ 1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset PositiveInt of Int where { $_ ~~ Int &amp;amp;&amp;amp; $_ &amp;gt; 0 }

enum Direction &amp;lt;NORTH EAST SOUTH WEST&amp;gt;;

sub MAIN(*@input where all(@input) ~~ PositiveInt &amp;amp;&amp;amp; @input.elems &amp;gt; 0) {
    # Ensure our input is exactly square
    my $side-length = @input.elems.sqrt;
    $side-length.Int == $side-length or die &quot;Must be a square matrix&quot;;

    # Turn our CLI input into a list of lists (containing both the value and a flag for if we have visted it)
    my @matrix = gather {
        loop (my $i = 0; $i &amp;lt; @input.elems; $i += $side-length) {
            my @row = @input[$i..^$i + $side-length].map({ Hash.new('value', $_, 'visited', False) });
            take @row;
        }
    }

    # Output list and helper function for adding to it
    my @output;
    sub visit-cell($i, $j) {
        my %cell = @matrix[$i][$j];
        if !%cell{'visited'} {
            @output.push(%cell{'value'});
        }
        @matrix[$i][$j]{'visited'} = True;
    }

    # Control vars used below
    my ($min-row, $min-col) = 0, 0;
    my ($max-row, $max-col) = @matrix.elems - 1, @matrix.tail.elems - 1;
    my ($current-row, $current-col, $current-direction) = $min-row, $min-col, EAST;

    # Iterate through matrix in the given directions. Check if we are in a corner or if we have already
    # visited the next cell to determine if we should turn
    while @output.elems != @input.elems {
        visit-cell($current-row, $current-col);
        given $current-direction {
            when EAST {
                if $current-col == $max-col || @matrix[$current-row][$current-col+1]{'visited'} {
                    $current-direction = SOUTH;
                    $current-row += 1;
                } else {
                    $current-col += 1;
                }
            }
            when SOUTH {
                if ($current-row == $max-row &amp;amp;&amp;amp; $current-col == $max-col) || @matrix[$current-row+1][$current-col]{'visited'} {
                    $current-direction = WEST;
                    $current-col -= 1;
                } else {
                    $current-row += 1;
                }
            }
            when WEST {
                if $current-col == $min-col || @matrix[$current-row][$current-col-1]{'visited'} {
                    $current-direction = NORTH;
                    $current-row -= 1;
                } else {
                    $current-col -= 1;
                }
            }
            when NORTH {
                # No need to check for special case here, because we always start in the top left
                if @matrix[$current-row-1][$current-col]{'visited'} {
                    $current-direction = EAST;
                    $current-col += 1;
                } else {
                    $current-row -= 1;
                }
            }
        }
    }
    say @output;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 1 2 3 4 5 6 7 8 9
[1 2 3 6 9 8 7 4 5]

$ raku ch-2.raku 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
[1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I &lt;em&gt;tried&lt;/em&gt; to do this one functionally, but I just couldn’t find a way to do it.&lt;/p&gt;

&lt;p&gt;The basics of the above program are as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We take some input and make sure it is square
    &lt;ul&gt;
      &lt;li&gt;Couldn’t find a better way to do this, but I am all ears if anyone knows. Scala has an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isWhole&lt;/code&gt; function on its number classes, so I basically did that check myself:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; my $side-length = @input.elems.sqrt;
 $side-length.Int == $side-length or die &quot;Must be a square matrix&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Convert that into an actual matrix that looks like this (using example 1):&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [
     [{value: 1, visited: False}, {value: 2, visited: False}, {value: 3, visited: False}],
     [{value: 4, visited: False}, {value: 5, visited: False}, {value: 6, visited: False}],
     [{value: 7, visited: False}, {value: 8, visited: False}, {value: 9, visited: False}],
 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Starting in the top left corner, walk to the right (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EAST&lt;/code&gt;) with the following logic: if we hit the edge or a visited cell, turn right, else keep going.
    &lt;ul&gt;
      &lt;li&gt;We always “visit” the current cell by marking it visited and adding it to the output&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;That’s it!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;What I like about this solution is that it is pretty simple. In fact, steps one and two could be drastically simplified if this program trusted that it would always get a square matrix rather than a 1D matrix from the command line. Additionally, as a fan of pattern matching, I am glad I got to use a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given/when&lt;/code&gt; clause here.&lt;/p&gt;

&lt;p&gt;What I dislike about this solution is the mutability (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output.push()&lt;/code&gt;) and the fragility of it. For example, if the problem were tweaked to walk counter clockwise, I would basically have to re-write the actual “business logic” of this solution.&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;This was a fun dive back into the world of Perl, and I am looking forward to more of these challenges and blogs going forward.&lt;/p&gt;

&lt;p&gt;I am hoping someone can prove me wrong and solve the second problem functionally. Looking forward to seeing everyone’s solutions and interacting more with the community!&lt;/p&gt;

&lt;h4 id=&quot;ps&quot;&gt;PS&lt;/h4&gt;

&lt;p&gt;It seems the theme I am using for my blog does not support &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;raku&lt;/code&gt; code highlighting yet. I am using Jekyll; any plugin I can use to circumvent this?&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">I have always been a fan of Perl (and its younger brother Raku), but, since leaving the Bioinformatics world, have not found any real-world scenarios to flex those muscles.</summary></entry></feed>