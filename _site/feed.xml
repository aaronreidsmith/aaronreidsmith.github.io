<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-02-06T15:20:38-06:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Aaron Smith</title><subtitle>Personal website and blog of Aaron Smith</subtitle><author><name>Aaron Smith</name></author><entry><title type="html">Perl Weekly Challenge 98</title><link href="http://localhost:4000/blog/perl-weekly-challenge-098/" rel="alternate" type="text/html" title="Perl Weekly Challenge 98" /><published>2021-02-06T00:00:00-06:00</published><updated>2021-02-06T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-098</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-098/">&lt;p&gt;This week’s solutions explore some more obscure parts of the Raku ecosystem, namely &lt;a href=&quot;https://docs.raku.org/syntax/state&quot;&gt;state variables&lt;/a&gt; and &lt;a href=&quot;https://docs.raku.org/language/glossary#index-entry-Adverb&quot;&gt;adverbs&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;task-1-read-n-characters&quot;&gt;Task 1: Read N-characters&lt;/h2&gt;

&lt;p&gt;You are given file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$FILE&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Create subroutine &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readN($FILE, $number)&lt;/code&gt; that returns the first n-characters and moves the pointer to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(n+1)th&lt;/code&gt; character.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: Suppose the file (input.txt) contains &quot;1234567890&quot;
Output:
    print readN(&quot;input.txt&quot;, 4); # returns &quot;1234&quot;
    print readN(&quot;input.txt&quot;, 4); # returns &quot;5678&quot;
    print readN(&quot;input.txt&quot;, 4); # returns &quot;90&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-098/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub readN(Str $file-name, Int $chars-to-read where $chars-to-read &amp;gt; 0) returns Str {
    state %file-map;                                          # [1]

    if %file-map{$file-name}:!exists {                        # [2]
        %file-map{$file-name} = IO::CatHandle.new($file-name) # [3]
    }

    %file-map{$file-name}.readchars($chars-to-read);          # [4]
}

sub MAIN(Str $FILE, Int $N) {
    say readN($FILE, $N);
    say readN($FILE, $N);
    say readN($FILE, $N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Assuming input.txt contains '1234567890'
$ raku ch-1.raku input.txt 4
1234
5678
90
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;All of this relies on two very cool aspects of Raku: &lt;a href=&quot;https://docs.raku.org/syntax/state&quot;&gt;state variables&lt;/a&gt; and &lt;a href=&quot;https://docs.raku.org/type/IO::CatHandle&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CatHandles&lt;/code&gt;&lt;/a&gt;, which I will detail below. Basically, we just create a new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CatHandle&lt;/code&gt; and pass all the heavy lifting to it via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readchars&lt;/code&gt;; it keeps track of where it is in the file and will not attempt to read past the end of the file.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;A state variable in Raku is similar to a static variable in other languages, with the additional caveat that it can be instantiated in subroutines in addition to classes. This variable will be instantiated once and shared across all invocations of the subroutine. So, if we wanted to, we could do the following:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# input1.txt
# maryalamb

# input2.txt
# hadlittle

sub MAIN {
  my $input1 = 'input1.txt';
  my $input2 = 'input2.txt';
  
  say readN($input1, 4);
  say readN($input2, 3);
  say readN($input1, 1);
  say readN($input2, 6);
  say readN($input1, 4);
}

# Output:
# mary
# had
# a
# little
# lamb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;This is a special case of the &lt;a href=&quot;https://docs.raku.org/type/Hash#:exists&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exists&lt;/code&gt;&lt;/a&gt; adverb. Adverbs are just named arguments. In this case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:exists&lt;/code&gt; is essentially the pair &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exists =&amp;gt; True&lt;/code&gt;, so to negate it we use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!:exists&lt;/code&gt;. I found this pretty interesting, because I thought it would have been &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!%file-map{$file-name}:exists&lt;/code&gt;, but Raku complains about that.&lt;/li&gt;
  &lt;li&gt;A &lt;a href=&quot;https://docs.raku.org/type/IO::CatHandle&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CatHandle&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;normally&lt;/em&gt; used to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat&lt;/code&gt; together several file handles and read them all at once. In this case, we are using it to take advantage of its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readchars&lt;/code&gt; function discussed below.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/type/IO::CatHandle#method_readchars&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readchars&lt;/code&gt;&lt;/a&gt; essentially just tracks our offset in the given handle and always outputs the next &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; characters that we request, and just returns an empty string if we are at the end of the file. Super convenient for this challenge!&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-search-insert-position&quot;&gt;Task 2: Search Insert Position&lt;/h2&gt;

&lt;p&gt;You are given a sorted array of distinct integers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt; and a target &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to return the index of the given target if found otherwise place the target in the sorted array and return the index.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @N = (1, 2, 3, 4) and $N = 3
Output: 2 since the target 3 is in the array at the index 2.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @N = (1, 3, 5, 7) and $N = 6
Output: 3 since the target 6 is missing and should be placed at the index 3.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-3&quot;&gt;Example 3&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @N = (12, 14, 16, 18) and $N = 10
Output: 0 since the target 10 is missing and should be placed at the index 0.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-4&quot;&gt;Example 4&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @N = (11, 13, 15, 17) and $N = 19
Output: 4 since the target 19 is missing and should be placed at the index 4.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-098/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@N is copy, Int $N) returns Int { # [1]
    my @new = $N ∉ @N ?? (|@N, $N).sort !! @N;  # [2]
    @new.first($N, :k);                         # [3]
}

sub MAIN(Int $N, *@N where all(@N) ~~ Int) {
    say challenge(@N, $N)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# $N followed by @N
$ raku ch-2.raku 3 1 2 3 4 
2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This is pretty straight forward; we check if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; is in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt; (if not, we add it and re-sort), then return the index of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;. That’s it!&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;In Raku, the sigil (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%&lt;/code&gt;, etc.) is &lt;em&gt;part of&lt;/em&gt; the variable declaration. Because of that, for better or for worse, it is not a problem (as far as the compiler is concerned) that we have to variables named &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Rather than mark &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt; as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is copy&lt;/code&gt; so we could use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N.push($N).sort&lt;/code&gt;, since we assign it to a new variable anyway (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@new&lt;/code&gt;), we can use a &lt;a href=&quot;https://docs.raku.org/type/Slip&quot;&gt;slip&lt;/a&gt; to append &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first&lt;/code&gt; returns the first instance of the argument in the list (in this case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;). We supply the &lt;a href=&quot;https://docs.raku.org/routine/first#class_List&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:k&lt;/code&gt; adverb&lt;/a&gt; to have it return the &lt;em&gt;index&lt;/em&gt; of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; rather than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; itself.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Raku has a lot of cool stuff built in to it. I find the hardest part of navigating this language is the documentation. Things are &lt;em&gt;mostly&lt;/em&gt; well documented, but things like Stack Overflow posts and how-tos can be few and far between. Hopefully this blog is helpful for anyone trying to learn the language!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">This week’s solutions explore some more obscure parts of the Raku ecosystem, namely state variables and adverbs.</summary></entry><entry><title type="html">Perl Weekly Challenge 97</title><link href="http://localhost:4000/blog/perl-weekly-challenge-097/" rel="alternate" type="text/html" title="Perl Weekly Challenge 97" /><published>2021-01-30T00:00:00-06:00</published><updated>2021-01-30T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-097</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-097/">&lt;p&gt;My solution to challenge two builds on last week’s challenge two, so I encourage you to go read &lt;a href=&quot;https://aaronreidsmith.github.io/blog/perl-weekly-challenge-096/&quot;&gt;last week’s post&lt;/a&gt; if you haven’t already!&lt;/p&gt;

&lt;h2 id=&quot;task-1-caesar-cipher&quot;&gt;Task 1: Caesar Cipher&lt;/h2&gt;

&lt;p&gt;You are given string &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; containing alphabets &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A..Z&lt;/code&gt; only and a number &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to encrypt the given string &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Caesar_cipher&quot;&gt;Caesar Cipher&lt;/a&gt; with left shift of size &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S = &quot;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&quot;, $N = 3
Output: &quot;QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD&quot;

Plain:  ABCDEFGHIJKLMNOPQRSTUVWXYZ
Cipher: XYZABCDEFGHIJKLMNOPQRSTUVW

Plaintext:  THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG
Ciphertext: QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-097/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;constant @alphabet = ('A'..'Z').List; # [1]

sub challenge(
    Str $S where $S ~~ /^[&amp;lt;alpha&amp;gt;|&amp;lt;space&amp;gt;]+$/, # [2]
    Int $N where $N &amp;gt;= 0
) {
    $S.uc.trans(@alphabet =&amp;gt; @alphabet.rotate(-$N)); # [3][4]
}

sub MAIN(Str $S, Int $N) {
    say challenge($S, $N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;We use some cool built-in functionality to make this so simple. Here is the logic:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Make sure the string is uppercase (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.uc&lt;/code&gt;). They say we will always get uppercase, but might as well validate.&lt;/li&gt;
  &lt;li&gt;For each letter in the string, translate it to a different version of the alphabet that is rotated by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; spaces.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s it!&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Since the alphabet is always going to be constant we can instantiate it at the top level as a &lt;a href=&quot;https://docs.raku.org/language/terms#Constants&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;constant&lt;/code&gt;&lt;/a&gt;. Constants are evaluated at compile time, so this speeds up the program (even if just marginally).&lt;/li&gt;
  &lt;li&gt;You have likely seen me use this syntax before; these are called anonymous type constraints, and allow us to be a little more specific than just &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Str&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;. In this case, we want a string that only contains letters and spaces, and an int that is greater than or equal to zero.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/trans&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trans&lt;/code&gt;&lt;/a&gt; is a cool subroutine; it takes two lists (or strings) defining replacements to be made in the supplied string. Given the example above, it is the equivalent of something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S.subst('a', 'x').subst('b', 'y')...&lt;/code&gt;. The left argument, in our case, will always be the alphabet, and the right argument is the alphabet rotated by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; spaces.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/rotate&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rotate&lt;/code&gt;&lt;/a&gt; takes a list and rotates it to the left. Since we need our letters shifted to the right, we use a negative number (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-$N&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-binary-substrings&quot;&gt;Task 2: Binary Substrings&lt;/h2&gt;

&lt;p&gt;You are given a binary string &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$B&lt;/code&gt; and an integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to split the binary string &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$B&lt;/code&gt; of size &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; and then find the minimum number of flips required to make it all the same.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $B = “101100101”, $S = 3
Output: 1

Binary Substrings:
  &quot;101&quot;: 0 flip
  &quot;100&quot;: 1 flip to make it &quot;101&quot;
  &quot;101&quot;: 0 flip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input $B = “10110111”, $S = 4
Output: 2

Binary Substrings:
  &quot;1011&quot;: 0 flip
  &quot;0111&quot;: 2 flips to make it &quot;1011&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-097/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use Text::Levenshtein; # imports `distance`

sub challenge(
    Str $B where $B ~~ /^[0|1]+$/,
    Int $S where $S &amp;gt; 0
) {
    my @segments = $B.comb.rotor($S, :partial).map(-&amp;gt; @chars { # [1]
        my $segment = @chars.join;
        $segment ~ '0' x ($S - $segment.chars) # [2][3]
    });
    distance(|@segments).sum; # [4]
}

multi sub MAIN(Str $B, Int $S) {
    say challenge($B, $S);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 101100101 3
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The number of flips seems oddly similar to the edit distance from last week, no? I was able to reuse &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text::Levenshtein.distance&lt;/code&gt; from last week to find the “edit distance” between binary strings! We do a little work to split the string into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; pieces (padding with zeros, if necessary), then leave all the heaving lifting to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distance&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/rotor&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rotor&lt;/code&gt;&lt;/a&gt; splits a list into pieces based on the argument (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; in this case). We pass it the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:partial&lt;/code&gt; flag so that it keeps any pieces that are less than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; in size (rather than throwing them away).&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/~&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~&lt;/code&gt;&lt;/a&gt; is Raku’s string concatenation subroutine.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/x&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;&lt;/a&gt; is Raku’s string repetition operator. I couldn’t an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rpad&lt;/code&gt; method in Raku, so this is my workaround.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distance&lt;/code&gt; does not take a single list of arguments, it takes a variable amount of top-level arguments. To achieve that behavior, we use a &lt;a href=&quot;https://docs.raku.org/routine/%7C&quot;&gt;slip (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt;)&lt;/a&gt; to unpack the list we built.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;As I was writing this blog I realized it may have been better for me to left pad the binary strings in challenge two; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1001 != 100100&lt;/code&gt; but &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1001 == 001001&lt;/code&gt;. Oh well, the question doesn’t talk about the “partial” case anyway!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">My solution to challenge two builds on last week’s challenge two, so I encourage you to go read last week’s post if you haven’t already!</summary></entry><entry><title type="html">Perl Weekly Challenge 96</title><link href="http://localhost:4000/blog/perl-weekly-challenge-096/" rel="alternate" type="text/html" title="Perl Weekly Challenge 96" /><published>2021-01-22T00:00:00-06:00</published><updated>2021-01-22T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-096</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-096/">&lt;p&gt;I admittedly took a shortcut for part two this week, but it allowed me to introduce modules here (I don’t &lt;em&gt;believe&lt;/em&gt; I have used them before in a blog), so I think it makes up for it. 🙂&lt;/p&gt;

&lt;h2 id=&quot;task-1-reverse-words&quot;&gt;Task 1: Reverse Words&lt;/h2&gt;

&lt;p&gt;You are given a string &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to reverse the order of words in the given string. The string may contain leading/trailing spaces. The string may have more than one space between words in the string. Print the result without leading/trailing spaces and there should be only one space between words.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S = &quot;The Weekly Challenge&quot;
Output: &quot;Challenge Weekly The&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S = &quot;    Perl and   Raku are  part of the same family  &quot;
Output: &quot;family same the of part are Raku and Perl&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-096/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Str $S) returns Str {
    $S.trim.words.reverse.join(' ');
}

sub MAIN(Str $S) {
    say challenge($S);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 'The Weekly Challenge'
Challenge Weekly The
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Pretty easy one-liner here. Here is the logic:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Take the string and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trim&lt;/code&gt; whitespace off of the beginning and the end.&lt;/li&gt;
  &lt;li&gt;Split it into individual words using the handy &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;words&lt;/code&gt; method (the equivalent of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;split(/&amp;lt;space&amp;gt;+/)&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Reverse the list generated from Step 2&lt;/li&gt;
  &lt;li&gt;Re-join the list into a space-separated string using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.join(' ')&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-edit-distance&quot;&gt;Task 2: Edit Distance&lt;/h2&gt;

&lt;p&gt;You are given two strings &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to find out the minimum operations required to convert &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S1&lt;/code&gt; into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S2&lt;/code&gt;. The operations can be “insert,” “remove,” or “replace” a character. Check out &lt;a href=&quot;https://en.wikipedia.org/wiki/Edit_distance&quot;&gt;Wikipedia page&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h3 id=&quot;example-1-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S1 = &quot;kitten&quot;; $S2 = &quot;sitting&quot;
Output: 3

Explanation:
Operation 1: replace 'k' with 's'
Operation 2: replace 'e' with 'i'
Operation 3: insert 'g' at the end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2-1&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S1 = &quot;sunday&quot;; $S2 = &quot;monday&quot;
Output: 2

Explanation:
Operation 1: replace 's' with 'm'
Operation 2: replace 'u' with 'o'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-096/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use Text::Levenshtein; # imports `distance` # [1]

sub challenge(Str $S1, Str $S2) returns Int {
    distance($S1.lc, $S2.lc).head; # [2][3]
}

sub MAIN(Str $S1, Str $S2) {
    say challenge($S1, $S2);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku kitten sitting
3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This was definitely a cop-out. Edit distance is also known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt;&lt;em&gt;Levenshtein Distance&lt;/em&gt;&lt;/a&gt;; when an algorithm has someone’s name attached to it, it is usually better to find an existing implementation. 😅 With that being said, if anyone &lt;em&gt;is&lt;/em&gt; interested in the Raku implementation of the algorithm, &lt;a href=&quot;https://github.com/thundergnat/Text-Levenshtein/blob/master/lib/Text/Levenshtein.pm6#L3-L28&quot;&gt;here is the source code for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text::Levenshtein&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In case it is not obvious, we simply pass the input strings to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distance&lt;/code&gt; and let it do the work.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;I encourage anyone reading this to read the &lt;a href=&quot;https://docs.raku.org/language/modules&quot;&gt;Raku documentation on modules&lt;/a&gt;. Basically, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;use&lt;/code&gt; is one of several keywords to import modules, and is probably the most common you will see in the wild. You can import specific elements, if the author allows it, or you can write it as we did here and get the default imports.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distance&lt;/code&gt; will treat uppercase and lowercase letters differently, which I did not want, so we explicitly cast everything to lowercase (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.lc&lt;/code&gt;) before passing them to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distance&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distance&lt;/code&gt; will accept a variable number of arguments and compare the 2nd to Nth arguments to the first one, returning an array of Levenshtein distances. Since we only have two arguments, we need to extract the first (and only) distance in the array using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;In my day-to-day I always encourage folks to use modules where possible. In puzzles like these, I usually prefer to write my own implementation, even if it is less efficient. But it was a long week, so I took the lazy way out. 😉 See y’all next week!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">I admittedly took a shortcut for part two this week, but it allowed me to introduce modules here (I don’t believe I have used them before in a blog), so I think it makes up for it. 🙂</summary></entry><entry><title type="html">Perl Weekly Challenge 95</title><link href="http://localhost:4000/blog/perl-weekly-chellanege-095/" rel="alternate" type="text/html" title="Perl Weekly Challenge 95" /><published>2021-01-16T00:00:00-06:00</published><updated>2021-01-16T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-chellanege-095</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-chellanege-095/">&lt;p&gt;Two pretty simple challenges this week! I tried ot focus on strongly typed subroutines and methods to shake things up.&lt;/p&gt;

&lt;h2 id=&quot;task-1-palindrome-number&quot;&gt;Task 1: Palindrome Number&lt;/h2&gt;

&lt;p&gt;You are given a number &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to figure out if the given number is a palindrome. Print &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; if true otherwise &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 1221
Output: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: -101
Output: 0 (since -101 and 101- are not the same)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-3&quot;&gt;Example 3&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 90
Output: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-095/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Int $N) {
    ($N.Str.flip eq $N.Str).Int; # [1]
}

sub MAIN(Int $N) {
    say challenge($N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 1221
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Pretty simple solution here. THe &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; subroutine takes the input, casts it to a string, reverses it and compares it to the input argument (returning a boolean). Finally, it casts that boolean to a number to match the challenges output.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Casting to a string allows us to account for any negative sign easily.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-demo-stack&quot;&gt;Task 2: Demo Stack&lt;/h2&gt;

&lt;p&gt;Write a script to demonstrate stack operations like below:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push($n)&lt;/code&gt; - add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; to the stack&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop()&lt;/code&gt; - remove the top element&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;top()&lt;/code&gt; - get the top element&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;min()&lt;/code&gt; - return the minimum element&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;p&gt;Note: This is shown with Perl 5 syntax.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my $stack = Stack-&amp;gt;new;
$stack-&amp;gt;push(2);
$stack-&amp;gt;push(-1);
$stack-&amp;gt;push(0);
$stack-&amp;gt;pop;       # removes 0
print $stack-&amp;gt;top; # prints -1
$stack-&amp;gt;push(0);
print $stack-&amp;gt;min; # prints -1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-095/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Stack {
    has @!internal-state of Int;

    method push(Int $elem --&amp;gt; True) {
        @!internal-state.push($elem);
    }

    method pop() returns Int {
        if @!internal-state.elems == 0 {
            warn &quot;Cannot pop an empty stack!&quot;;
        } else {
            @!internal-state.pop;
        }
    }

    method top returns Int {
        if @!internal-state.elems == 0 {
            warn &quot;Cannot find top of empty stack!&quot;;
        } else {
            @!internal-state.tail;
        }
    }

    method min returns Int {
        if @!internal-state.elems == 0 {
            warn &quot;Cannot find minimum of empty stack!&quot;;
        } else {
            @!internal-state.min;
        }
    }

    method Str returns Str {
        &quot;({@!internal-state.join(', ')}) &amp;lt;-- Top&quot;;
    }
}

sub MAIN(*@push where all(@push) ~~ Int, Int :$pop = 2) {
     # Can't put a default on &quot;slurpy&quot; args, so this is our work around
    @push = @push.elems &amp;gt; 0 ?? @push !! (1, 2, 3, 4);

    my $stack = Stack.new;
    for @push -&amp;gt; $elem {
        $stack.push($elem);
    }
    say &quot;     Stack after pushing: $stack&quot;;
    for ^$pop {
        $stack.pop();
    }
    say &quot;     Stack after popping: $stack&quot;;
    say &quot;    Top element of stack: {$stack.top}&quot;;
    say &quot;Minimum element of stack: {$stack.min}&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# All default
$ raku ch-2.raku 
     Stack after pushing: (1, 2, 3, 4) &amp;lt;-- Top
     Stack after popping: (1, 2) &amp;lt;-- Top
    Top element of stack: 2
Minimum element of stack: 1

# Override pop default
$ raku ch-2.raku --pop=1
     Stack after pushing: (1, 2, 3, 4) &amp;lt;-- Top
     Stack after popping: (1, 2, 3) &amp;lt;-- Top
    Top element of stack: 3
Minimum element of stack: 1

# Override pop and push defaults
$ raku ch-2.raku --pop=1 1 2 3
     Stack after pushing: (1, 2, 3) &amp;lt;-- Top
     Stack after popping: (1, 2) &amp;lt;-- Top
    Top element of stack: 2
Minimum element of stack: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;A stack is a last in, first out (LIFO) structure, where we can only interact with the top. You can think of it like a stack of plates; it’s not easy to grab the middle plate from the stack!&lt;/p&gt;

&lt;p&gt;In this case, we decided to make the stack homogenous (i.e., it can only hold integers). A Raku &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; already has a stack-like interface, so we basically just wrap that and add some warnings.&lt;/p&gt;

&lt;p&gt;We simply define a class with a private &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array&lt;/code&gt; of integers such that the user can only interact with it via the methods described in the challenge. Then, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; subroutine simply demos those methods.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Raku classes have something called &lt;a href=&quot;https://docs.raku.org/language/variables#Twigils&quot;&gt;twigils&lt;/a&gt;. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!&lt;/code&gt; twigil here indicates that this variable is private to the class, and cannot be seen by any outside callers.&lt;/li&gt;
  &lt;li&gt;This could also be written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;has Int @!internal-state&lt;/code&gt;, but I feel that doesn’t read as well. It can be written like this since the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@&lt;/code&gt; sigil already denotes it is a positional variable, so you only need to constrain the members.&lt;/li&gt;
  &lt;li&gt;This is a &lt;a href=&quot;https://docs.raku.org/routine/say#(Independent_routines)_sub_say&quot;&gt;common pattern&lt;/a&gt; for methods and subroutines that don’t actually return anything. Similar to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unit&lt;/code&gt; in Scala, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;void&lt;/code&gt; in Java, or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt; in Python. And of course &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&amp;gt;&lt;/code&gt; is the way we define the return type.&lt;/li&gt;
  &lt;li&gt;The returns type can &lt;em&gt;also&lt;/em&gt; be defined using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;returns &amp;lt;type&amp;gt;&lt;/code&gt; as shown here. The difference between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&amp;gt;&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;returns&lt;/code&gt; is that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;returns&lt;/code&gt; can only specify abstract types, whereas &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&amp;gt;&lt;/code&gt; can specify both abstract type or specific values, which is why we needed to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&amp;gt;&lt;/code&gt; to return the &lt;em&gt;specific value&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;You’ll notice we don’t add the empty parentheses here. They are optional if there are no arguments to the method. In this case, I am using the Scala convention of having parentheses if the method has &lt;a href=&quot;https://en.wikipedia.org/wiki/Side_effect_(computer_science)&quot;&gt;side effects&lt;/a&gt;, and leaving them off otherwise.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Str&lt;/code&gt; is a magic method, similar to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__str__&lt;/code&gt; in Python or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;toString&lt;/code&gt; in Java and Scala. It is called whenever this variable is coerced to a string. So we don’t have to say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;Stack: {$stack.Str}&quot;&lt;/code&gt;, we can just say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;Stack: $stack&quot;&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Strongly typed Raku is much faster than gradually typed Raku, but I find it to be more cumbersome. Scalars are fairly easy (which is the majority of what we dealt with here), but I find positional (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lists&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Arrays&lt;/code&gt;, etc.) and associatives (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hashes&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Maps&lt;/code&gt;, etc.) to be more challenging. For example, the way you constrain a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; and an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array&lt;/code&gt; is &lt;em&gt;slightly&lt;/em&gt; different. And &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Maps&lt;/code&gt; &lt;em&gt;always&lt;/em&gt; have to have string keys, which makes things both cumbersome and slow. In fact, there was some interesting discussion around Raku’s speed (or lack thereof) on the &lt;a href=&quot;https://www.reddit.com/r/rakulang/comments/kxjsca/raku_is_friggin_slow/&quot;&gt;Raku subreddit&lt;/a&gt;, and I encourage anyone reading this to spend a little time over there. Anyway, that’s enough rambling from me. Until next time!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Two pretty simple challenges this week! I tried ot focus on strongly typed subroutines and methods to shake things up.</summary></entry><entry><title type="html">Perl Weekly Challenge 94</title><link href="http://localhost:4000/blog/perl-weekly-challenge-094/" rel="alternate" type="text/html" title="Perl Weekly Challenge 94" /><published>2021-01-10T00:00:00-06:00</published><updated>2021-01-10T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-094</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-094/">&lt;p&gt;The second challenge was a lot like last weeks second challenge, so I went a step further and implemented multiple tree traversals. I won’t include the tests this week, but feel free to click the GitHub links to see the test cases.&lt;/p&gt;

&lt;h2 id=&quot;task-1-group-anagrams&quot;&gt;Task 1: Group Anagrams&lt;/h2&gt;

&lt;p&gt;You are given an array of strings &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@S&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to group &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Anagrams&lt;/code&gt; together in any random order.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Input: (&quot;opt&quot;, &quot;bat&quot;, &quot;saw&quot;, &quot;tab&quot;, &quot;pot&quot;, &quot;top&quot;, &quot;was&quot;)
Output: [ (&quot;bat&quot;, &quot;tab&quot;),
          (&quot;saw&quot;, &quot;was&quot;),
          (&quot;top&quot;, &quot;pot&quot;, &quot;opt&quot;) ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Input: (&quot;x&quot;)
Output: [ (&quot;x&quot;) ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-094/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@S) {
    my $output = Set.new;
    for @S -&amp;gt; $word {
        my @permutations = $word.comb.permutations.map(*.join); # [1]
        $output ∪= (@S ∩ @permutations).keys.sort.join(',');    # [2]
    }
    $output.keys.map(*.split(',')).sort
}
sub MAIN(*@S where all(@S) ~~ /^&amp;lt;alpha&amp;gt;+$/) { # [3]
    say challenge(@S);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku opt bat saw tab pot top was
((bat tab) (opt pot top) (saw was))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This solution utilizes a cool Raku subroutine called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;permutations&lt;/code&gt;, which finds all the permutations of a given list. It only works for list smaller than 20 elements, so that is a caveat here. The logic is as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;For each inout word, find all the permutations.&lt;/li&gt;
  &lt;li&gt;Find the &lt;em&gt;union&lt;/em&gt; of the input words with the permutations of our current word to find permutations in the input list.&lt;/li&gt;
  &lt;li&gt;Add the above union to a set, so we don’t store duplicates.&lt;/li&gt;
  &lt;li&gt;Return the set as a list of lists in alphabetical order (the problem says random order, but I alphabetized for determinism in my tests).&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;permutations&lt;/code&gt; only works on a list, so we have to cast our word to a list via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comb&lt;/code&gt;, then back to a string via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;join&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Sets only work on scalars, so since we have a &lt;em&gt;list&lt;/em&gt; of words, we have to join it into a string separated by a comma.&lt;/li&gt;
  &lt;li&gt;The challenge doesn’t say to only accept letters, but I felt it was implied.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-binary-tree-to-linked-list&quot;&gt;Task 2: Binary Tree to Linked List&lt;/h2&gt;

&lt;p&gt;You are given a binary tree.&lt;/p&gt;

&lt;p&gt;Write a script to represent the given binary tree as an object and flatten it to a linked list object. Finally, print the linked list object.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:

    1
   / \
  2   3
 / \
4   5
   / \
  6   7

Output:

1 -&amp;gt; 2 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7 -&amp;gt; 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-094/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset NodeValue of Str where { $_ ~~ /^&amp;lt;digit&amp;gt;$/ || $_ eq 'Nil' }

class Node {
    has Node $.left  is rw = Nil;
    has Node $.right is rw = Nil;
    has Int $.value        = 0;
}

enum Traversal &amp;lt;Preorder Inorder Postorder&amp;gt;;

sub build-tree(@array, $root is copy = Nil, Int $i = 0) {
    if $i &amp;lt; @array.elems &amp;amp;&amp;amp; @array[$i] ne 'Nil' {
        $root       = Node.new(value =&amp;gt; @array[$i].Int);
        $root.left  = build-tree(@array, $root.left, 2 * $i + 1);
        $root.right = build-tree(@array, $root.right, 2 * $i + 2);
    }
    $root;
}

sub challenge(Node $root, Traversal $traversal) {
    with $root {
        given $traversal {
            when Preorder  { ($root.value, |challenge($root.left, $traversal), |challenge($root.right, $traversal)) }
            when Inorder   { (|challenge($root.left, $traversal), $root.value, |challenge($root.right, $traversal)) }
            when Postorder { (|challenge($root.left, $traversal), |challenge($root.right, $traversal), $root.value) }
        }
    }
}

sub challenge-wrapper(Node $root, Traversal $traversal = Preorder) {
    challenge($root, $traversal).join(' -&amp;gt; ');
}

sub MAIN(Str :$traversal = 'preorder', *@N where all(@N) ~~ NodeValue) {
    my $root = build-tree(@N);
    given $traversal.lc {
        when 'preorder'  { say challenge-wrapper($root, Preorder) }
        when 'inorder'   { say challenge-wrapper($root, Inorder) }
        when 'postorder' { say challenge-wrapper($root, Postorder) }
        default          { die &quot;Traversal must be one of: (preorder, inorder, postorder), not $traversal&quot; }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 1 2 3 4 5 Nil Nil Nil Nil 6 7
1 -&amp;gt; 2 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7 -&amp;gt; 3

# Same as above with traversal explicitly stated
$ raku ch-2.raku --traversal=preorder 1 2 3 4 5 Nil Nil Nil Nil 6 7
1 -&amp;gt; 2 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7 -&amp;gt; 3

$ raku ch-2.raku --traversal=inorder 1 2 3 4 5 Nil Nil Nil Nil 6 7
4 -&amp;gt; 2 -&amp;gt; 6 -&amp;gt; 5 -&amp;gt; 7 -&amp;gt; 1 -&amp;gt; 3

$ raku ch-2.raku --traversal=postorder 1 2 3 4 5 Nil Nil Nil Nil 6 7
4 -&amp;gt; 6 -&amp;gt; 7 -&amp;gt; 5 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The bulk of this code is the same as &lt;a href=&quot;https://aaronreidsmith.github.io/blog/perl-weekly-challenge-093/#solution-1&quot;&gt;last week’s&lt;/a&gt;, with the overlapping code being used to build a tree from command line arguments. Since the challenge code itself is only a line or two, I added the ability to pick which type of &lt;a href=&quot;https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/&quot;&gt;tree traversal&lt;/a&gt; you want (with the default being &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;preorder&lt;/code&gt;, as shown in the example).&lt;/p&gt;

&lt;p&gt;Basically, we just have a subroutine that takes a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt;, and depending on what traversal type is chosen, will build up an array like one of the following (where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Left&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Right&lt;/code&gt; can themselves be a tree and will be expanded recursively):&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Preorder  -&amp;gt; (Root, Left, Right)
Inorder   -&amp;gt; (Left, Root, Right)
Postorder -&amp;gt; (Left, Right, Root)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We then have a simple wrapper to “stringify” the list with arrows between the elements.&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Hoping for something a little less copy/paste next week, but regardless, this was a fun start to the new year!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">The second challenge was a lot like last weeks second challenge, so I went a step further and implemented multiple tree traversals. I won’t include the tests this week, but feel free to click the GitHub links to see the test cases.</summary></entry><entry><title type="html">Perl Weekly Challenge 93</title><link href="http://localhost:4000/blog/perl-weekly-challenge-093/" rel="alternate" type="text/html" title="Perl Weekly Challenge 93" /><published>2020-12-30T00:00:00-06:00</published><updated>2020-12-30T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-093</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-093/">&lt;p&gt;I was &lt;em&gt;going&lt;/em&gt; to stop adding my test cases (to the blog, not the code) this week, but after writing a solution that passed the provided test cases for part one, I wrote a new test that it failed and had to rewrite the whole thing. Because of that, today’s solutions still have the tests included. Additionally, in part one, I will go through both the failing solution and the corrected one.&lt;/p&gt;

&lt;h2 id=&quot;task-1-max-points&quot;&gt;Task 1: Max Points&lt;/h2&gt;

&lt;p&gt;You are given set of co-ordinates &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to count maximum points on a straight line when given co-ordinates plotted on 2-d plane.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;|
|     x
|   x
| x
+ _ _ _ _

Input: (1,1), (2,2), (3,3)
Output: 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;|
|
| x       x
|   x
| x   x
+ _ _ _ _ _

Input: (1,1), (2,2), (3,1), (1,3), (5,3)
Output: 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-093/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;h4 id=&quot;first-attempt&quot;&gt;First Attempt&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@pairs) {
    my %lines;
    my $already-compared = Set.new;

    for @pairs -&amp;gt; @pair {
        my @pairs-to-compare = @pairs.grep(* ne @pair);

        for @pairs-to-compare -&amp;gt; @other-pair {
            my ($x1, $y1) = @pair;
            my ($x2, $y2) = @other-pair;

            next if &quot;$x1,$y1:$x2,$y2&quot; ∈ $already-compared || &quot;$x2,$y2:$x1,$y1&quot; ∈ $already-compared; # [1]

            my $numerator = $y2 - $y1;
            my $denominator = $x2 - $x1;

            # Find the slope
            my $m = $denominator == 0 ?? 'undefined' !! $numerator / $denominator;

            # If it is a vertical line, use the x-intercept for uniqueness
            my $b = $m eq 'undefined' ?? @pair[1] !! @pair[1] - ($m * @pair[0]);

            # Slope and y-intercept (or x-intercept) are unique, so this is all we need
            %lines{&quot;$m:$b&quot;}++;                                                           # [2]

            $already-compared ∪= &quot;$x1,$y1:$x2,$y2&quot;;
        }
    }
    %lines.max(-&amp;gt; $entry { $entry.value }).value;
}

multi sub MAIN(*@N where all(@N) ~~ Int &amp;amp;&amp;amp; @N.elems %% 2) { # [3]
    my @pairs = @N.map(-&amp;gt; $x, $y { ($x, $y) });
    say challenge(@pairs);
}

multi sub MAIN(Bool :$test) {
    use Test;

    my @tests = (
        (((1, 1), (2, 2), (3, 3)), 3),
        (((1, 1), (2, 2), (3, 1), (1, 3), (5, 3)), 3),
        (((1, 1), (2, 1), (3, 1), (4, 1)), 4)
    );

    for @tests -&amp;gt; (@pairs, $expected) {
        is(challenge(@pairs), $expected);
    }

    done-testing;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 1 1 2 2 3 3
3

$ raku ch-1.raku --test
ok 1 - 
ok 2 - 
not ok 3 - 
1..3
# Failed test at /home/asmith/perlweeklychallenge-club/challenge-093/aaronreidsmith/raku/ch-1.raku line 47
# expected: '4'
#      got: '6'
# You failed 1 test of 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;corrected-solution&quot;&gt;Corrected Solution&lt;/h4&gt;

&lt;p&gt;As you can see, the above solution fails for my added test case. We will explore this below, but here is the corrected version (with an additional test case):&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Point {
    has $.x;
    has $.y;

    multi method new($x, $y) { # [4]
        self.bless(:$x, :$y);
    }
}

class Line {
    has $.slope;
    has $.x-intercept;
    has $.y-intercept;
    has Set $.points is rw;
}

sub challenge(@points) {
    my %lines;
    for @points.kv -&amp;gt; $index, $point {
        for @points[$index+1..*] -&amp;gt; $other-point {
            my $numerator = $other-point.y - $point.y;
            my $denominator = $other-point.x - $point.x;

            my $slope = $denominator == 0 ?? 'undefined' !! $numerator / $denominator;

            my $y-intercept;
            if $slope eq 'undefined' {
                $y-intercept = $point.y == 0 ?? 0 !! 'undefined';
            } else {
                $y-intercept = $point.y - ($slope * $point.x);
            }

            my $x-intercept;
            if $slope eq 'undefined' {
                $x-intercept = $point.x;
            } elsif $slope == 0 {
                $x-intercept = 'undefined'
            } else {
                $x-intercept = -$y-intercept / $slope;
            }

            my $points = Set.new(&quot;{$point.x},{$point.y}&quot;, &quot;{$other-point.x},{$other-point.y}&quot;);

            my $key = &quot;$slope,$x-intercept,$y-intercept&quot;; # [5]
            
            if %lines{$key}:exists {
                %lines{$key}.points ∪= $points;
            } else {
                %lines{$key} = Line.new(:$slope, :$x-intercept, :$y-intercept, :$points);
            }
        }
    }
    %lines.max({ $_.value.points.elems }).value.points.elems;
}

multi sub MAIN(*@N where all(@N) ~~ Int &amp;amp;&amp;amp; @N.elems %% 2) {
    my @pairs = @N.map(-&amp;gt; $x, $y { Point.new($x, $y) });
    say challenge(@pairs);
}

multi sub MAIN(Bool :$test) {
    use Test;

    my @tests = (
        ((Point.new(1, 1), Point.new(2, 2), Point.new(3, 3)), 3),
        ((Point.new(1, 1), Point.new(2, 2), Point.new(3, 1), Point.new(1, 3), Point.new(5, 3)), 3),
        ((Point.new(1, 1), Point.new(2, 1), Point.new(3, 1), Point.new(4, 1)), 4),
        ((Point.new(1, 1), Point.new(1, 2), Point.new(2, 1), Point.new(3, 1), Point.new(4, 1)), 4)
    );

    for @tests -&amp;gt; (@points, $expected) {
        is(challenge(@points), $expected);
    }

    done-testing;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 1 1 2 2 3 3
3

$ raku ch-1.raku --test
ok 1 - 
ok 2 - 
ok 3 - 
ok 4 -
1..4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;For both of these there is some logic in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; that I will explain once. Basically, we expect the user to pass us one or more integers, and they have to pass us an &lt;em&gt;even&lt;/em&gt; number of integers so that we can split it into pairs. We then pass this to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; subroutine.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;First Attempt&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The logic here is as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;For each point, compare it to each other point.&lt;/li&gt;
  &lt;li&gt;During the comparison calculate both the slope and (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$m&lt;/code&gt;) and the y-intercept (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$b&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Store the slope/y-intercept combo in a Hash called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%lines&lt;/code&gt;.
    &lt;ul&gt;
      &lt;li&gt;Increment if it exists, otherwise, set to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Comparing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 1) &amp;lt;-&amp;gt; (2, 2)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(2, 2) &amp;lt;-&amp;gt; (1, 1)&lt;/code&gt; is the same thing, so we store that in a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt; to save ourselves a few cycles.&lt;/li&gt;
  &lt;li&gt;Finally, find the maximum entry by value and return it.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This logic breaks down in the case of a horizontal line (see test number 3). The reason it breaks down is because the pairs are evaluated like this:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 1)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(2, 1)&lt;/code&gt; – m = 0, b = 1. New line – set to 1&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 1)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(3, 1)&lt;/code&gt; – m = 0, b = 1. Existing line – increment to 2&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 1)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(4, 1)&lt;/code&gt; – m = 0, b = 1. Existing line – increment to 3&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(2, 1)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 1)&lt;/code&gt; – Same as number 1 – skip&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(2, 1)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(3, 1)&lt;/code&gt; – m = 0, b = 1. Existing line – increment to 4&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(2, 1)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(4, 1)&lt;/code&gt; – m = 0, b = 1. Existing line – increment to 5&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(3, 1)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 1)&lt;/code&gt; – Same as number 2 – skip&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(3, 1)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(2, 1)&lt;/code&gt; – Same as number 5 – skip&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(3, 1)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(4, 1)&lt;/code&gt; – m - 0, b = 1. Existing line – increment to 6&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;As you can see, even with four points, we generate an answer of six. My first though was to just take the minimum of the number of points and the longest run we found, which would yield four. However, if we had any points &lt;em&gt;not&lt;/em&gt; on the line (look at test 4 the corrected solution), then it would yield the wrong answer as well.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Corrected Solution&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The logic here is similar, but accounts for the above situation. First, you will notice I added a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Point&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Line&lt;/code&gt; class, to make things a little easier. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Line&lt;/code&gt; class also contains a set of points along that line that we can use to de-duplicate if necessary. Once those are defined, the logic is as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Compare each point to each &lt;em&gt;subsequent&lt;/em&gt; point.
    &lt;ul&gt;
      &lt;li&gt;There is no need to look at past points, as it results in the “skips” shown above&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;During each comparison we calculate the slope, x-intercept and y-intercept.
    &lt;ul&gt;
      &lt;li&gt;The reason for this is because if we have an undefined slope (vertical line), we need to know where along the x-axis it falls.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Once we have the above calculated, we create a joint key of all 3 to use in a Hash.&lt;/li&gt;
  &lt;li&gt;Using the above key, we look up our string in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%lines&lt;/code&gt; Hash. If it exists, we add the points used to find it to the points contained in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Line&lt;/code&gt; object (since it is a set, it will de-duplicate itself automatically). Otherwise, we create a new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Line&lt;/code&gt; object and store it with the key from #3.&lt;/li&gt;
  &lt;li&gt;Finally, we find the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Line&lt;/code&gt; with the most &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Point&lt;/code&gt;s and return the number of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Point&lt;/code&gt;s.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;We need to use a string here or else the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt; will erroneously combine some of our points. Sets flatten their arguments in Raku, which makes it tricky to store nested items. This has been my go-to solution.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt; objects behave kind of like default dicts in Python in that if you use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;++&lt;/code&gt; on a key that does not exist, it will create the key and increment it to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Raku has an operator specifically for “divisible by.” In other languages, you might see &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x % 2 == 0&lt;/code&gt; to check if something is divisible by 2, but in Raku you can say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$x %% 2&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Raku, like some other languages, allows us to define multiple constructors. The default one is created for us and takes named arguments. This one takes positional arguments and passes them to the default constructor via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self.bless&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Similar to #1, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt; objects always use string keys. So if we need some kind of compound key, we need to cast it to a string as seen here.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-sum-path&quot;&gt;Task 2: Sum Path&lt;/h2&gt;

&lt;p&gt;You are given binary tree containing numbers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0-9&lt;/code&gt; only.&lt;/p&gt;

&lt;p&gt;Write a script to sum all possible paths from root to leaf.&lt;/p&gt;

&lt;h3 id=&quot;example-1-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
     1
    /
   2
  / \
 3   4

Output: 13
as sum two paths (1-&amp;gt;2-&amp;gt;3) and (1-&amp;gt;2-&amp;gt;4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2-1&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
     1
    / \
   2   3
  /   / \
 4   5   6

Output: 26
as sum three paths (1-&amp;gt;2-&amp;gt;4), (1-&amp;gt;3-&amp;gt;5) and (1-&amp;gt;3-&amp;gt;6)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-093/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset NodeValue of Str where { $_ ~~ /^&amp;lt;digit&amp;gt;$/ || $_ eq 'Nil' } # [1]

class Node {
    has Node $.left  is rw = Nil; # [2]
    has Node $.right is rw = Nil;
    has Int $.value        = 0;
}

sub build-tree(@array, $root is copy = Nil, Int $i = 0) {
    if $i &amp;lt; @array.elems &amp;amp;&amp;amp; @array[$i] ne 'Nil' {
        $root       = Node.new(value =&amp;gt; @array[$i].Int);
        $root.left  = build-tree(@array, $root.left, 2 * $i + 1);
        $root.right = build-tree(@array, $root.right, 2 * $i + 2);
    }
    $root;
}

sub challenge(Node $root, @path is copy = ()) {
    my $path-sum = 0;
    with $root {
        @path.push($root.value);

        if !$root.left.defined &amp;amp;&amp;amp; !$root.right.defined {
            $path-sum = @path.sum;
        } else {
            $path-sum += challenge($root.left, @path);
            $path-sum += challenge($root.right, @path);
        }
    }
    $path-sum;
}

multi sub MAIN(*@N where all(@N) ~~ NodeValue) {
    my $root = build-tree(@N);
    say challenge($root);
}

multi sub MAIN(Bool :$test) {
    use Test;

    my @tests = (
        (build-tree(('1', '2', 'Nil', '3', '4')), 13),
        (build-tree(('1', '2', '3', '4', 'Nil', '5', '6')), 26),
        (build-tree(('2', '7', '5', '2', '6', 'Nil', '9', 'Nil', '5', '11', '4', 'Nil')), 77)
    );

    for @tests -&amp;gt; ($tree, $expected) {
        is(challenge($tree), $expected);
    }

    done-testing;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 1 2 Nil 3 4
13

$ raku ch-2.raku 1 2 3 4 Nil 5 6
26

$ raku ch-2.raku --test
ok 1 - 
ok 2 - 
ok 3 - 
1..3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The hardest part of this, for me, was giving the user some kind of command line interface to be able to define their own trees (something that wasn’t explicitly part of the problem). We basically just use the &lt;a href=&quot;https://www.geeksforgeeks.org/binary-tree-array-implementation/&quot;&gt;array implementation&lt;/a&gt; of a binary tree where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@array[0]&lt;/code&gt; is the root, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@array[1]&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@array[2]&lt;/code&gt; are the second row, etc. Anything that is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; is recognized as an empty node (i.e., an &lt;a href=&quot;http://www.opendatastructures.org/versions/edition-0.1d/ods-java/node37.html&quot;&gt;unbalanced tree&lt;/a&gt;). So, for example, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 2 Nil 3 4&lt;/code&gt; represents the first example shown above.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; does some validation to make sure everything is either a number or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; and then let’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build-tree&lt;/code&gt; convert the array into an actual tree (by creating &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt; objects). Once we have a tree, we give it to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; which implements the following logic:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If the node is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; return 0.
    &lt;ul&gt;
      &lt;li&gt;Technically unnecessary since we check if we are at a terminal node before recursing, but doesn’t hurt to have.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Push the current node’s value into our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@path&lt;/code&gt; list.&lt;/li&gt;
  &lt;li&gt;If we are at a leaf node (no &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;left&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;right&lt;/code&gt;), then calculate the sum of the path and return.&lt;/li&gt;
  &lt;li&gt;Otherwise, recurse both left and right ith the existing path and add it to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$path-sum&lt;/code&gt; variable.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;This line ensures that, even though we are expecting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Str&lt;/code&gt; types, that all of them are either digits or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'Nil'&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;By default, class attributes are read only, so by defining them as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is rw&lt;/code&gt; (read/write), we say that they are mutable. Additionally, we assign these attributes default values.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;This challenge is a good case study in test-driven development! Be sure to write edge-case tests to make sure everything is behaving as expected. In the case of part one, it was &lt;em&gt;not&lt;/em&gt; behaving as expected and required a re-write.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">I was going to stop adding my test cases (to the blog, not the code) this week, but after writing a solution that passed the provided test cases for part one, I wrote a new test that it failed and had to rewrite the whole thing. Because of that, today’s solutions still have the tests included. Additionally, in part one, I will go through both the failing solution and the corrected one.</summary></entry><entry><title type="html">Perl Weekly Challenge 92</title><link href="http://localhost:4000/blog/perl-weekly-challenge-092/" rel="alternate" type="text/html" title="Perl Weekly Challenge 92" /><published>2020-12-25T00:00:00-06:00</published><updated>2020-12-25T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-092</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-092/">&lt;p&gt;It was a slow Christmas day for me, for the most part, so I decided to knock this challenge out as well as &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-25/&quot;&gt;finishing up AoC&lt;/a&gt;!&lt;/p&gt;

&lt;h2 id=&quot;task-1-isomorphic-strings&quot;&gt;Task 1: Isomorphic Strings&lt;/h2&gt;

&lt;p&gt;You are given two strings &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$A&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to check if the given strings are &lt;a href=&quot;https://www.educative.io/edpresso/how-to-check-if-two-strings-are-isomorphic&quot;&gt;isomorphic&lt;/a&gt;. Print &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; if they are otherwise &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $A = &quot;abc&quot;; $B = &quot;xyz&quot;
Output: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $A = &quot;abb&quot;; $B = &quot;xyy&quot;
Output: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-3&quot;&gt;Example 3&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $A = &quot;sum&quot;; $B = &quot;add&quot;
Output: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-092/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use MONKEY-TYPING;  # [1]

augment class Seq {
    method OrderedSet {
        my @set;
        for self -&amp;gt; $item {
            next if $item ∈ @set;
            @set.push($item);
        }
        @set;
    }
}

sub challenge(Str $A, Str $B) returns Int {
    my $a-chars = $A.comb.OrderedSet.join;
    my $b-chars = $B.comb.OrderedSet.join;
    ($A.trans($a-chars =&amp;gt; $b-chars) eq $B).Int;
}

multi sub MAIN(Str $A, Str $B) {
    say challenge($A, $B);
}

multi sub MAIN(Bool :$test) {
    use Test;

    my @tests = (
        ('abc', 'xyz', 1),
        ('abb', 'xyy', 1),
        ('sum', 'add', 0)
    );

    for @tests -&amp;gt; @test {
        is(challenge(@test[0], @test[1]), @test[2]);
    }

    done-testing;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku abc xyz
1

$ raku ch-1.raku --test
ok 1 - 
ok 2 - 
ok 3 - 
1..3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Once again, most the logic lives in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt;. Basically, I wanted to take advantage of something we used &lt;a href=&quot;https://aaronreidsmith.github.io/blog/perl-weekly-challenge-090&quot;&gt;a couple weeks ago&lt;/a&gt;, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trans&lt;/code&gt; subroutine. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trans&lt;/code&gt; takes two strings and &lt;em&gt;translates&lt;/em&gt; the given input using the map. If I were to hardcode it for the example, this is basically what I am trying to check:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'abc'.trans('abc' =&amp;gt; 'xyz') eq 'xyz'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To do this we need to remove duplicates (so we need a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt;), but we also need to preserve order (so something like an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderedSet&lt;/code&gt;). Unfortunately, such a thing doesn’t exist in Raku… so we have to create it!&lt;/p&gt;

&lt;p&gt;I am doing something which is &lt;em&gt;technically&lt;/em&gt; &lt;a href=&quot;https://docs.raku.org/syntax/augment&quot;&gt;frowned upon&lt;/a&gt; by using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;augment&lt;/code&gt; keyword, but it is a fairly normal pattern in Scala, so I just went with it. Basically, we just &lt;a href=&quot;https://en.wikipedia.org/wiki/Monkey_patch&quot;&gt;monkey patch&lt;/a&gt; an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderedSet&lt;/code&gt; method onto the existing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Seq&lt;/code&gt; builtin. In Scala, we would do this via an implicit class; here is an example:&lt;/p&gt;

&lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;implicit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExtendedString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;excited&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;$str!!!&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;&quot;Hello world&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;py&quot;&gt;excited&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Hello world!!!&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I feel Raku makes this much clearer via the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;augment&lt;/code&gt; keyword. It says we are &lt;em&gt;augmenting&lt;/em&gt; the class &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Seq&lt;/code&gt; and then we define the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderedSet&lt;/code&gt; method. The method itself does not &lt;em&gt;technically&lt;/em&gt; return a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt;, but it returns a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; that maintains order and removes duplicates – all we need.&lt;/p&gt;

&lt;p&gt;Once we have both the left and right strings converted to ordered sets, we convert them &lt;em&gt;back&lt;/em&gt; into strings to use in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trans&lt;/code&gt; method as shown above&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;If we want to use the “frowned upon” pragma of monkey patching, we have to manually turn it on using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;use MONKEY-TYPING&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-insert-interval&quot;&gt;Task 2: Insert Interval&lt;/h2&gt;

&lt;p&gt;You are given a set of sorted non-overlapping intervals and a new interval.&lt;/p&gt;

&lt;p&gt;Write a script to merge the new interval to the given set of intervals.&lt;/p&gt;

&lt;h3 id=&quot;example-1-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input $S = (1,4), (8,10); $N = (2,6)
Output: (1,6), (8,10)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2-1&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input $S = (1,2), (3,7), (8,10); $N = (5,8)
Output: (1,2), (3,10)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-3-1&quot;&gt;Example 3&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input $S = (1,5), (7,9); $N = (10,11)
Output: (1,5), (7,9), (10,11)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-092/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset MultiRange of Str where { $_ ~~ /^[&amp;lt;digit&amp;gt;+'-'&amp;lt;digit&amp;gt;+',']+[&amp;lt;digit&amp;gt;+'-'&amp;lt;digit&amp;gt;+]$/ }
subset Range of Str where { $_ ~~ /^&amp;lt;digit&amp;gt;+'-'&amp;lt;digit&amp;gt;+$/ }

sub challenge(@S, $N) {
    my @combined = (|@S, $N).sort({ $^a.min cmp $^b.min });
    my @final = (@combined.head,);
    OUT: for @combined[1..*] -&amp;gt; $new-range {           # [1]
        my ($min, $max) = $new-range.minmax;
        IN: for @final.kv -&amp;gt; $index, $range {
            next IN if $min ∈ $range &amp;amp;&amp;amp; $max ∈ $range; # [2]
            if $min ∈ $range {
                @final[$index] = ($range.min..$max);
                next OUT;
            } elsif $max ∈ $range {
                @final[$index] = ($min..$range.max);
                next OUT;
            } elsif $index == @final.end {
                @final.push($new-range);
            }
        }
    }
    @final.map(-&amp;gt; $range { &quot;({$range.min},{$range.max})&quot; }).join(', ');
}

multi sub MAIN(MultiRange :$S, Range :$N) {
    my @s = $S.split(',').map(*.split('-').map(*.Int).minmax);
    my $n = $N.split('-').map(*.Int).minmax;
    say challenge(@s, $n);
}

multi sub MAIN(Bool :$test) {
    use Test;

    my @tests = (
        ((1..4), (8..10), (2..6), '(1,6), (8,10)'),
        ((1..2), (3..7), (8..10), (5..8), '(1,2), (3,10)'),
        ((1..5), (7..9), (10..11), '(1,5), (7,9), (10,11)')
    );

    for @tests -&amp;gt; @test {
        my @S = @test[0..^*-2];
        my $N = @test[*-2];
        my $answer = @test[*-1];
        is(challenge(@S, $N), $answer);
    }

    done-testing;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku -S=1-4,8-10 -N=2-6
(1,6), (8,10)

$ raku ch-2.raku --test
ok 1 - 
ok 2 - 
ok 3 - 
1..3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; has a little validation and parsing. It validates that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt; contains &lt;em&gt;at least&lt;/em&gt; two ranges (defined as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X-Y&lt;/code&gt;) via the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MultiRange&lt;/code&gt; subset, and that we get exactly one range in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; (via the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Range&lt;/code&gt; subset). It then parses those ranges into actual &lt;a href=&quot;https://docs.raku.org/type/Range&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Range&lt;/code&gt;&lt;/a&gt; objects to give to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; subroutine.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; first puts all the ranges in order &lt;em&gt;by their minimum element&lt;/em&gt; and creates an output list called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@final&lt;/code&gt; that contains the minimum range of the input ranges. We then iterate through the remaining ranges. For each one, we check the following conditions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If it is &lt;em&gt;wholly contained&lt;/em&gt; by an existing range, skip it.&lt;/li&gt;
  &lt;li&gt;If the &lt;em&gt;minimum&lt;/em&gt; item in our new range is contained in any existing range, extend the existing range up to the new maximum.&lt;/li&gt;
  &lt;li&gt;If the &lt;em&gt;maximum&lt;/em&gt; item in our new range is contained in any existing range, extend the existing range down to the new minimum.&lt;/li&gt;
  &lt;li&gt;If we have exhausted all the overlap checks, this must be a totally distinct range and just add it to the end.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Finally, once we have our ranges, we need to convert them to the output format defined, so we do that and return.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;This is a Raku feature called &lt;a href=&quot;https://docs.raku.org/type/Label&quot;&gt;Labels&lt;/a&gt;, where we can add a label to our &lt;a href=&quot;https://docs.raku.org/type/Supply&quot;&gt;Supply&lt;/a&gt; objects (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gather&lt;/code&gt;, etc). It allows us to name our loops and use the features outline in #2.&lt;/li&gt;
  &lt;li&gt;With labels in place, if we want to break both an inner and an outer loop, we can do that in one statement (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;last OUT&lt;/code&gt;), or if we want to go to the next outer loop without finishing our inner loop, we can do that as well (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next OUT&lt;/code&gt;). This makes the code faster and more readable, in my opinion.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Some fun little challenges that nicely complement Advent of Code. Now to start enjoying Christmas with my family! Merry Christmas everyone!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">It was a slow Christmas day for me, for the most part, so I decided to knock this challenge out as well as finishing up AoC!</summary></entry><entry><title type="html">Advent of Code: Day 25</title><link href="http://localhost:4000/blog/advent-of-code-day-25/" rel="alternate" type="text/html" title="Advent of Code: Day 25" /><published>2020-12-25T00:00:00-06:00</published><updated>2020-12-25T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-25</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-25/">&lt;p&gt;Merry Christmas! Part two was probably my favorite part of all of Advent of Code; check it out!&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;We finally get to the front desk of the resort, and they tell us that the system is down, and we will be unable to check in. Luckily, they created all the room keys this morning, so we &lt;em&gt;will&lt;/em&gt; be able to go to our room, and just formally check in later. We are on the 25th floor, and the elevator is broken. 🙃&lt;/p&gt;

&lt;p&gt;We make it to our room and scan the key and get the disheartening red light from the door. Luckily, there is a number to call IT on the card, and we give them a ring. They say we can either go down to the front desk to get it reset or reverse engineer the cryptographic handshake between the card and the door. Obviously we will take the latter choice.&lt;/p&gt;

&lt;p&gt;We’re able to obtain the &lt;em&gt;public keys&lt;/em&gt; of both the door and the card (our input). To find the cryptographic handshake we must take the subject number (a constant; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;7&lt;/code&gt;) and transform it according to the following rules:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Start with a value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Set the value equal to itself times the subject number (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;7&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Set the value equal to the remainder after dividing by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;20201227&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Continue until the value equals the device’s public key&lt;/li&gt;
  &lt;li&gt;For the above steps, count how many loops it took; this is the secret &lt;strong&gt;loop size&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Once we have found the secret loop size for one of the devices, we can take the loop size and apply the same transformation as above using the public key from &lt;em&gt;the other device&lt;/em&gt; as our subject number, which yields the handshake key. Let’s look at an example:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Card Public Key: 5764801
Door Public Key: 17807724

--- Finding the loop size for the card ---
# Loop 1
value = 1 * 7        = 7
value = 7 % 20201227 = 7

# Loop 2
value = 7 * 7         = 49
value = 49 % 20201227 = 49

# Loop 3
value = 49 * 7         = 343
value = 343 % 20201227 = 343

# Loop 4
value = 343 * 7         = 2401
value = 2401 % 20201227 = 2401

# Loop 5
value = 2401 * 7         = 16807
value = 16807 % 20201227 = 16807

# Loop 6
value = 16807 * 7         = 117649
value = 117649 % 20201227 = 117649

# Loop 7
value = 117649 * 7        = 823543
value = 823543 % 20201227 = 823543

# Loop 8
value = 823543 * 7         = 5764801
value = 5764801 % 20201227 = 5764801 &amp;lt;-- The card's public key

--- Applying the loop size to the door ---
# Loop 1
value = 1 * 17807724        = 17807724
value = 17807724 % 20201227 = 17807724

# Loop 2
value = 17807724 * 17807724        = 317115034060176
value = 317115034060176 % 20201227 = 10847306

# Loop 3
value = 10847306 * 17807724        = 193165831391544
value = 193165831391544 % 20201227 = 1914476

# Loop 4
value = 1914476 * 17807724        = 34092460212624
value = 34092460212624 % 20201227 = 874663

# Loop 5
value = 874663 * 17807724         = 15575757297012
value = 15575757297012 % 20201227 = 5243202

# Loop 6
value = 5243202 * 17807724        = 93369494092248
value = 93369494092248 % 20201227 = 8733831

# Loop 7
value = 8733831 * 17807724         = 155529651910644
value = 155529651910644 % 20201227 = 1213104

# Loop 8
value = 1213104 * 17807724        = 21602621215296
value = 21602621215296 % 20201227 = 14897079       &amp;lt;-- Cryptographic Handshake
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I will not display it, but if we had found the door’s loop size and then used the card’s public key as the subject number, we would have come to the same cryptographic handshake; this is how the door, and the card know they are a match.&lt;/p&gt;

&lt;p&gt;With our &lt;em&gt;real&lt;/em&gt; card and door public keys, what is the cryptographic handshake between them?&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/25/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($file) {
    my ($card-key, $door-key) = $file.IO.lines.map(*.Int);
    my $handshake = 1;
    my $target = 1;
    while $target != $door-key {
        $target = ($target * 7) % 20201227;
        $handshake = ($handshake * $card-key) % 20201227;
    }
    say $handshake;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
18293391
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;Rather than keep track of the loop size, we just do the above 2 loops in parallel until &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$target&lt;/code&gt; matches &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$door-key&lt;/code&gt;. Rather than do the two steps outline above, we are able to do the multiplication and remainder division (&lt;a href=&quot;https://en.wikipedia.org/wiki/Modulo_operation&quot;&gt;modulo&lt;/a&gt;) in one step. Finally, all we have to do is say the handshake!&lt;/p&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;2020 has been a tough year and everyone needs a break. Day 25 part 2 is a freebie. 🙂&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I had my ups and downs with this challenge. Obviously I did not fulfill my goal of solving everything in functional Raku; in fact, I wasn’t even able to solve everything in Raku. However, I learned a lot about the language, I learned a few new algorithms, and I had fun! This whole thing was a lot of fun, and I want to thank &lt;a href=&quot;https://github.com/topaz&quot;&gt;Eric&lt;/a&gt; for doing it for the past 6 years (even though this was my first time participating).&lt;/p&gt;

&lt;p&gt;Next year I will have a one-and-a-half-year-old, so no promises I will be able to blog every day (it was hard enough this year), but I will do my best to participate, and I may blog for problems I find particularly clever.&lt;/p&gt;

&lt;p&gt;With that, I would like to wish everyone a very merry Christmas and a happy New Year!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Merry Christmas! Part two was probably my favorite part of all of Advent of Code; check it out!</summary></entry><entry><title type="html">Advent of Code: Day 24</title><link href="http://localhost:4000/blog/advent-of-code-day-24/" rel="alternate" type="text/html" title="Advent of Code: Day 24" /><published>2020-12-24T00:00:00-06:00</published><updated>2020-12-24T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-24</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-24/">&lt;p&gt;Merry Christmas Eve! I had a lot more fun with today’s challenge than the past few days. It is reminiscent of days &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-11/&quot;&gt;11&lt;/a&gt; and &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-17/&quot;&gt;17&lt;/a&gt;, but with a fun twist. I also solved it using a different data structure due to that twist, so it felt fresh.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;We &lt;em&gt;finally&lt;/em&gt; made it to the resort, but there is a problem – they are renovating the lobby floor, and we can’t make it to the check-in desk until they are done. Since we are in a rush, we offer to help.&lt;/p&gt;

&lt;p&gt;The workers are trying to lay a pattern using hexagonal tiles. All the tiles are white on one side and black on the other; to start, the workers laid them all out in the “white” orientation. The foreman gives us a list that looks like the following:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sesenwnenenewseeswwswswwnenewsewsw
neeenesenwnwwswnenewnwwsewnenwseswesw
seswneswswsenwwnwse
nwnwneseeswswnenewneswwnewseswneseene
swweswneswnenwsewnwneneseenw
eesenwseswswnenwswnwnwsewwnwsene
sewnenenenesenwsewnenwwwse
wenwwweseeeweswwwnwwe
wsweesenenewnwwnwsenewsenwwsesesenwne
neeswseenwwswnwswswnw
nenwswwsewswnenenewsenwsenwnesesenew
enewnwewneswsewnwswenweswnenwsenwsw
sweneswneswneneenwnewenewwneswswnese
swwesenesewenwneswnwwneseswwne
enesenwswwswneneswsenwnewswseenwsese
wnwnesenesenenwwnenwsewesewsesesew
nenewswnwewswnenesenwnesewesw
eneswnwswnwsenenwnwnwwseeswneewsenese
neswnwewnwnwseenwseesewsenwsweewe
wseweeenwnesenwwwswnew
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;From an arbitrary starting tile, this defines directions to the tiles that need to be flipped; one set of directions per line. From each tile, there are six directions we can move in: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;e&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;se&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sw&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;w&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nw&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ne&lt;/code&gt;. So the first line above would split into these directions:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;se se nw ne ne ne w se e sw w sw sw w ne ne w se w sw
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once we follow the directions to the appropriate tile, we flip it. One note, some of these tiles may flip and then &lt;em&gt;flip back&lt;/em&gt;. After all the instructions have been processed, how many tiles are flipped with their black side up?&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/24/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($file) {
    my $regex = /^(e|se|sw|w|nw|ne)+$/;
    my @instructions =
        $file.IO
        .lines
        .map(-&amp;gt; $line {
            $line.match($regex).map(*.Str).split(' ')
        });
    my $flipped = Set.new;
    for @instructions -&amp;gt; @instruction-set {
        my ($q, $r) = (0, 0);
        for @instruction-set -&amp;gt; $direction {
            given $direction {
                when 'e'  { $q += 1          }
                when 'se' { $r += 1          }
                when 'sw' { $q -= 1; $r += 1 }
                when 'w'  { $q -= 1          }
                when 'nw' { $r -= 1          }
                when 'ne' { $q += 1; $r -= 1 }
            }
        }
        my $tile-key = &quot;$q:$r&quot;;    # [1]
        if $tile-key ∈ $flipped {
            $flipped ⊖= $tile-key; # [2]
        } else {
            $flipped ∪= $tile-key; # [3]
        }
    }
    say $flipped.elems;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
459
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;First things first, we need to split the input into a list of lists, where the inner list contains the individual directions we need to move. We do so by matching each line against a regex and converting that into a list. Next, since a hexagonal grid is kind of an unconventional data structure, I decided to go with a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set&lt;/code&gt; to store the flipped tiles rather than a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; or some other traversable.&lt;/p&gt;

&lt;p&gt;Now that we have the building blocks, how do we follow these directions? I found this great resource dedicated to &lt;a href=&quot;https://www.redblobgames.com/grids/hexagons&quot;&gt;hexagonal grids&lt;/a&gt; and how to traverse them. We use something called &lt;a href=&quot;https://www.redblobgames.com/grids/hexagons/#coordinates-axial&quot;&gt;axial coordinates&lt;/a&gt;. Here is a good representation of what is happening:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/aaronreidsmith/aaronreidsmith.github.io/master/assets/images/axial-coordinates.png&quot; alt=&quot;Axial Coordinates (credit: Red Blob Games)&quot; /&gt;
&lt;sub&gt;Image credit: &lt;a href=&quot;https://www.redblobgames.com/grids/hexagons/#coordinates-axial&quot;&gt;Red Blob Games&lt;/a&gt;&lt;sub&gt;&lt;/sub&gt;&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;Basically, we move east or west, we increment or decrement our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q&lt;/code&gt; value. Similarly, if we move northwest or southeast, we increment or decrement our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt; value. If we move northeast or southwest, we increment one while decrementing the other. Now that we understand that, it is fairly easy to see what is happening in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; block.&lt;/p&gt;

&lt;p&gt;Once we reach our desired tile, we check if it is in our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$flipped&lt;/code&gt; set. If so, we need to remove it (or “un-flip” it); otherwise, it goes &lt;em&gt;in&lt;/em&gt; to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$flipped&lt;/code&gt; set. Finally, we just count the flipped tiles (via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$flipped.elems&lt;/code&gt;).&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;Sets can only contain scalars in Raku (i.e., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set.new((1, 2, 3))&lt;/code&gt; yields &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Set(1, 2, 3)&lt;/code&gt;), so we can’t just add the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt; values to the set as-is. My workaround is to convert them to a string with the format &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q:r&lt;/code&gt; so we are able to store them in a set, but still retrieve them easily later.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;⊖&lt;/code&gt; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Symmetric_difference&quot;&gt;symmetric difference&lt;/a&gt; operator, which removes elements that are present in both sets. In conjunction with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=&lt;/code&gt; operator, it reassigns to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$flipped&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;∪&lt;/code&gt; is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Union_(set_theory)&quot;&gt;set union&lt;/a&gt;, which returns all the items in both sets cast to a new set. In conjunction with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=&lt;/code&gt; operator, it reassigns to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$flipped&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;Now we find out that the tiles in the lobby are meant to be a sort-of “living art exhibit.” Every day the tiles are flipped according to the following rules:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Any &lt;strong&gt;black&lt;/strong&gt; tile with &lt;strong&gt;zero&lt;/strong&gt; or &lt;strong&gt;more than 2&lt;/strong&gt; black tiles immediately adjacent to it is flipped to &lt;strong&gt;white&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;Any &lt;strong&gt;white&lt;/strong&gt; tile with &lt;strong&gt;exactly 2&lt;/strong&gt; black tiles immediately adjacent to it is flipped to &lt;strong&gt;black&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The rules are applied simultaneously to every tile; put another way, it is first determined which tiles need to be flipped, then they are all flipped at the same time.&lt;/p&gt;

&lt;p&gt;Starting with the layout &lt;em&gt;after&lt;/em&gt; part one, what how many tiles will be black after 100 days?&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/24/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub adjacent($q, $r) {
    &quot;{$q + 1}:$r&quot;,       # [1]
    &quot;$q:{$r + 1}&quot;,
    &quot;{$q - 1}:{$r + 1}&quot;,
    &quot;{$q - 1}:$r&quot;,
    &quot;$q:{$r - 1}&quot;,
    &quot;{$q + 1}:{$r - 1}&quot;  # [2]
}

sub MAIN($file, Bool :$p2 = False) {
    my $regex = /^(e|se|sw|w|nw|ne)+$/;
    my @instructions =
        $file.IO
        .lines
        .map(-&amp;gt; $line {
            $line.match($regex).map(*.Str).split(' ')
        });

    my $flipped = Set.new;
    for @instructions -&amp;gt; @instruction-set {
        my ($q, $r) = (0, 0);
        for @instruction-set -&amp;gt; $direction {
            given $direction {
                when 'e'  { $q += 1          }
                when 'se' { $r += 1          }
                when 'sw' { $q -= 1; $r += 1 }
                when 'w'  { $q -= 1          }
                when 'nw' { $r -= 1          }
                when 'ne' { $q += 1; $r -= 1 }
            }
        }
        my $tile = &quot;$q:$r&quot;;
        if $tile ∈ $flipped {
            $flipped ⊖= $tile;
        } else {
            $flipped ∪= $tile;
        }
    }

    if $p2 {
        for (^100) {
            my $flipped-this-round = Set.new;
            my $unflipped-this-round = Set.new;
            my @q-range = $flipped.keys.map(*.split(':')[0].Int).minmax;
            my @r-range = $flipped.keys.map(*.split(':')[1].Int).minmax;
            for (@q-range.min - 1 .. @q-range.max + 1) -&amp;gt; $q {
                for (@r-range.min - 1 .. @r-range.max + 1) -&amp;gt; $r {
                    my $tile = &quot;$q:$r&quot;;
                    my $adjacent-flipped = adjacent($q, $r).grep(* ∈ $flipped).elems;
                    if $tile ∈ $flipped {
                        if $adjacent-flipped == 0 || $adjacent-flipped &amp;gt; 2 {
                            $unflipped-this-round ∪= $tile;
                        }
                    } else {
                        if $adjacent-flipped == 2 {
                            $flipped-this-round ∪= $tile;
                        }
                    }
                }
            }
            $flipped ∪= $flipped-this-round;
            $flipped ⊖= $unflipped-this-round;
        }
    }
    say $flipped.elems;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
459

$ raku main.raku --p2 input.txt
4150
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;I had some initial difficulty here because I didn’t have a good data structure to traverse, so how would this work? Turns out we don’t need it, we just need the min and max black tile coordinates (from our arbitrary starting tile), and we can traverse that way!&lt;/p&gt;

&lt;p&gt;All that was added was the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if $p2 {...}&lt;/code&gt; block, as well as a helper function (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;adjacent&lt;/code&gt;) to help find adjacent tiles. The logic here is fairly straightforward:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Once we have our layout for part 1, we kick off 100 iterations.&lt;/li&gt;
  &lt;li&gt;Within each iteration, to not affect &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$flipped&lt;/code&gt; state until the end, we create 2 new sets: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$flipped-this-round&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$unflipped-this-round&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;We find the minimum and maximum &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;q&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&lt;/code&gt; values and go one tile further (we need to account for the neighbors of those outer black tiles).&lt;/li&gt;
  &lt;li&gt;For each tile in our area we check if it is black (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$tile ∈ $flipped&lt;/code&gt;).
    &lt;ul&gt;
      &lt;li&gt;If so, we check if it has either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;gt;2&lt;/code&gt; black neighbors. If so, it goes in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$unflipped-this-round&lt;/code&gt; set.&lt;/li&gt;
      &lt;li&gt;If it is a white tile, we check if it has exactly &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; black neighbors. If so, it goes in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$flipped-this-round&lt;/code&gt; set.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;We update &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$flipped&lt;/code&gt; by unioning it with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$flipped-this-round&lt;/code&gt; and removing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$unflipped-this-round&lt;/code&gt; elements via symmetric set difference.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After 100 round, just like part one, we count our black tiles via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$flipped.elems&lt;/code&gt;!&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;Parentheses are optional when constructing a list in Raku. In this case, I felt it read better to not use them.&lt;/li&gt;
  &lt;li&gt;Additionally, semicolons are optional &lt;em&gt;for the last expression in a block&lt;/em&gt;. You have seen this before (look at those &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given/when&lt;/code&gt; blocks, for example), but I have never called it out. Similarly, I felt it read better without it here.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I had fun with this one! Maybe it helps that I am actually off for the holidays and don’t have to rush through it before or after work. Looking forward to crossing the finish line tomorrow!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Merry Christmas Eve! I had a lot more fun with today’s challenge than the past few days. It is reminiscent of days 11 and 17, but with a fun twist. I also solved it using a different data structure due to that twist, so it felt fresh.</summary></entry><entry><title type="html">Advent of Code: Day 23</title><link href="http://localhost:4000/blog/advent-of-code-day-23/" rel="alternate" type="text/html" title="Advent of Code: Day 23" /><published>2020-12-23T00:00:00-06:00</published><updated>2020-12-23T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-23</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-23/">&lt;p&gt;This is just trashy, slow code that gets the job done. Not functional, not fast, not clever, and not nice to look at. Anyway, enjoy!&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;After &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-22/&quot;&gt;yesterday’s game of War&lt;/a&gt;, the crab challenges &lt;em&gt;us&lt;/em&gt; to a game! In this game there are 10 labeled cups placed clockwise in a circle (our input). The first cup in our list is our “current cup,” and the crab is going to make &lt;strong&gt;100 moves&lt;/strong&gt;. Here is how each move works:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The crab picks up the three cups that are immediately clockwise of the current cup. They are removed from the circle; cup spacing is adjusted as necessary to maintain the circle.&lt;/li&gt;
  &lt;li&gt;The crab selects a destination cup: the cup with a label equal to the current cup’s label minus one. If this would select one of the cups that was just picked up, the crab will keep subtracting one until it finds a cup that wasn’t just picked up. If at any point in this process the value goes below the lowest value on any cup’s label, it wraps around to the highest value on any cup’s label instead.&lt;/li&gt;
  &lt;li&gt;The crab places the cups it just picked up so that they are immediately clockwise of the destination cup. They keep the same order as when they were picked up.&lt;/li&gt;
  &lt;li&gt;The crab selects a new current cup: the cup which is immediately clockwise of the current cup.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is an example of 10 moves with the input &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;389125467&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- move 1 --
cups: (3) 8  9  1  2  5  4  6  7 
pick up: 8, 9, 1
destination: 2

-- move 2 --
cups:  3 (2) 8  9  1  5  4  6  7 
pick up: 8, 9, 1
destination: 7

-- move 3 --
cups:  3  2 (5) 4  6  7  8  9  1 
pick up: 4, 6, 7
destination: 3

-- move 4 --
cups:  7  2  5 (8) 9  1  3  4  6 
pick up: 9, 1, 3
destination: 7

-- move 5 --
cups:  3  2  5  8 (4) 6  7  9  1 
pick up: 6, 7, 9
destination: 3

-- move 6 --
cups:  9  2  5  8  4 (1) 3  6  7 
pick up: 3, 6, 7
destination: 9

-- move 7 --
cups:  7  2  5  8  4  1 (9) 3  6 
pick up: 3, 6, 7
destination: 8

-- move 8 --
cups:  8  3  6  7  4  1  9 (2) 5 
pick up: 5, 8, 3
destination: 1

-- move 9 --
cups:  7  4  1  5  8  3  9  2 (6)
pick up: 7, 4, 1
destination: 5

-- move 10 --
cups: (5) 7  4  1  8  3  9  2  6 
pick up: 7, 4, 1
destination: 3

-- final --
cups:  5 (8) 3  7  4  1  9  2  6 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After the crab is done, what order will the cups be in? Starting after the cup labeled 1, collect the other cups’ labels clockwise into a single string with no extra characters; each number except &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; should appear exactly once. In the above example, after 10 moves, the cups clockwise from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; are labeled &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;9&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt;, and so on, producing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;92658374&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;What is the answer after 100 moves with an input of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;712643589&lt;/code&gt;?&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/23/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($file) {
    my @ring;
    my ($current, $previous);
    for $file.IO.slurp.comb -&amp;gt; $number {
        $current //= $number.Int;            # [1]
        with $previous {                     # [2]
            @ring[$previous] = $number.Int;
        }
        $previous = $number.Int;
    }
    @ring[$previous] = $current;

    for (^100) {
        my $pointer = $current;
        my %grabbed = %(
            0 =&amp;gt; True,
            |(1 .. 3).map({
                $pointer = @ring[$pointer]; # [3]
                $pointer =&amp;gt; True;
            }).Hash
        );

        my $destination = $current - 1;
        while %grabbed{$destination}:exists {
            $destination = ($destination - 1) % 10;
        }

        (@ring[$current], @ring[$pointer], @ring[$destination]) = (@ring[$pointer], @ring[$destination], @ring[$current]);

        $current = @ring[$current];
    }

    $current = 1;
    my $output;
    while (($current = @ring[$current]) != 1) {
        $output ~= $current;                    # [4]
    }
    say $output;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
29385746
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;We use a circularly-linked-list (stored in a list of integers) for this.&lt;/p&gt;

&lt;p&gt;Once we have parsed our input, we created the linked list by keeping track of our &lt;em&gt;current&lt;/em&gt; and &lt;em&gt;previous&lt;/em&gt; cups. Then, for 100 iterations, we “grab” 3 cups (plus 0, which is an empty artifact of the way we fill our list), find the next destination cup by decrementing until we find one in the remaining cups, then swapping all the pointers to insert the three “grabbed” cups. For part one, this is a fairly quick process (~0.36s).&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;//&lt;/code&gt; operator returns the left-hand-side if it is defined, otherwise the right-hand side. In combination with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=&lt;/code&gt; operator, it is the same as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$current = $current.defined ?? $current !! $number&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; operator only enters the block if the variable is defined. This is the same as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if $previous.defined {...}&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;I hate that we update an outside variable in a map statement. Makes me cringe, but I wrote it, so guess I can’t complain too much.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~&lt;/code&gt; is Raku’s concatenate operator. So we are taking the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$output&lt;/code&gt; variable, concatenating &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$current&lt;/code&gt; and reassigning to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$output&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;The crab adds almost &lt;em&gt;a million&lt;/em&gt; more cups to the game. After the 9 initial ones, we add 999,991 more labeled 10 to 1,000,000. Once he has done that, he hides 2 stars in the cups that will end up in the two spots immediately following the cup labeled &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; after &lt;em&gt;10 million&lt;/em&gt; rounds. What is the product of those two cup labels?&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/23/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub part1($file) {
    my @ring;
    my ($current, $previous);
    for $file.IO.slurp.comb -&amp;gt; $number {
        $current //= $number.Int;
        with $previous {
            @ring[$previous] = $number.Int;
        }
        $previous = $number.Int;
    }
    @ring[$previous] = $current;

    for (^100) {
        my $pointer = $current;
        my %grabbed = %(
            0 =&amp;gt; True,
            |(1 .. 3).map({
                $pointer = @ring[$pointer];
                $pointer =&amp;gt; True;
            }).Hash
        );

        my $destination = $current - 1;
        while %grabbed{$destination}:exists {
            $destination = ($destination - 1) % 10;
        }

        (@ring[$current], @ring[$pointer], @ring[$destination]) = (@ring[$pointer], @ring[$destination], @ring[$current]);

        $current = @ring[$current];
    }

    $current = 1;
    my $output;
    while (($current = @ring[$current]) != 1) {
        $output ~= $current;
    }
    say $output;
}

sub part2($file) {
    my @ring;
    my ($current, $previous);
    for $file.IO.slurp.comb -&amp;gt; $number {
        $current //= $number.Int;
        with $previous {
            @ring[$previous] = $number.Int;
        }
        $previous = $number.Int;
    }

    for (10..1_000_000) -&amp;gt; $i {
        @ring[$previous] = $i;
        $previous = $i;
    }
    @ring[$previous] = $current;

    for (^10_000_000) {
        my $pointer = $current;
        my %grabbed = %(
            0 =&amp;gt; True,
            |(1 .. 3).map({
                $pointer = @ring[$pointer];
                $pointer =&amp;gt; True;
            }).Hash
        );

        my $destination = $current - 1;
        while %grabbed{$destination}:exists {
            $destination = ($destination - 1) % 1_000_001;
        }

        my $old             = @ring[$current];
        @ring[$current]     = @ring[$pointer];
        @ring[$pointer]     = @ring[$destination];
        @ring[$destination] = $old;

        $current = @ring[$current];
    }

    say @ring[1] * @ring[@ring[1]];
}

sub MAIN($file, Bool :$p2 = False) {
    $p2 ?? part2($file) !! part1($file);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
29385746

$ raku main.raku --p2 input.txt
712643589
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;As you can see, rather than try to retrofit the code today, I just wrote two functions that are &lt;em&gt;almost&lt;/em&gt; exactly the same. The differences are as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Part 2 adds the extra cups&lt;/li&gt;
  &lt;li&gt;Part 2 has more iterations&lt;/li&gt;
  &lt;li&gt;Part 2 needs a different modulo to find if a cup is in the valid range&lt;/li&gt;
  &lt;li&gt;Part 2 reassigns the pointers in order rather than all at once
    &lt;ul&gt;
      &lt;li&gt;Shifting that much data in one step really hurt Raku&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;We output the product of 2 numbers instead of just the order of the cups&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There is not too much to dive into with this one since it is the same problem with bigger numbers. It’s ugly, and I hate it. And, in contrast to part one, it is slow as all get out; it finishes in 351.32s (almost 6 minutes), which makes it 979 times slower than part one. Yikes.&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I am burnt out on this, but I am planning on finishing the week out. I enjoy most of the puzzles, but the blogging is starting to wear on me. 😅 2 more days; we got this!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">This is just trashy, slow code that gets the job done. Not functional, not fast, not clever, and not nice to look at. Anyway, enjoy!</summary></entry></feed>