<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-12-15T16:54:09-06:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Aaron Smith</title><subtitle>Personal website and blog of Aaron Smith</subtitle><author><name>Aaron Smith</name></author><entry><title type="html">Advent of Code: Day 15</title><link href="http://localhost:4000/blog/advent-of-code-day-15/" rel="alternate" type="text/html" title="Advent of Code: Day 15" /><published>2020-12-15T00:00:00-06:00</published><updated>2020-12-15T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-15</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-15/">&lt;p&gt;Even with how short and sweet today‚Äôs solution is, I had to rewrite it between parts one and two after hitting the maximum recursion depth. So we‚Äôve got one functional, recursive solution and one imperative, iterative solution!&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;While we wait for our next flight, we decide to call the elves back at the North Pole. They‚Äôre playing a memory game that they want us to join.&lt;/p&gt;

&lt;p&gt;In this game, the players take turns saying numbers. They begin by taking turns reading from a list of starting numbers (your puzzle input). Then, each turn consists of considering the most recently spoken number:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If that was the first time the number has been spoken, the current player says &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Otherwise, the number had been spoken before; the current player announces how many turns apart the number is from when it was previously spoken.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is an example with input &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0,3,6&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Turn 1: The 1st number spoken is a starting number, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Turn 2: The 2nd number spoken is a starting number, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Turn 3: The 3rd number spoken is a starting number, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Turn 4: Now, consider the last number spoken, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6&lt;/code&gt;. Since that was the first time the number had been spoken, the 4th number spoken is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Turn 5: Next, again consider the last number spoken, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;. Since it had been spoken before, the next number to speak is the difference between the turn number when it was last spoken (the previous turn, 4) and the turn number of the time it was most recently spoken before then (turn 1). Thus, the 5th number spoken is 4 - 1, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Turn 6: The last number spoken, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt; had also been spoken before, most recently on turns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt;. So, the 6th number spoken is 5 - 2, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Turn 7: Since 3 was just spoken twice in a row, and the last two turns are 1 turn apart, the 7th number spoken is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Turn 8: Since 1 is new, the 8th number spoken is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Turn 9: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; was last spoken on turns 8 and 4, so the 9th number spoken is the difference between them, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Turn 10: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4&lt;/code&gt; is new, so the 10th number spoken is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given an input of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;11,18,0,20,1,7,16&lt;/code&gt;, what will be the 2020&lt;sup&gt;th&lt;/sup&gt; number?&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/15/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub play-game(%numbers, $turn, $number, $target-turn) {
    if $turn == $target-turn {
        $number;
    } else {
        my $next-number = %numbers{$number}:exists ?? $turn - %numbers{$number} !! 0;        # [1]
        play-game(%(|%numbers, |($number =&amp;gt; $turn)), $turn + 1, $next-number, $target-turn); # [2]
    }
}

sub MAIN($file, Bool :$p2 = False) {
    my %initial = $file.IO.slurp.split(',').kv.map(-&amp;gt; $key, $value { $value =&amp;gt; $key + 1 } ).Hash;
    say play-game(%initial, %initial.elems + 1, 0, 2020);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
639
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;So, in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; we first pull everything from our input into a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt; with the keys being the number that was said by the elves, and the value being the turn it was said on. Then we pass that to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;play-game&lt;/code&gt; with four parameters:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt; itself&lt;/li&gt;
  &lt;li&gt;The turn we are starting on (in the case of our input, 8)&lt;/li&gt;
  &lt;li&gt;The next number in the sequence (since our input is so small, we can hard-code this to 0)&lt;/li&gt;
  &lt;li&gt;The number in the sequence we are hoping to find (2020)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;play-game&lt;/code&gt; will recursively do the following (until it hits turn 2020):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If we have seen this number find the difference between this turn, and the turn it was last said on, otherwise &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Update the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%numbers&lt;/code&gt; variable with the new number/turn pair&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That‚Äôs it!&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:exists&lt;/code&gt; tag here is something called an &lt;a href=&quot;https://docs.raku.org/language/subscripts#index-entry-:exists_(subscript_adverb)&quot;&gt;adverb&lt;/a&gt; in Raku. It is the equivalent of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;key in dictionary&lt;/code&gt; in Python.&lt;/li&gt;
  &lt;li&gt;There is some special syntax on this line for merging hashes without mutating the original hashes. The slip character (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt;) unpacks the two hashes into an outer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt; (denoted by the preceding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%&lt;/code&gt; sigil) and gives precedence to the second &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt;. Here is what that means in simple terms:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my %a = (a =&amp;gt; 1, b =&amp;gt; 2);  # {a =&amp;gt; 1, b =&amp;gt; 2} 
my %b = (b =&amp;gt; 3, c =&amp;gt; 4);  # {b =&amp;gt; 3, c =&amp;gt; 4}
my %c = %(|%a, |%b);       # {a =&amp;gt; 1, b =&amp;gt; 3, c =&amp;gt; 4}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;The elves are impressed with our memory skills, so they up the ante! What is the &lt;em&gt;30 millionth&lt;/em&gt; term in the sequence?&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/15/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub play-game-recursive(%numbers, $turn, $number, $target-turn) {
    if $turn == $target-turn {
        $number;
    } else {
        my $next-turn = %numbers{$number}:exists ?? $turn - %numbers{$number} !! 0;
        play-game-recursive(
            %(|%numbers, |($number =&amp;gt; $turn)),
            $turn + 1,
            $next-turn,
            $target-turn
        );
    }
}

sub play-game-iterative(%numbers is copy, $target-turn) {                                      # [1]
    my $last-item = %numbers.pairs.sort({ $^a.value cmp $^b.value })[*-1];                     # [2]
    for (%numbers.elems^..$target-turn) -&amp;gt; $turn {                                             # [3]
        my $new-item = %numbers{$last-item}:exists ?? ($turn - 1) - %numbers{$last-item} !! 0;
        %numbers{$last-item} = $turn - 1;
        $last-item = $new-item;
    }
    $last-item;
}

sub MAIN($file, Bool :$p2 = False) {
    my %initial = $file.IO.slurp.split(',').kv.map(-&amp;gt; $key, $value { $value =&amp;gt; $key + 1 } ).Hash;
    my $last-turn = $p2 ?? 30_000_000 !! 2020;                                                    # [4]
    say play-game-iterative(%initial, $last-turn);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
639

# Part 2
$ raku main.raku --p2 input.txt
266
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;So the first thing you‚Äôll notice is I refactored &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;play-game&lt;/code&gt; to be called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;play-game-recursive&lt;/code&gt;; this is not used anywhere, it was simply left in to show the progression of the code.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; does the same thing, but changes the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$last-turn&lt;/code&gt; value based on if it is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$p2&lt;/code&gt; or not, but then passes the input to an &lt;em&gt;iterative&lt;/em&gt; solution. The iterative solution basically just keeps the last-said number in memory and checks if it exists in our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%number&lt;/code&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt;. If so, it finds the difference between the last turn, and the last time it was said and that is our next number, otherwise it is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;. We then add that new number to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%numbers&lt;/code&gt; and keep going.&lt;/p&gt;

&lt;p&gt;For 30 million iterations this solution is still pretty slow, but it works where the recursive solution just dies.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is copy&lt;/code&gt; parameter tells the subroutine that it is receiving a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;copy&lt;/code&gt; of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%numbers&lt;/code&gt; and it is safe to mutate it.&lt;/li&gt;
  &lt;li&gt;Since a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt; does not guarantee order, we need to implement a custom sort algorithm. In this case, we are sorting by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value&lt;/code&gt; of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Pair&lt;/code&gt; objects, which is the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;turn&lt;/code&gt; in our scenario. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$^a&lt;/code&gt; syntax is special here in that it assigns and uses a variable all at once. This is the equivalent of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.sort(-&amp;gt; $a, $b { $a.value cmp $b.value })&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^..&lt;/code&gt; syntax means it is a range &lt;em&gt;exclusive&lt;/em&gt; of the bottom end but &lt;em&gt;inclusive&lt;/em&gt; of the top; the corresponding math notation is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a, b]&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Raku (like many languages) allows us to put underscores in numeric literals to make them easier to read.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;This is obviously a time when recursion is not the best idea. It‚Äôs important to be able to distinguish what can be done recursively and what must be done iteratively, even if the recursive solution seems more ‚Äúnatural.‚Äù&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Even with how short and sweet today‚Äôs solution is, I had to rewrite it between parts one and two after hitting the maximum recursion depth. So we‚Äôve got one functional, recursive solution and one imperative, iterative solution!</summary></entry><entry><title type="html">Advent of Code: Day 14</title><link href="http://localhost:4000/blog/advent-of-code-day-14/" rel="alternate" type="text/html" title="Advent of Code: Day 14" /><published>2020-12-14T00:00:00-06:00</published><updated>2020-12-14T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-14</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-14/">&lt;p&gt;Today was much less math-heavy than yesterday, although we will dive into an algorithm that would make it faster. However, I did do this problem more imperatively than functionally; read on to see why!&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;As we approach the mainland, the captain once again asks for our help; our computer system is not compatible with the port‚Äôs docking software. We quickly see that the docking parameters are not being properly initialized. The docking program is using a strange bitmask software, and we don‚Äôt have the proper chip to decode it. Luckily, we can emulate it.&lt;/p&gt;

&lt;p&gt;Our input looks like the following:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mask = XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
mem[8] = 11
mem[7] = 101
mem[8] = 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This defines a 36-bit bitmask and multiple memory addresses to update with bitmasked values. Here is how the bitmask is applied:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;value:  000000000000000000000000000000001011  (decimal 11)
mask:   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
result: 000000000000000000000000000001001001  (decimal 73)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;First, a value (in this case 11) is converted to binary and then the mask is applied by using the mask character if it‚Äôs a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; and the original character if it is an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X&lt;/code&gt;. As you can see, this gives us the number 73 represented as binary. We then store &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;73&lt;/code&gt; at memory address 8 and move on to the next instruction.&lt;/p&gt;

&lt;p&gt;Once all instructions have been applied, what is the sum of values in memory?&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/14/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub apply-mask($mask, $num) {
    my @mask-list = $mask.comb;
    my @num-list  = $num.base(2).comb;

    while @num-list.elems &amp;lt; @mask-list.elems {
        @num-list.unshift(0);                                 # [1]
    }

    my @masked = gather {
        for @mask-list Z @num-list -&amp;gt; ($mask-digit, $digit) { # [2]
            take $mask-digit eq 'X' ?? $digit !! $mask-digit;
        }
    }

    @masked.join.parse-base(2);
}

sub extract-values($line) {
    my $address = $line.match(/\[(&amp;lt;digit&amp;gt;+)\]/)[0].Int;
    my $value = $line.split(' = ')[1].Int;
    ($address, $value)
}

sub MAIN($file) {
    my $mask;
    my @mem;
    for $file.IO.lines -&amp;gt; $line {
        if $line.starts-with('mask') {
            $mask = $line.split(' = ')[1];
        } else {
            my ($address, $value) = extract-values($line);
            @mem[$address] = apply-mask($mask, $value);
        }
    }
    say @mem.sum; # [3]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
17934269678453
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;So, first we define 2 helper functions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply-mask&lt;/code&gt; takes a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mask&lt;/code&gt; string and an integer, then converts it to binary and iteratively works through the strings to apply the mask to the integer, then it casts the string back to a base-10 integer.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extract-values&lt;/code&gt; simply parse the memory address and value to be masked from the input line.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; you can see how imperatively we did this. First, we define a mutable mask&lt;sup&gt;*&lt;/sup&gt; and memory register, then start iterating through the lines. If we hit a mask, overwrite our current one, otherwise extract the values, apply the mask, and add it to our memory register. Finally, just sum all the masked values up!&lt;/p&gt;

&lt;p&gt;&lt;sup&gt;*&lt;/sup&gt;One thing about our input that was not super clear to me in the instructions is that we are given &lt;em&gt;multiple&lt;/em&gt; masks that we have to apply to the next N values (until we hit the next mask).&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unshift&lt;/code&gt; adds values to the beginning of an array. Raku has no equivalent of Python‚Äôs &lt;a href=&quot;https://docs.python.org/3/library/itertools.html#itertools.zip_longest&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;zip_longest&lt;/code&gt;&lt;/a&gt; function, so we have to make sure the input lists are exactly the same length.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Z&lt;/code&gt; is Raku‚Äôs zip operator. So &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 2, 3) Z (4, 5, 6)&lt;/code&gt; yields &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((1, 4), (2, 5), (3, 6))&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Notice we never initialized a size of this array. Raku doesn‚Äôt require us to! It will implicitly fill in any unused slots with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt;, which is one of its undefined types. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt; is skipped during the sum, so it really is just as simple as saying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@mem.sum&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;After all that business, we realize the docking computer must be running version 2 of the software while we are still on version 1. ü§¶üèª&lt;/p&gt;

&lt;p&gt;V2 of the software applies the bitmask to memory &lt;em&gt;addresses&lt;/em&gt;, not the &lt;em&gt;values&lt;/em&gt;. Additionally, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X&lt;/code&gt; now means ‚Äúfloating‚Äù (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 or 1&lt;/code&gt;), so we have to update both possible addresses. Here is an example:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;address: 000000000000000000000000000000101010  (decimal 42)
mask:    000000000000000000000000000000X1001X
result:  000000000000000000000000000000X1101X
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After the mask, we are left with &lt;em&gt;four&lt;/em&gt; addresses to update:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;000000000000000000000000000000011010  (decimal 26)
000000000000000000000000000000011011  (decimal 27)
000000000000000000000000000000111010  (decimal 58)
000000000000000000000000000000111011  (decimal 59)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Using V2, what is the sum of the memory addresses after initialization?&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/14/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub find-all-masks(@zipped, $pointer = 0, @prefix = ()) {                          # [1]
    if $pointer == @zipped.elems {
        @prefix.join.parse-base(2);
    } else {
        my ($mask-digit, $digit) = @zipped[$pointer];
        given $mask-digit {
            when '0' { find-all-masks(@zipped, $pointer + 1, (|@prefix, $digit)) } # [2]
            when '1' { find-all-masks(@zipped, $pointer + 1, (|@prefix, $mask-digit)) }
            when 'X' {
                |(
                    find-all-masks(@zipped, $pointer + 1, (|@prefix, '0')),
                    find-all-masks(@zipped, $pointer + 1, (|@prefix, '1'))
                )
            }
        }
    }
}

sub apply-mask($mask, $num, Bool $part-two = False) {
    my @mask-list = $mask.comb;
    my @num-list  = $num.base(2).comb;

    while @num-list.elems &amp;lt; @mask-list.elems {
        @num-list.unshift(0);
    }

    if $part-two {
        find-all-masks(@mask-list Z @num-list);
    } else {
        my @masked = gather {
            for @mask-list Z @num-list -&amp;gt; ($mask-digit, $digit) {
                take $mask-digit eq 'X' ?? $digit !! $mask-digit;
            }
        }
        @masked.join.parse-base(2);
    }
}

sub extract-values($line) {
    my $address = $line.match(/\[(&amp;lt;digit&amp;gt;+)\]/)[0].Int;
    my $value = $line.split(' = ')[1].Int;
    ($address, $value)
}

sub MAIN($file, Bool :$p2 = False) {
    my $mask;
    my @mem;
    for $file.IO.lines -&amp;gt; $line {
        if $line.starts-with('mask') {
            $mask = $line.split(' = ')[1];
        } else {
            my ($address, $value) = extract-values($line);
            if $p2 {
                for apply-mask($mask, $address, $p2) -&amp;gt; $index {
                    @mem[$index] = $value;
                }
            } else {
                @mem[$address] = apply-mask($mask, $value);
            }
        }
    }
    say @mem.sum;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
17934269678453

# Part 2
$ raku main.raku --p2 input.txt
3440662844064
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;We made a few tweaks to the original program:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If it is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$part-two&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply-mask&lt;/code&gt; now returns a list of integers instead of just a single integer.&lt;/li&gt;
  &lt;li&gt;Given the above, if it is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$p2&lt;/code&gt; in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt;, we iterate through the returned list.&lt;/li&gt;
  &lt;li&gt;We added a function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find-all-masks&lt;/code&gt; that will find all binary combinations for the ‚Äúfloating‚Äù bits.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The logic is pretty much the same, except using addresses instead of values!&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;This solution works, but it is &lt;em&gt;slow&lt;/em&gt; and memory intensive. The correct way to find all of these bit flips is by using something called a &lt;a href=&quot;https://en.wikipedia.org/wiki/Gray_code&quot;&gt;Gray code&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;We use these slips all over this to make sure we end up with just a 1D list (per call) when all is said and done.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I am enjoying learning about all the shortcuts that are necessary to make these things run in an acceptable amount of time. Maybe next year I will be able to think of them without writing the brute force solution first!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Today was much less math-heavy than yesterday, although we will dive into an algorithm that would make it faster. However, I did do this problem more imperatively than functionally; read on to see why!</summary></entry><entry><title type="html">Advent of Code: Day 13</title><link href="http://localhost:4000/blog/advent-of-code-day-13/" rel="alternate" type="text/html" title="Advent of Code: Day 13" /><published>2020-12-13T00:00:00-06:00</published><updated>2020-12-14T18:46:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-13</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-13/">&lt;p&gt;Today‚Äôs challenge was‚Ä¶ interesting, to say the least. It may look short and sweet, but it is fairly complex and requires a fair bit of &lt;a href=&quot;https://en.wikipedia.org/wiki/Number_theory&quot;&gt;number theory&lt;/a&gt; for part two.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;After &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-12/&quot;&gt;yesterday‚Äôs fiasco&lt;/a&gt;, our ferry is being forced to make an emergency stop on a different island. Unfortunately, there are no ferries from this island to our destination island; once again, we will have to take a plane. To get to the airport, our only option is a bus. Bus IDs also correspond to how often they come. I.e., a bus with ID 7 will come at timestamps 0, 7, 14, etc.&lt;/p&gt;

&lt;p&gt;We took a few notes (our input) on the bus schedule. Example:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;939
7,13,x,x,59,x,31,19
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first line is the earliest timestamp we will be able to make it to the bus station, and the second line is a list of bus IDs; buses that are out of service are denoted with an X. Given this information, our goal is to find the earliest bus that will get us to the airport. With the above example, we can see how this breaks down (in the below table a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt; means ‚Äúdeparture‚Äù):&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;time   bus 7   bus 13  bus 59  bus 31  bus 19
929      .       .       .       .       .
930      .       .       .       D       .
931      D       .       .       .       D
932      .       .       .       .       .
933      .       .       .       .       .
934      .       .       .       .       .
935      .       .       .       .       .
936      .       D       .       .       .
937      .       .       .       .       .
938      D       .       .       .       .
939      .       .       .       .       .  &amp;lt;--- Time we make it to the bus station
940      .       .       .       .       .
941      .       .       .       .       .
942      .       .       .       .       .
943      .       .       .       .       .
944      .       .       D       .       .  &amp;lt;--- First bus that can take us to the airport
945      D       .       .       .       .
946      .       .       .       .       .
947      .       .       .       .       .
948      .       .       .       .       .
949      .       D       .       .       .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once we have found the bus that can take us to the airport, we need to calculate the product of the bus ID and our wait time. In the example above it would be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;59 * (944 - 939) = 295&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/13/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($file) {
    my @input = $file.IO.lines;
    my $arrival-time = @input[0].Int;
    my @buses = @input[1].split(',').grep(* ne 'x').map(*.Int);
    say [*] @buses
            .map(-&amp;gt; $id { ($id, $id - $arrival-time % $id) })
            .min(*[1])
            .flat;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
261
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;Since our bus timestamps will always just be multiples of the bus ID, we can look at just the bus IDs themselves to find how long we will be waiting. When we calculate the remainder between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$arrival-time&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$id&lt;/code&gt;, it will show us how many minutes have passed &lt;strong&gt;since the last bus&lt;/strong&gt;. Let‚Äôs look at this in context:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;939 % 7  = 1  (means there was a bus 1 minute ago)
939 % 13 = 3  (means there was a bus 3 minutes ago)
939 % 59 = 54 (means there was a bus 54 minutes ago)
939 % 31 = 9  (means there was a bus 9 minutes ago)
939 % 19 = 8  (means there was a bus 8 minutes ago)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, looking at the above, it is not immediately obvious what we need to do. Basically, since we know how often a bus comes, we want to minimize the value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$id - &amp;lt;output of above&amp;gt;&lt;/code&gt;. To do that, we simply subtract the amount of time that has passed for each bus from its scheduled departure time:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 7 - (939 %  7) =  7 - 1  = 6
13 - (939 % 13) = 13 - 3  = 10
59 - (939 % 59) = 59 - 54 = 5
31 - (939 % 31) = 31 - 9  = 22
19 - (939 % 19) = 19 - 8  = 11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So from this, it is obvious that bus 59 has the shortest time to next departure, so that is the best choice. At this point, we multiply 59 * 5 and get 295.&lt;/p&gt;

&lt;p&gt;I feel the code reflects this pretty well. The first three lines are just pulling the data in, removing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt; buses, and converting things to integers. After that, for each bus ID, we do the calculations above, then filter it down to the minimum wait time. Finally, we flatten it into one list and multiply the values (via the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[*]&lt;/code&gt; metaoperator). That‚Äôs it!&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;p&gt;No specific comments today; I feel it is pretty straightforward.&lt;/p&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;So after all the time we just spent to find the bus that will get us to the airport the fastest, we throw it all out the window.&lt;/p&gt;

&lt;p&gt;The shuttle company is running a contest to find the earliest timestamp such that each bus will depart one minute after the next. In the case of an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;, there no constraints on bus IDs in that slot. So, given the same input as above:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;7,13,x,x,59,x,31,19
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We are looking for a timestamp (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;) that satisfies these conditions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Bus ID &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;7&lt;/code&gt; departs at timestamp &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Bus ID &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;13&lt;/code&gt; departs one minute after timestamp &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;There are no requirements or restrictions on departures at two or three minutes after timestamp &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Bus ID &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;59&lt;/code&gt; departs four minutes after timestamp &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;There are no requirements or restrictions on departures at five minutes after timestamp &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Bus ID &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;31&lt;/code&gt; departs six minutes after timestamp &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Bus ID &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;19&lt;/code&gt; departs seven minutes after timestamp &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this example, the answer is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1068781&lt;/code&gt;, as shown here:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;time     bus 7   bus 13  bus 59  bus 31  bus 19
1068773    .       .       .       .       .
1068774    D       .       .       .       .
1068775    .       .       .       .       .
1068776    .       .       .       .       .
1068777    .       .       .       .       .
1068778    .       .       .       .       .
1068779    .       .       .       .       .
1068780    .       .       .       .       .
1068781    D       .       .       .       .  &amp;lt;--- Bus 7 departs at timestamp `t`
1068782    .       D       .       .       .  &amp;lt;--- Bus 13 departs 1 minutes after `t`
1068783    .       .       .       .       .
1068784    .       .       .       .       .
1068785    .       .       D       .       .  &amp;lt;--- Bus 59 departs 4 minutes after `t`
1068786    .       .       .       .       .
1068787    .       .       .       D       .  &amp;lt;--- Bus 31 departs 6 minutes after `t`
1068788    D       .       .       .       D  &amp;lt;--- Bus 19 departs 7 minutes after `t`
1068789    .       .       .       .       .
1068790    .       .       .       .       .
1068791    .       .       .       .       .
1068792    .       .       .       .       .
1068793    .       .       .       .       .
1068794    .       .       .       .       .
1068795    D       D       .       .       .
1068796    .       .       .       .       .
1068797    .       .       .       .       .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Looking at our notes (our input), we realize that timestamp &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt; will &lt;em&gt;surely&lt;/em&gt; be larger thn &lt;strong&gt;100 &lt;em&gt;trillion&lt;/em&gt;&lt;/strong&gt;, so we need to be smart about how we calculate it.&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/13/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($file, Bool :$p2 = False) {
    my @input = $file.IO.lines;
    if $p2 {
        # https://brilliant.org/wiki/chinese-remainder-theorem
        my @buses = @input[1].split(',').antipairs.grep(*.key ne 'x');

        my @times = @buses.map(*.key.Int);
        my @offsets = @buses.map(-&amp;gt; $pair { $pair.key - $pair.value });

        my $N = [*] @times;
        my @x = do for @offsets Z @times -&amp;gt; ($offset, $depart-time) {
            $offset * ($N div $depart-time) * expmod($N div $depart-time, -1, $depart-time);
        }

        say @x.sum % $N;
    } else {
        my @buses = @input[1].split(',').grep(* ne 'x').map(*.Int);
        my $arrival-time = @input[0].Int;
        say [*] @buses
                .map(-&amp;gt; $id { ($id, $id - $arrival-time % $id) })
                .min(*[1])
                .flat;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
261

# Part 2
$ raku main.raku --p2 input.txt
807435693182510
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;So obviously, given the hint about 100 trillion in the problem, we can‚Äôt just brute force this. The brute force method (using the example data) would be to start at 100 trillion and basically just go one-by-one until each subsequent bus passes our tests. Given that our actual output is closer to 1 quadrillion, that would take &lt;em&gt;forever&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;That‚Äôs where number theory comes in. As I commented in the code, there is something called &lt;a href=&quot;https://en.wikipedia.org/wiki/Chinese_remainder_theorem&quot;&gt;Chinese remainder theorem&lt;/a&gt; that basically states the following:&lt;/p&gt;

&lt;p&gt;Given the following items:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A sequence &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; of &lt;a href=&quot;https://en.wikipedia.org/wiki/Coprime_integers#Coprimality_in_sets&quot;&gt;pairwise coprime&lt;/a&gt; integers&lt;/li&gt;
  &lt;li&gt;A sequence &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;, such that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 &amp;lt;= ai &amp;lt; ni&lt;/code&gt; for every &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;An integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; defined as the product of all integers in the sequence &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is exactly one number, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;, in the range &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 &amp;lt;= x &amp;lt; N&lt;/code&gt; such that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x % ai == ni&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I won‚Äôt go too deep into the math here, but basically (again, using example data) we have the following terms:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Our sequence &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;7, 13, 59, 31, 19&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Our sequence &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0, 1, 4, 6, 7&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Our number &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;7 * 13 * 59 * 31 * 19 = 3162341&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And we basically solve for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;. That‚Äôs pretty much as far as I can go with this explanation, as Chinese remainder theorem is pretty advanced for me as well. I just converted the proof in the commented link to Raku to make this work üôÇ&lt;/p&gt;

&lt;p&gt;When we do this with our real data, rather than running forever, it finishes in about 0.27 seconds (using a fairly slow language).&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;p&gt;I don‚Äôt fully understand the implementation here, so I have nothing to add üòÇ&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;We are officially past the halfway point! I wouldn‚Äôt say this was the toughest one, it felt like more of a trick question. Regardless, I expect the difficulty to start ramping quite a bit; hopefully I can keep up.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Today‚Äôs challenge was‚Ä¶ interesting, to say the least. It may look short and sweet, but it is fairly complex and requires a fair bit of number theory for part two.</summary></entry><entry><title type="html">Advent of Code: Day 12</title><link href="http://localhost:4000/blog/advent-of-code-day-12/" rel="alternate" type="text/html" title="Advent of Code: Day 12" /><published>2020-12-12T00:00:00-06:00</published><updated>2020-12-12T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-12</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-12/">&lt;p&gt;Today was the first day where I didn‚Äôt use the same code for parts one and two ‚Äì they were just too different! Other than that, this is a classic recursive solution with a hint of middle school algebra.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;We finally got on the ferry to our vacation destination after the &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-11/&quot;&gt;day 11&lt;/a&gt; nonsense. However, we hit a patch of bad weather that knocked the navigation computer out. Luckily, as it was dying, it printed out its final instructions, and the captain needs help interpreting what it produced.&lt;/p&gt;

&lt;p&gt;The instructions (our input) consist of single-character actions followed by values. Here is an example followed by our interpretation for the captain:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;F10
N3
F7
R90
F11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Action &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; means to move north by the given value.&lt;/li&gt;
  &lt;li&gt;Action &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt; means to move south by the given value.&lt;/li&gt;
  &lt;li&gt;Action &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt; means to move east by the given value.&lt;/li&gt;
  &lt;li&gt;Action &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;W&lt;/code&gt; means to move west by the given value.&lt;/li&gt;
  &lt;li&gt;Action &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;L&lt;/code&gt; means to turn left the given number of degrees.&lt;/li&gt;
  &lt;li&gt;Action &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; means to turn right the given number of degrees.&lt;/li&gt;
  &lt;li&gt;Action &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt; means to move forward by the given value in the direction the ship is currently facing.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Our ship is fairly sophisticated, so it does not need to face the direction it is moving. If we are currently facing east, what is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Taxicab_geometry&quot;&gt;Manhattan distance&lt;/a&gt; from where we started after we execute the instructions?&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/12/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub turn-ship($facing-direction, $turning-direction, $degrees) {
    my %turns = (
        N =&amp;gt; { L =&amp;gt; 'W', R =&amp;gt; 'E' },  # [1][2]
        E =&amp;gt; { L =&amp;gt; 'N', R =&amp;gt; 'S' },
        S =&amp;gt; { L =&amp;gt; 'E', R =&amp;gt; 'W' },
        W =&amp;gt; { L =&amp;gt; 'S', R =&amp;gt; 'N' }
    );

    if $degrees == 0 {
        $facing-direction;
    } else {
        my $new-degrees = $degrees - 90;
        my $new-direction = %turns{$facing-direction}{$turning-direction};
        turn-ship($new-direction, $turning-direction, $new-degrees);
    }
}

sub traverse(
    @directions,
    $pointer = 0,
    $current-direction = 'E',
    @current-position = (0, 0)
) {
    if $pointer == @directions.elems {
        @current-position.map(*.abs).sum;
    } else {
        my ($i, $j) = @current-position;
        my $new-pointer = $pointer + 1;
        my $direction = @directions[$pointer].subst('F', $current-direction); # [3]
        given $direction {
            # Traversal directions
            when /(N|E|S|W)(&amp;lt;digit&amp;gt;+)/ {
                my @new-position = do given $/[0].Str {                       # [4]
                    when 'N' { ($i - $/[1].Int, $j) }
                    when 'E' { ($i, $j + $/[1].Int) }
                    when 'S' { ($i + $/[1].Int, $j) }
                    when 'W' { ($i, $j - $/[1].Int) }
                };
                traverse(
                    @directions,
                    $new-pointer,
                    $current-direction,
                    @new-position
                );
            }
            # Turning directions
            when /(L|R)(&amp;lt;digit&amp;gt;+)/ {
                traverse(
                    @directions,
                    $new-pointer,
                    turn-ship($current-direction, $/[0].Str, $/[1].Int),
                    ($i, $j)
                );
            }
        }
    }
}

sub MAIN($file) {
    say traverse($file.IO.lines);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
1186
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; only has one line; most of the logic happens in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traverse&lt;/code&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traverse&lt;/code&gt; is a recursive subroutine that requires: the directions, a pointer to which step we are on, the direction we are currently facing, and an ordered pair describing our current position.&lt;/p&gt;

&lt;p&gt;The logic in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traverse&lt;/code&gt; is pretty simple:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If we are at the end of the list of directions, return the sum of the absolute values of our position (aka the Manhattan distance); otherwise, we will read the next instruction.&lt;/li&gt;
  &lt;li&gt;If the next instruction is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N|E|S|W|F&lt;/code&gt;, we simply move our position in the desired direction and go to the next instruction.&lt;/li&gt;
  &lt;li&gt;If the next instruction is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;L&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt;, we call the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;turn-ship&lt;/code&gt; subroutine that will recursively turn the ship 90¬∞ at a time, then go to the next instruction.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;Keys in hashes are strings by default, so you will notice we only put quotes around the values.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{...}&lt;/code&gt; is the anonymous &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt; constructor, so it can be used to create a nested hash. You will notice we don‚Äôt use it for the outer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt;; the reason for this is the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%&lt;/code&gt; sigil already denotes that the right-hand-side of the expression is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt;, so it is redundant. In fact, the parentheses are unnecessary as well, but they make it more readable.&lt;/li&gt;
  &lt;li&gt;Whenever we encounter an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt; it just means ‚Äúgo in the direction we are already facing.‚Äù Rather than have a special &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;when&lt;/code&gt; block for it, we just replace it with the direction we are already facing.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You might have seen me do something like this in the past:&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; my $y = gather {
     given $y {
         when * { take &amp;lt;value&amp;gt; }
     }
 }.head;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;This is because I am used to the Scala paradigm of something like this:&lt;/p&gt;

    &lt;div class=&quot;language-scala highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;The problem is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gather/take&lt;/code&gt; returns a list when I just need one value (hence the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.head&lt;/code&gt;). Well, it turns out that there is a subroutine called &lt;a href=&quot;https://docs.raku.org/routine/do&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt;&lt;/a&gt; that can prefix any &lt;a href=&quot;https://docs.raku.org/type/Supply&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Supply&lt;/code&gt;&lt;/a&gt;, which allows the values in the block to be returned/assigned to a variable rather than having to use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gather/take&lt;/code&gt; trick. It‚Äôs not the prettiest, but it works!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;After all that, it turns out that the instructions had come with interpretation instructions printed on the back. ü§¶üèª Almost all instructions refer to the manipulation of some waypoint relative to the ship. Here is the &lt;em&gt;real&lt;/em&gt; interpretation:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Action &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; means to move the waypoint north by the given value.&lt;/li&gt;
  &lt;li&gt;Action &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;S&lt;/code&gt; means to move the waypoint south by the given value.&lt;/li&gt;
  &lt;li&gt;Action &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;E&lt;/code&gt; means to move the waypoint east by the given value.&lt;/li&gt;
  &lt;li&gt;Action &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;W&lt;/code&gt; means to move the waypoint west by the given value.&lt;/li&gt;
  &lt;li&gt;Action &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;L&lt;/code&gt; means to rotate the waypoint around the ship left (counter-clockwise) the given number of degrees.&lt;/li&gt;
  &lt;li&gt;Action &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;R&lt;/code&gt; means to rotate the waypoint around the ship right (clockwise) the given number of degrees.&lt;/li&gt;
  &lt;li&gt;Action &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt; means to move forward to the waypoint a number of times equal to the given value.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If we start with a waypoint 1 unit north and 10 units east, what is our final Manhattan distance from our starting position?&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;For brevity on this one, since the two solutions do not overlap, I did not copy the part one code from above. If you would like to see it, see the link below.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/12/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1 code here
# ...

sub rotate-waypoint(@waypoint, $direction, $degrees) {
    if $degrees == 0 {
        @waypoint;
    } else {
        my ($i, $j) = @waypoint;
        my $new-degrees = $degrees - 90;
        given $direction {
            when 'L' { rotate-waypoint((-$j, $i), $direction, $new-degrees) } # [1]
            when 'R' { rotate-waypoint(($j, -$i), $direction, $new-degrees) }
        }
    }
}

sub traverse-part2(
    @directions,
    $pointer = 0,
    @current-position = (0, 0),
    @waypoint = (-1, 10)        # [2]
) {
    if $pointer == @directions.elems {
        @current-position.map(*.abs).sum;
    } else {
        my ($waypoint-i, $waypoint-j) = @waypoint;
        my $new-pointer = $pointer + 1;
        given @directions[$pointer] {
            # Waypoint translation directions
            when /(N|E|S|W)(&amp;lt;digit&amp;gt;)/ {
                my @new-waypoint = do given $/[0].Str {
                    when 'N' { ($waypoint-i - $/[1].Int, $waypoint-j) }
                    when 'E' { ($waypoint-i, $waypoint-j + $/[1].Int) }
                    when 'S' { ($waypoint-i + $/[1].Int, $waypoint-j) }
                    when 'W' { ($waypoint-i, $waypoint-j - $/[1].Int) }
                };
                traverse-part2(
                    @directions,
                    $new-pointer,
                    @current-position,
                    @new-waypoint
                );
            }
            # Waypoint rotation directions
            when /(L|R)(&amp;lt;digit&amp;gt;+)/ {
                traverse-part2(
                    @directions,
                    $new-pointer,
                    @current-position,
                    rotate-waypoint(@waypoint, $/[0].Str, $/[1].Int)
                );
            }
            # Ship-moving direction
            when /F(&amp;lt;digit&amp;gt;+)/ {
                my $number-of-moves = $/[0].Int;
                my ($i, $j) = @current-position;
                my $new-i = $i + ($number-of-moves * $waypoint-i);
                my $new-j = $j + ($number-of-moves * $waypoint-j);
                traverse-part2(
                    @directions,
                    $new-pointer,
                    ($new-i, $new-j),
                    @waypoint
                );
            }
        }
    }
}

sub MAIN($file, Bool :$p2 = False) {
    my @directions = $file.IO.lines;
    say $p2 ?? traverse-part2(@directions) !! traverse-part1(@directions);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
1186

# Part 2
$ raku main.raku --p2 input.txt
47806
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;The logic here is familiar, but just different enough to warrant its own subroutine. The only editing from the original function was to rename &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traverse&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traverse-part1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Basically, instead of storing our current direction, we store our waypoint position. When a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N|E|S|W&lt;/code&gt; instruction comes in, we move it accordingly. When a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;L|R&lt;/code&gt; instruction comes in, we use a little &lt;a href=&quot;https://calcworkshop.com/transformations/rotation-rules/&quot;&gt;middle school algebra&lt;/a&gt; to rotate the waypoint (via the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rotate-waypoint&lt;/code&gt; subroutine). And finally, when an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt; instruction comes in, we move towards the way point &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; times, where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; is the value supplied with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt; instruction.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;We were able to exploit the fact that all of our degrees were increments of 90. When we rotate the point &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(x, y)&lt;/code&gt; point counter clockwise it becomes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(-y, x)&lt;/code&gt;, and, when we rotate the same point clockwise it becomes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(y, -x)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Since we are treating the grid as a grid from the top left and growing downward, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(-1, 10)&lt;/code&gt; indicates 1 unit north and 10 units east.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;This was a fun little weekend exercise. Almost halfway to the end; see y‚Äôall tomorrow!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Today was the first day where I didn‚Äôt use the same code for parts one and two ‚Äì they were just too different! Other than that, this is a classic recursive solution with a hint of middle school algebra.</summary></entry><entry><title type="html">Advent of Code: Day 11</title><link href="http://localhost:4000/blog/advent-of-code-day-11/" rel="alternate" type="text/html" title="Advent of Code: Day 11" /><published>2020-12-11T00:00:00-06:00</published><updated>2020-12-11T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-11</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-11/">&lt;p&gt;I am giving myself half credit for today; the solution I came up with &lt;em&gt;is&lt;/em&gt; in Raku, but it is an iterative solution. Additionally, this solution is &lt;em&gt;slow&lt;/em&gt;. In fact, it was so slow that in between runs I was able to write a &lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/11/python/main.py&quot;&gt;Python solution&lt;/a&gt; (with the same logic) that ran much faster.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;We finally landed, and the last leg of our journey is via ferry, and we are all spilling into the waiting area right now. We are trying to find the best place to sit, so we make a quick sketch of the seat map in the waiting area (our input). Here is an example:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;L.LL.LL.LL
LLLLLLL.LL
L.L.L..L..
LLLL.LL.LL
L.LL.LL.LL
L.LLLLL.LL
..L.L.....
LLLLLLLLLL
L.LLLLLL.L
L.LLLLL.LL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Each position is either floor (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.&lt;/code&gt;), an empty seat (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;L&lt;/code&gt;) or an occupied seat (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;We are apparently traveling with a bunch of psychopaths who adhere to the following rules when finding a seat. For these rules the term ‚Äúneighbor‚Äù is used to describe any of the eight seats (vertically, horizontally, and diagonally) immediately adjacent to the target chair.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If the seat is empty and zero neighbors are occupied, the seat becomes occupied&lt;/li&gt;
  &lt;li&gt;If the seat is occupied and four or more neighbors are occupied, the seat becomes empty&lt;/li&gt;
  &lt;li&gt;Otherwise, the seat stays the same.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The interesting thing about the layout is that (following the above rules) it will &lt;em&gt;eventually&lt;/em&gt; reach a steady state. How many seats are occupied when it reaches steady state?&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/11/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum SeatState &amp;lt;Occupied Empty Floor&amp;gt;; # [1]

sub find-equilibrium(@state) {
    my ($max-row, $max-col) = @state.elems, @state[0].elems;
    my @directions = (
        (-1, 0), # N
        (-1, 1), # NE
        (0, 1),  # E
        (1, 1),  # SE
        (1, 0),  # S
        (1, -1), # SW
        (0, -1), # W
        (-1, -1) # NW
    );

    sub occupied-neighbors(@seat-map, $row, $col) {
        sub neighbor(@direction) {
            my ($new-row, $new-col) = $row, $col;
            loop {
                $new-row += @direction[0];
                $new-col += @direction[1];
                if ($new-row &amp;lt; 0 || $new-row &amp;gt;= $max-row || $new-col &amp;lt; 0 || $new-col &amp;gt;= $max-col) {
                    return 'Out of Bounds';
                } else {
                    return @seat-map[$new-row][$new-col]; # [2]
                }
            }
        }
        @directions.map(&amp;amp;neighbor).grep(* eq Occupied).elems;
    }

    my @old-state;
    while @old-state ne @state {
        @old-state = @state;
        @state = ();
        for ^$max-row -&amp;gt; $row {
            my @new-row;
            for ^$max-col -&amp;gt; $col {
                my $current-seat = @old-state[$row][$col];
                my $occupied-neighbors = occupied-neighbors(@old-state, $row, $col);
                if $current-seat eq Empty &amp;amp;&amp;amp; $occupied-neighbors == 0 {
                    @new-row.push(Occupied);
                } elsif $current-seat eq Occupied &amp;amp;&amp;amp; $occupied-neighbors &amp;gt;= 4 {
                    @new-row.push(Empty);
                } else {
                    @new-row.push($current-seat);
                }
            }
            @state.push(@new-row);
        }
    }
    @old-state[*;*].grep(* eq Occupied).elems; # [3][4]
}


sub MAIN($file) {
    my @seats = $file.IO.lines.map(-&amp;gt; $line {
        $line.comb.map(-&amp;gt; $char {
            given $char {
                when '#' { Occupied }
                when 'L' { Empty }
                when '.' { Floor }
            }
        })
    });
    say find-equilibrium(@seats);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
2152
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;The logic here is basically as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;First, make a 2D array of the input, where each cell is a valid &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SeatState&lt;/code&gt; (no use passing those cryptic characters around) and pass that to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find-equilibrium&lt;/code&gt; subroutine.&lt;/li&gt;
  &lt;li&gt;In the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find-equilibrium&lt;/code&gt; subroutine, we basically iterate until &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@old-state&lt;/code&gt; equals &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@state&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;For each cell we find count the occupied neighbors and the apply the rules (by comparing to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@old-state&lt;/code&gt;):
    &lt;ul&gt;
      &lt;li&gt;If the current seat is&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Empty&lt;/code&gt; and the neighbors areall &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Empty&lt;/code&gt;, make it &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Occupied&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;If the current seat is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Occupied&lt;/code&gt; and four or more neighbors are &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Occupied&lt;/code&gt;, make it &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Empty&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Otherwise, leave it alone.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Finally, we count up the occupied cells.&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;I just used an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;enum&lt;/code&gt; for clarity when reading this; it makes it a lot easier to understand than something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if $seat eq '#'&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;This is one of the few times you will see me use an explicit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; in Raku (especially functional Raku). In general, the last statement evaluated in the block is the return value. But, since we have an infinite &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loop&lt;/code&gt;, we have to add the explicit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; statements here.&lt;/li&gt;
  &lt;li&gt;This is the Raku way to &lt;a href=&quot;https://docs.raku.org/language/subscripts#index-entry-flattening_&quot;&gt;flatten a 2D list&lt;/a&gt;. If it were a 3D list, we would do &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@list[*;*;*]&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt; is only used for numbers in Raku; everything else should us &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eq&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ne&lt;/code&gt;, etc.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;We realize that the pattern the pattern the waiting passengers is following is not actually as simple as we made it.&lt;/p&gt;

&lt;p&gt;They are actually looking for the &lt;em&gt;first seat they can see&lt;/em&gt; in all eight directions rather than just the eight adjacent chairs. For example, the empty chair below would see eight occupied seats:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.......#.
...#.....
.#.......
.........
..#L....#
....#....
.........
#........
...#.....
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Additionally, people seem to be more tolerant than expected and will only vacate their seat if &lt;strong&gt;five or more&lt;/strong&gt; occupied seats are visible. How many seats are occupied at steady state now?&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/11/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;enum SeatState &amp;lt;Occupied Empty Floor&amp;gt;;

sub find-equilibrium(@state, Int $min-occupied, Bool $only-immediate) {
    my ($max-row, $max-col) = @state.elems, @state[0].elems;
    my @directions = (
        (-1, 0), # N
        (-1, 1), # NE
        (0, 1),  # E
        (1, 1),  # SE
        (1, 0),  # S
        (1, -1), # SW
        (0, -1), # W
        (-1, -1) # NW
    );

    sub occupied-neighbors(@seat-map, $row, $col) {
        sub neighbor(@direction) {
            my ($new-row, $new-col) = $row, $col;
            my $valid-seats = Set[SeatState].new(Occupied, Empty);
            loop {
                $new-row += @direction[0];
                $new-col += @direction[1];
                if ($new-row &amp;lt; 0 || $new-row &amp;gt;= $max-row || $new-col &amp;lt; 0 || $new-col &amp;gt;= $max-col) {
                    return 'Out of Bounds';
                } else {
                    my $seat = @seat-map[$new-row][$new-col];
                    if $seat ‚àà $valid-seats || $only-immediate {
                        return $seat;
                    }
                }
            }
        }
        @directions.map(&amp;amp;neighbor).grep(* eq Occupied).elems;
    }

    my @old-state;
    while @old-state ne @state {
        @old-state = @state;
        @state = ();
        for ^$max-row -&amp;gt; $row {
            my @new-row;
            for ^$max-col -&amp;gt; $col {
                my $current-seat = @old-state[$row][$col];
                my $occupied-neighbors = occupied-neighbors(@old-state, $row, $col);
                if $current-seat eq Empty &amp;amp;&amp;amp; $occupied-neighbors == 0 {
                    @new-row.push(Occupied);
                } elsif $current-seat eq Occupied &amp;amp;&amp;amp; $occupied-neighbors &amp;gt;= $min-occupied {
                    @new-row.push(Empty);
                } else {
                    @new-row.push($current-seat);
                }
            }
            @state.push(@new-row);
        }
    }
    @old-state[*;*].grep(* eq Occupied).elems;
}


sub MAIN($file, Bool :$p2 = False) {
    my @seats = $file.IO.lines.map(-&amp;gt; $line {
        $line.comb.map(-&amp;gt; $char {
            given $char {
                when '#' { Occupied }
                when 'L' { Empty }
                when '.' { Floor }
            }
        })
    });
    my $min-occupied = $p2 ?? 5 !! 4;
    my $only-immediate = !$p2;
    say find-equilibrium(@seats, $min-occupied, $only-immediate);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
2152

# Part 2
$ raku main.raku --p2 input.txt
1937
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;This code looks almost the same. Here are the &lt;em&gt;only&lt;/em&gt; changes to the code:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find-equilibrium&lt;/code&gt; now takes two additional parameters:
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$min-occupied&lt;/code&gt;: How many nearby seats need to be occupied for someone to vacate theirs.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$only-immediate&lt;/code&gt;: Whether or not we should only look at the eight immediate neighbors.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;elsif&lt;/code&gt; block has been changed to utilize &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$min-occupied&lt;/code&gt; instead of being hard-coded to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; subroutine will define &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$min-occupied&lt;/code&gt; as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5&lt;/code&gt; if it‚Äôs part two, otherwise &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; subroutine will define &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$only-immediate&lt;/code&gt; as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt; if it‚Äôs part two, otherwise &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That‚Äôs it!&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;p&gt;Nothing for part two!&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;This solution is just begging to be done iteratively, so I can‚Äôt blame myself too much for naturally leaning towards an iterative approach. With that being said, I would love to see some functional approaches to this just to better my understanding of the functional mindset.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">I am giving myself half credit for today; the solution I came up with is in Raku, but it is an iterative solution. Additionally, this solution is slow. In fact, it was so slow that in between runs I was able to write a Python solution (with the same logic) that ran much faster.</summary></entry><entry><title type="html">Advent of Code: Day 10</title><link href="http://localhost:4000/blog/advent-of-code-day-10/" rel="alternate" type="text/html" title="Advent of Code: Day 10" /><published>2020-12-10T00:00:00-06:00</published><updated>2020-12-10T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-10</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-10/">&lt;p&gt;Part two today &lt;em&gt;almost&lt;/em&gt; forced me to use an iterative approach that would require a mutable array. However, I stumbled on a great feature of Raku that let me do it recursively without mutability. See below for details!&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;We are trying to plug our phone into the seat-back plug, but the problem is it puts out the wrong &lt;em&gt;joltage&lt;/em&gt;. We have a handful of adaptors labeled by their output joltage (our input), and our device is rated for 3 jolts above the maximum adaptor joltage. Each adaptor can be plugged into an adaptor 1-, 2-, or 3-jolts below it (i.e., a 4-jolt adaptor can plug into a 1-, 2- or 3-jolt plug).&lt;/p&gt;

&lt;p&gt;We are bored on this flight, so, treating the seat-back outlet as zero jolts, we want to find a solution that uses &lt;em&gt;every&lt;/em&gt; adaptor we own. Once we have found the right sequence, we want to multiply the number of 1-jolt differences by the number of 3-jolt differences.&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/10/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub find-differences(@joltage, $pointer = 0, @differences = ()) {
    if $pointer == @joltage.elems - 1 {
        @differences;
    } else {
        my $a = @joltage[$pointer];
        my $b = @joltage[$pointer + 1];
        find-differences(@joltage, $pointer + 1, (|@differences, $b - $a));
    }
}

sub MAIN($file) {
    my @adaptors = $file.IO.lines.map(*.Int).sort;
    my $device-joltage = @adaptors.max + 3;
    my @joltage-list = (0, |@adaptors, $device-joltage); # [1]
    my @differences = find-differences(@joltage-list);
    say @differences.grep(* == 1).elems * @differences.grep(* == 3).elems;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
2176
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;The logic laid out in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; is pretty clear.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We pull out all of our adaptors and sort them by output joltage&lt;/li&gt;
  &lt;li&gt;We find out device voltage (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@adaptors.max + 3&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;We make our final joltage list including the outlet (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;) and our device&lt;/li&gt;
  &lt;li&gt;We find all the differences between each adaptor&lt;/li&gt;
  &lt;li&gt;We multiply the 1-joltage differences by the 3-joltage differences&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;I‚Äôve used this before, but I wanted to call it out as it is used in a few places in this solution. This is called a &lt;a href=&quot;https://docs.raku.org/type/Slip&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Slip&lt;/code&gt;&lt;/a&gt;, which basically unpacks a list into the outer list. So this is a way of prepending and appending items to a list at the same time.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;Now that we have found the one solution that uses all adaptors, we want to find &lt;em&gt;all&lt;/em&gt; possible solutions that will connect our device to the plug. Looking at our adaptors we realize there must be more than a &lt;strong&gt;trillion&lt;/strong&gt; ways to arrange them, so we have to be smart about how we approach it.&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/10/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use experimental :cached;

sub find-differences(@joltage-list, $pointer = 0, @differences = ()) {
    if $pointer == @joltage-list.elems - 1 {
        @differences;
    } else {
        my $a = @joltage-list[$pointer];
        my $b = @joltage-list[$pointer + 1];
        find-differences(@joltage-list, $pointer + 1, (|@differences, $b - $a));
    }
}

sub find-paths($current-joltage, @joltage-list) is cached {   # [1]
    given $current-joltage {
        when * == @joltage-list.max { 1 }
        when * ‚àâ @joltage-list      { 0 }                     # [2][3]
        default {
            find-paths($current-joltage + 1, @joltage-list) +
            find-paths($current-joltage + 2, @joltage-list) + # [4]
            find-paths($current-joltage + 3, @joltage-list);
        }
    }
}

sub MAIN($file, Bool :$p2 = False) {
    my @adaptors = $file.IO.lines.map(*.Int).sort;
    my $device-joltage = @adaptors.max + 3;
    my @joltage-list = (0, |@adaptors, $device-joltage);
    if $p2 {
        say find-paths(0, @joltage-list);
    } else {
        my @differences = find-differences(@joltage-list);
        say @differences.grep(* == 1).elems * @differences.grep(* == 3).elems;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
2176

# Part 2
$ raku main.raku --p2 input.txt
18512297918464
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;There is a lot of fluff going on from part one that we can ignore. We generate the same &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@joltage-list&lt;/code&gt; and pass it to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find-paths&lt;/code&gt; starting at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;joltage = 0&lt;/code&gt;. This subroutine does the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;If we have hit the max joltage (device joltage) mark this as a valid path (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;If the joltage we are currently on is not in the set of adaptors, mark it as invalid (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Otherwise, recursively find the valid paths for any adaptors that could plug into this one (i.e. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n+1&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n+2&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n+3&lt;/code&gt;) and add them up&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This looks pretty brute-force, right? Well, that is where the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is cached&lt;/code&gt; trait comes in. See #1 below for details!&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;Coming from a Python background, I am familiar with &lt;a href=&quot;https://docs.python.org/3/library/functools.html#functools.cache&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;functools.cache&lt;/code&gt;&lt;/a&gt;, a decorator that basically builds a dictionary of input to output such that expensive functions are only calculated once. Basically, the first call would compute the value and store it in the cache and any subsequent calls to that functions with the same input would use the cached value instead; this optimization is called &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoization&lt;/a&gt;. In Raku, this is an &lt;a href=&quot;https://docs.raku.org/language/experimental#cached&quot;&gt;experimental trait&lt;/a&gt; called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cached&lt;/code&gt; which can be applied to subroutines to achieve the same memoization goal. Basically, the reason this is not a brute-force approach is because we will only compute &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find-paths&lt;/code&gt; once for each input rather than the traditional re-computing that can happen in recursive functions.&lt;/li&gt;
  &lt;li&gt;This is the first time using this operator, so I want to call it out: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;‚àâ&lt;/code&gt; is the ‚Äúelement not part of set‚Äù operator.&lt;/li&gt;
  &lt;li&gt;This function could be optimized by &lt;em&gt;only&lt;/em&gt; looking at joltages in the input list, but instead we just look at everything from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0..N&lt;/code&gt;. If it is not in the input list, we just mark it as an invalid path.&lt;/li&gt;
  &lt;li&gt;Because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find-paths($current-joltage + 1, @joltage-list)&lt;/code&gt; will recursively call more &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find-paths&lt;/code&gt; functions, this line uses the cache, so the only operation really happening here is the addition.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;A lot of my solutions for the Advent of Code so far have been recursive (and relatively slow). I am glad I found out about the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is cached&lt;/code&gt; trait, and I am looking forward to applying it to more solutions in the future!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Part two today almost forced me to use an iterative approach that would require a mutable array. However, I stumbled on a great feature of Raku that let me do it recursively without mutability. See below for details!</summary></entry><entry><title type="html">Advent of Code: Day 9</title><link href="http://localhost:4000/blog/advent-of-code-day-09/" rel="alternate" type="text/html" title="Advent of Code: Day 9" /><published>2020-12-09T00:00:00-06:00</published><updated>2020-12-09T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-09</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-09/">&lt;p&gt;Today we have a classic &lt;a href=&quot;https://www.geeksforgeeks.org/window-sliding-technique/&quot;&gt;sliding window&lt;/a&gt; problem. But, instead of the traditional iterative approach, we take a recursive approach.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;After helping our seatmate fix his Game Boy &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-08/&quot;&gt;yesterday&lt;/a&gt;, we find ourselves bored on the plane. Why not pass the time with a little mid-air hacking?&lt;/p&gt;

&lt;p&gt;We hook our computer up to the seat-back entertainment center, but it is protected by the e&lt;strong&gt;X&lt;/strong&gt;change-&lt;strong&gt;M&lt;/strong&gt;asking &lt;strong&gt;A&lt;/strong&gt;ddition &lt;strong&gt;S&lt;/strong&gt;ystem (XMAS), which is a cipher with a documented weakness.&lt;/p&gt;

&lt;p&gt;XMAS starts by sending us 25 numbers (a ‚Äúpreamble‚Äù). The 26th number should be the sum of two numbers in the preamble. The 27th number should be the sum of its previous 25 numbers, and so on. Here is an example with a preamble of size 5:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;35
20
15
25
47
40
62
55
65
95
102
117
150
182
127
219
299
277
309
576
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can see how the pattern works here:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;40 is the sum of 15 and 25&lt;/li&gt;
  &lt;li&gt;62 is the sum of 15 and 47&lt;/li&gt;
  &lt;li&gt;55 is the sum of 15 and 40&lt;/li&gt;
  &lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The first step in attacking the weakness of the cipher is that exactly one number doesn‚Äôt follow the pattern. In this case 127 is not the sum of any numbers in the previous 5 (95, 102, 117, 150, 182). Our job is to find the invalid number in the XMAS cipher.&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/09/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub find-invalid(@list, $window-start = 0, $window-size = 25) {                               # [1]
    my $window-end = $window-start + $window-size - 1;
    my $target-number = @list[$window-end + 1];
    my @preamble-combinations = @list[$window-start..$window-end].combinations(2).map(*.sum); # [2]
    if $target-number ‚àà @preamble-combinations {
        find-invalid(@list, $window-start + 1);
    } else {
        $target-number;
    }
}

sub MAIN($file) {
    say find-invalid($file.IO.lines.map(*.Int));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
31161678
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;First, we pull all of our numbers into a list and turn them into integers. Once we‚Äôve done that, we pass the list to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find-invalid&lt;/code&gt;, which will find the sliding window and target value we are looking for (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@list[0..24]&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@list[25]&lt;/code&gt; in the first iteration). We then find all possible combinations in that 25-item list (via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.combinations(2)&lt;/code&gt;) and sum each pair (vis &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.map(*.sum&lt;/code&gt;). If the target &lt;em&gt;is&lt;/em&gt; in the list of sums, it is valid, and we go to the next sliding window. If it is &lt;em&gt;not&lt;/em&gt;, we found our invalid term and return.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;I added a parameter for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$window-size&lt;/code&gt; here because I had a feeling it would change in part two. It did not, but I left it in here to give an idea of my thought process.&lt;/li&gt;
  &lt;li&gt;I am trying to get more consistent in using dot operators (like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.sum&lt;/code&gt;) rather than mixing paradigms. With that being said, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.map([+] *)&lt;/code&gt; didn‚Äôt work here to begin with; it wanted me to do something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.map(-&amp;gt; @pair { [+] @pair })&lt;/code&gt;. I think it was interpreting the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; as a multiplication operator instead of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Whatever&lt;/code&gt; star, so it was getting confused. All the more reason to use dot operators, I guess!&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;The second step of finding the weakness relies on the invalid number found above.&lt;/p&gt;

&lt;p&gt;We need to find a contiguous set of numbers (size two or greater) in the input that add up to our invalid input. Once we have found that contiguous range, we need to add the minimum and maximum numbers in the range; that is our encryption weakness.&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/09/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub find-invalid(@list, $window-start = 0, $window-size = 25) {
    my $window-end = $window-start + $window-size - 1;
    my $target-number = @list[$window-end + 1];
    my @preamble-combinations = @list[$window-start..$window-end].combinations(2).map(*.sum);
    if $target-number ‚àà @preamble-combinations {
        find-invalid(@list, $window-start + 1);
    } else {
        $target-number;
    }
}

sub find-contiguous-range(@list, $target, $start = 0, $end = 1) {
    my @range = @list[$start..$end];
    given @range.sum {
        when * &amp;lt; $target  { find-contiguous-range(@list, $target, $start, $end + 1) }       # [1][2]
        when * == $target { @range }
        when * &amp;gt; $target  { find-contiguous-range(@list, $target, $start + 1, $start + 2) }
    }
}

sub MAIN($file, Bool :$p2 = False) {
    my @input = $file.IO.lines.map(*.Int);
    my $invalid = find-invalid(@input);
    if $p2 {
        my @contiguous-range = find-contiguous-range(@input.reverse, $invalid); # [3]
        say @contiguous-range.min + @contiguous-range.max;
    } else {
        say $invalid;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
31161678

# Part 2
$ raku main.raku --p2 input.txt
5453868
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;find-invalid&lt;/code&gt; subroutine stays the same, but we now assign the output of it to a variable. If the user is running part one, we print and exit. If the user is running part two, we recursively search the list for a range that adds up to the invalid number. We use the following criteria:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Start with window size two&lt;/li&gt;
  &lt;li&gt;If the sum of the window is less than the target, increase it by one and try again&lt;/li&gt;
  &lt;li&gt;If the sum of the window is the target, return the range&lt;/li&gt;
  &lt;li&gt;If the sum of the window is greater than the target, move the start of the window by one, resize to a window of size two and start again&lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;This is an annoying trap that I almost fell into: since Raku treats &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;foo&amp;gt;&lt;/code&gt; the same as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;('foo')&lt;/code&gt;, I was unable to just write &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;when &amp;lt; $target&lt;/code&gt;. It‚Äôs annoying to me because I &lt;em&gt;can&lt;/em&gt; write &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;when $target&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;when * == $target&lt;/code&gt;, but I left all three with the same pattern for consistency.&lt;/li&gt;
  &lt;li&gt;Either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$_&lt;/code&gt; can be used here. Since I am using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; in other places, I used it for consistency.&lt;/li&gt;
  &lt;li&gt;We exploit the fact that our input is &lt;em&gt;kind of&lt;/em&gt; in order. When I say &lt;em&gt;kind of&lt;/em&gt; I mean all the two-digit numbers are before all the three-digit numbers, etc. Because our invalid number is so large, I started our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contiguous-range&lt;/code&gt; check from the end of the list. This paid off, as the solution did not even finish when starting from the beginning, but finished fairly quickly starting from the end.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I‚Äôm realizing how &lt;em&gt;slow&lt;/em&gt; Raku is (both to write and to run). It‚Äôs disappointing because Perl (Raku‚Äôs older brother) is slow to write, but at least it is fast to run (as far as interpreted languages go). I guess there is a reason &lt;a href=&quot;https://github.com/github/linguist/pull/5104#issuecomment-739561686&quot;&gt;fewer than 200 people&lt;/a&gt; are using it on GitHub. Regardless, I am committed to finishing the challenge I set forward for myself (barring Day 7 *shakes fist*). See y‚Äôall for day 10!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Today we have a classic sliding window problem. But, instead of the traditional iterative approach, we take a recursive approach.</summary></entry><entry><title type="html">Advent of Code: Day 8</title><link href="http://localhost:4000/blog/advent-of-code-day-08/" rel="alternate" type="text/html" title="Advent of Code: Day 8" /><published>2020-12-08T00:00:00-06:00</published><updated>2020-12-08T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-08</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-08/">&lt;p&gt;Today tripped me up a bit in part 2 due to my lack of understanding around copying objects in Raku. Regardless, we made it through and are now over 30% of the way to the end!&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;We‚Äôre still traveling to our destination (see the past few blogs of the &lt;a href=&quot;https://www.adventofcode.com&quot;&gt;Advent of Code&lt;/a&gt; itself for more backstory).&lt;/p&gt;

&lt;p&gt;We are on another flight, and the kid in the seat next to us is having an issue with his Game Boy. We are able to isolate the boot code, and it looks like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nop +0
acc +1
jmp +4
acc +3
jmp -3
acc -99
acc +1
jmp -4
acc +6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Where each instruction means the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nop&lt;/code&gt;: No operation, move to the next entry&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmp&lt;/code&gt;: Jump to the entry specified by the number (+1 means next entry, -1 means previous entry, etc.)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;acc&lt;/code&gt;: Increment an accumulator the specified amount of times, then go to the next entry&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The example instructions, as well as our input, create an infinite loop. Our task is to find the value of the accumulator immediately before any instruction is executed a second time.&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/08/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub accumulate(@instructions is copy, $pointer = 0, $accumulator = 0) { # [1]
    if @instructions[$pointer]&amp;lt;visited&amp;gt; {
        $accumulator;
    } else {
        @instructions[$pointer]&amp;lt;visited&amp;gt; = True;
        given @instructions[$pointer]&amp;lt;operation&amp;gt; {
            when 'acc' {
                accumulate(
                    @instructions,
                    $pointer + 1,
                    $accumulator + @instructions[$pointer]&amp;lt;value&amp;gt;
                );
            }
            when 'jmp' {
                accumulate(
                    @instructions,
                    $pointer + @instructions[$pointer]&amp;lt;value&amp;gt;,
                    $accumulator
                );
            }
            when 'nop' {
                accumulate(@instructions, $pointer + 1, $accumulator);
            }
        }
    }
}


sub MAIN($file) {
    my @cells = $file.IO.lines.map(-&amp;gt; $line {
        my ($operation, $value) = $line.split(' ');
        { :$operation, value =&amp;gt; $value.Int, :!visited } # [2]
    });
    say accumulate(@cells);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
1600
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;The logic here is fairly simple. First, we split our input into a list of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt; objects that look like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{ operation =&amp;gt; 'jmp|acc|nop', value =&amp;gt; &amp;lt;value&amp;gt;, visited =&amp;gt; False }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We then recursively traverse this list of cells until we hit one that is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;visited =&amp;gt; True&lt;/code&gt;, and we return the accumulator at that point.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;We mark the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@instructions&lt;/code&gt; variable as a copy so that we can manipulate it in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;accumulate&lt;/code&gt; subroutine without affecting the outer scope.&lt;/li&gt;
  &lt;li&gt;We use two shorthands on this line. The first being &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:$operation&lt;/code&gt;, which is shorthand for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;operation =&amp;gt; $operation&lt;/code&gt;, and the second being &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:!visited&lt;/code&gt;, which is shorthand for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;visited =&amp;gt; False&lt;/code&gt;. I don‚Äôt really like mixing the paradigms, but IntelliJ was complaining about it, so what are you gonna do? ü§∑üèª‚Äç‚ôÇÔ∏è&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;Now that we have a program to interpret the boot code, we find that there is a bug in the boot code itself. Either a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nop&lt;/code&gt; was switched for a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jmp&lt;/code&gt; or vice versa, in exactly one place in the code. Swapping the right code back to its original form will allow the boot code to terminate rather than running forever.&lt;/p&gt;

&lt;p&gt;We need to find the value of the accumulator in the terminal solution.&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/08/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub accumulate(@instructions is copy, $pointer = 0, $accumulator = 0, $part-two = False) {
    if $part-two &amp;amp;&amp;amp; $pointer == @instructions.elems {
        ($accumulator, 'Terminal');
    } elsif @instructions[$pointer]&amp;lt;visited&amp;gt; {
        ($accumulator, 'Infinite');
    } else {
        @instructions[$pointer]&amp;lt;visited&amp;gt; = True;
        given @instructions[$pointer]&amp;lt;operation&amp;gt; {
            when 'acc' {
                accumulate(
                    @instructions,
                    $pointer + 1,
                    $accumulator + @instructions[$pointer]&amp;lt;value&amp;gt;,
                    $part-two
                );
            }
            when 'jmp' {
                accumulate(
                    @instructions,
                    $pointer + @instructions[$pointer]&amp;lt;value&amp;gt;,
                    $accumulator,
                    $part-two
                );
            }
            when 'nop' {
                accumulate(@instructions, $pointer + 1, $accumulator, $part-two);
            }
        }
    }
}


sub MAIN($file, Bool :$p2 = False) {
    my @cells = $file.IO.lines.map(-&amp;gt; $line {
        my ($operation, $value) = $line.split(' ');
        { :$operation, value =&amp;gt; $value.Int, :!visited }
    });
    if $p2 {
        my @fixed-instructions = gather {
            for @cells.kv -&amp;gt; $index, %cell {
                given %cell&amp;lt;operation&amp;gt;.Str {
                    when /^[nop|jmp]$/ {                                               # [1]
                        my @cells-copy = @cells.deepmap(-&amp;gt; $entry is copy { $entry }); # [2]
                        my %cell-copy = %cell.deepmap(-&amp;gt; $entry is copy { $entry });
                        when 'nop' {
                            %cell-copy&amp;lt;operation&amp;gt; = 'jmp';
                            @cells-copy[$index] = %cell-copy;
                            take @cells-copy;
                        }
                        when 'jmp' {
                            %cell-copy&amp;lt;operation&amp;gt; = 'nop';
                            @cells-copy[$index] = %cell-copy;
                            take @cells-copy;
                        }
                    }
                }
            }
        };
        say @fixed-instructions
            .map(&amp;amp;accumulate.assuming(*, 0, 0, $p2))
            .grep(-&amp;gt; @pair { @pair[1] eq 'Terminal' })
            .head  # Gives us the first item in the above list
            .head; # Gives us the number in the pair returned from `accumulate`
    } else {
        say accumulate(@cells).head;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
1600

# Part 2
$ raku main.raku --p2 input.txt
1543
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;The logic here is fairly straightforward (albeit brute force) as well. Basically, we find all combinations of our input with a single code point change (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@fixed-instructions&lt;/code&gt;), find &lt;em&gt;all&lt;/em&gt; solutions to those codes (infinite and terminal), filter down to the terminal solution and print the output.&lt;/p&gt;

&lt;p&gt;The hard part here was copying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@cells&lt;/code&gt; multiple times into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@fixed-instructions&lt;/code&gt;. I ran into an issue where all of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@fixed-instructions&lt;/code&gt; was pointing to the same memory address, so after traversing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@fixed-instructions[0]&lt;/code&gt;, the rest of the inputs were tainted. This issue was fixed by the (awkward) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.deepmaps&lt;/code&gt;. See #2 below for additional details.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;
&lt;ol&gt;
  &lt;li&gt;Interestingly &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;when 'nop' || 'jmp'&lt;/code&gt; does not work here. I suspect it has to do with the fact that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;when&lt;/code&gt; operates &lt;a href=&quot;https://docs.raku.org/language/control#index-entry-control_flow__given-given&quot;&gt;very eagerly&lt;/a&gt; and as soon as it finds a match, it skips the rest of the lines of input. Generally that happens in a code block, but I guess it can happen in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;when&lt;/code&gt; statement itself.&lt;/li&gt;
  &lt;li&gt;I knew I needed a mutable copy of the original input here. Originally I tried &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@cells-copy = @cells&lt;/code&gt;, but that didn‚Äôt work. Eventually I stumbled upon &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.clone&lt;/code&gt;, which it seems &lt;a href=&quot;https://docs.raku.org/routine/clone&quot;&gt;&lt;em&gt;intentionally&lt;/em&gt; doesn‚Äôt work&lt;/a&gt; on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@&lt;/code&gt;- or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%&lt;/code&gt;-sigiled variables. Finally, I &lt;a href=&quot;https://stackoverflow.com/a/38585401/10696164&quot;&gt;stumbled upon&lt;/a&gt; this awkward &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.deepcopy&lt;/code&gt; syntax which is not only incredibly ugly, but also incredibly slow. For reference, part one runs in 0.48 seconds on my machine and part two runs in 28.7 seconds.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Today‚Äôs problem helped me get back on the functional Raku track after a &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-07/&quot;&gt;frustrating day 7&lt;/a&gt;. However, I am going to have to do more digging on copies of iterables in Raku, because a 60x performance decrease is not really acceptable for this kind of thing, especially when the input is relatively small (&amp;lt;1000 lines).&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Today tripped me up a bit in part 2 due to my lack of understanding around copying objects in Raku. Regardless, we made it through and are now over 30% of the way to the end!</summary></entry><entry><title type="html">Perl Weekly Challenge 90</title><link href="http://localhost:4000/blog/perl-weekly-challenge-090/" rel="alternate" type="text/html" title="Perl Weekly Challenge 90" /><published>2020-12-07T00:00:00-06:00</published><updated>2020-12-07T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-090</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-090/">&lt;p&gt;Today was a busy day with both &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-07/&quot;&gt;Advent of Code&lt;/a&gt; and the Perl Weekly Challenge. Luckily, the PWC was short and sweet this week, and a nice breather after the Advent of Code.&lt;/p&gt;

&lt;h2 id=&quot;task-1-dna-sequence&quot;&gt;Task 1: DNA Sequence&lt;/h2&gt;

&lt;p&gt;You are given DNA sequence, GTAAACCCCTTTTCATTTAGACAGATCGACTCCTTATCCATTCTCAGAGATGTGTTGCTGGTCGCCG.&lt;/p&gt;

&lt;p&gt;Write a script to print nucleotide count in the given DNA sequence. Also print the complementary sequence where Thymine (T) on one strand is always facing an adenine (A) and vice versa; guanine (G) is always facing a cytosine (C) and vice versa.&lt;/p&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-090/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset ValidDna of Str where { $_ ~~ /^^[A|T|G|C]+$$/ }

sub MAIN($dna where $dna ~~ ValidDna, Bool :rc(:$reverse-complement) = False) { # [1]
    say &quot;Input stats:\n{$dna.comb.Bag.Hash}\n&quot;;                                 # [2]

    say &quot;Complement:&quot;;
    my $translated = $dna.trans('ATGC' =&amp;gt; 'TACG');                              # [3]
    if $reverse-complement {
        say &quot;5'-{$translated.flip}-3'&quot;;
    } else {
        say &quot;3'-$translated-5'&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku GTAAACCCCTTTTCATTTAGACAGATCGACTCCTTATCCATTCTCAGAGATGTGTTGCTGGTCGCCG
Input stats:
A	14
C	18
G	13
T	22

Complement:
3'-CATTTGGGGAAAAGTAAATCTGTCTAGCTGAGGAATAGGTAAGAGTCTCTACACAACGACCAGCGGC-5'

$ raku ch-1.raku --reverse-complement GTAAACCCCTTTTCATTTAGACAGATCGACTCCTTATCCATTCTCAGAGATGTGTTGCTGGTCGCCG
Input stats:
A	14
C	18
G	13
T	22

Complement:
5'-CGGCGACCAGCAACACATCTCTGAGAATGGATAAGGAGTCGATCTGTCTAAATGAAAAGGGGTTTAC-3'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Coming from a Biochemistry background, this one is rather simple. However, the question does not take into consideration that DNA has a &lt;a href=&quot;https://en.wikipedia.org/wiki/Directionality_(molecular_biology)&quot;&gt;direction&lt;/a&gt;. Generally, if you are handed a string like this, you expect it to be read from 5‚Äô to 3‚Äô (5 prime to 3 prime). Because of the directionality, the opposite strand would be 3‚Äô to 5‚Äô.&lt;/p&gt;

&lt;p&gt;So generally, when a question asks for the complementary strand, they want the &lt;em&gt;reverse&lt;/em&gt; complement, so it is shown 5‚Äô to 3‚Äô. This question did not specify, so I wrote an answer that handles both.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;This syntax allows us to give aliases to our command line arguments. In this case, we accept either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--rc&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--reverse-complement&lt;/code&gt; and store it in a variable called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$reverse-complement&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;A &lt;a href=&quot;https://docs.raku.org/type/Bag&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bag&lt;/code&gt;&lt;/a&gt; is a weighted collection. When passed the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; produced by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.comb&lt;/code&gt;, it generates a bag with the weight of each letter. We only convert it to a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt; for pretty printing.&lt;/li&gt;
  &lt;li&gt;Raku‚Äôs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trans&lt;/code&gt; method is a single-pass method, meaning you won‚Äôt translate &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;T&lt;/code&gt; and then accidentally translate it back to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; with a second pass.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-ethiopian-multiplication&quot;&gt;Task 2: Ethiopian Multiplication&lt;/h2&gt;

&lt;p&gt;You are given two positive numbers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$A&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$B&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to demonstrate &lt;a href=&quot;https://threesixty360.wordpress.com/2009/06/09/ethiopian-multiplication/&quot;&gt;Ethiopian Multiplication&lt;/a&gt; using the given numbers.&lt;/p&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-090/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset PositiveInt of Int where { $_ ~~ Int &amp;amp;&amp;amp; $_ &amp;gt; 0 }

sub generate-pairs($a, $b) {
    sprintf(&quot;%02d, %02d&quot;, $a, $b).put;
    if $a == 1 {
        (($a, $b),);
    } else {
        (($a, $b), |generate-pairs($a div 2, $b * 2));
    }
}

sub MAIN(PositiveInt $A, PositiveInt $B) {
    say &quot;Input: A: $A, B: $B&quot;;
    say &quot;Divide A by 2 (ignoring remainders) until it is 1. Multiply B by 2 as we go:&quot;;
    my @pairs = generate-pairs($A, $B);
    say &quot;Then, wherever A is odd, we add the Bs together:&quot;;
    my @odd-bs = @pairs.grep(-&amp;gt; @pair { !(@pair[0] %% 2) }).map(-&amp;gt; @pair { @pair[1] });
    say &quot;{@odd-bs.join(' + ')} = {@odd-bs.sum}&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 14 12
Input: A=14, B=12
Divide A by 2 (ignoring remainders) until it is 1. Multiply B by 2 as we go:
14, 12
07, 24
03, 48
01, 96
Then, wherever A is odd, we add the Bs together:
24 + 48 + 96 = 168
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This is a very straightforward solution; most of the mess in the code is from the messages printed out. Basically, we generate our pairs (and print them) using recursion, then filter them down to where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$A&lt;/code&gt; is odd, and add up the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$B&lt;/code&gt;s.&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;This week was super easy, so not much to add! Jump over to my blog on &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-07/&quot;&gt;day 7 of the Advent of Code&lt;/a&gt; for something more challenging.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Today was a busy day with both Advent of Code and the Perl Weekly Challenge. Luckily, the PWC was short and sweet this week, and a nice breather after the Advent of Code.</summary></entry><entry><title type="html">Advent of Code: Day 7</title><link href="http://localhost:4000/blog/advent-of-code-day-07/" rel="alternate" type="text/html" title="Advent of Code: Day 7" /><published>2020-12-07T00:00:00-06:00</published><updated>2020-12-07T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-07</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-07/">&lt;p&gt;Well, today was our streak breaker. For the life of me, I could not get Raku to run in a timely manner. I ended up reverting to Python and using a more imperative approach. Nevertheless, I am sharing it here for anyone who cares!&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;For the past few days, we have been traveling. First we had troubles at &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-04/&quot;&gt;the airport&lt;/a&gt;, then we had trouble &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-05/&quot;&gt;finding our seat&lt;/a&gt;, and then we had issues filling out the &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-06/&quot;&gt;customs form&lt;/a&gt;. But, we have landed safely and are ready to enjoy our vacation!&lt;/p&gt;

&lt;p&gt;However, our luggage is taking a long time getting to the carousel due to recent luggage rules that have been put into effect. We are given a list of the rules that looks like the following:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;light red bags contain 1 bright white bag, 2 muted yellow bags.
dark orange bags contain 3 bright white bags, 4 muted yellow bags.
bright white bags contain 1 shiny gold bag.
muted yellow bags contain 2 shiny gold bags, 9 faded blue bags.
shiny gold bags contain 1 dark olive bag, 2 vibrant plum bags.
dark olive bags contain 3 faded blue bags, 4 dotted black bags.
vibrant plum bags contain 5 faded blue bags, 6 dotted black bags.
faded blue bags contain no other bags.
dotted black bags contain no other bags.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We have a &lt;strong&gt;shiny gold&lt;/strong&gt; bag, and we want to know how many color combinations there are for the outermost bag. With the above example, we have:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A bright white bag, which can hold our shiny gold bag directly&lt;/li&gt;
  &lt;li&gt;A muted yellow bag, which can hold our shiny gold bag directly, plus some other bags&lt;/li&gt;
  &lt;li&gt;A dark orange bag, which can hold bright white and muted yellow bags, either of which could then hold our shiny gold bag&lt;/li&gt;
  &lt;li&gt;A light red bag, which can hold bright white and muted yellow bags, either of which could then hold our shiny gold bag&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So the question is, given a much larger input file, how many outermost bags can eventually hold our shiny gold bag?&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/07/python/main.py&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;dataclasses&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataclass&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;typing&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tuple&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;


&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataclass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe_hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# [1][2]
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adjective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;contains_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;held_bags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contains_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;held_bags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        

&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataclass&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Rule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bag&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parse_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bag_desc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' contain '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Create Bag
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;adjective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag_desc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adjective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Fill in contents
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;_contents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'no other bags.'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;inner_bags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;', '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bag&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner_bags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;quantity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adjective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;inner_bag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adjective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quantity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inner_bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Turn the contents into a rule and return
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;input_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;stripped&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stripped&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'shiny'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'gold'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;can_hold_target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contains_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;can_hold_target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;can_hold_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python main.py input.txt
151
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;The logic of this one is fairly straightforward:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;For each line in the file, we turn it into a key-value pair of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bag&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rule&lt;/code&gt;, where the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bag&lt;/code&gt; contains the color of the outer bag and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rule&lt;/code&gt; contains a list of inner bags, as well as how many of them we hold.&lt;/li&gt;
  &lt;li&gt;For each outer bag we call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.contains_target&lt;/code&gt; which will recursively check if this bag will ever hold our shiny gold bag.&lt;/li&gt;
  &lt;li&gt;We tally up the outer bags that returned &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt; above.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I tried to apply this logic in Raku, but I just kept finding myself fighting the type system.&lt;/p&gt;

&lt;p&gt;First, rather than the inelegant parsing I did here, I tried to use one of Raku‚Äôs &lt;a href=&quot;https://docs.raku.org/type/Grammar&quot;&gt;grammars&lt;/a&gt;, which ended up being clunky, and it took me several hours just to get the data to parse.&lt;/p&gt;

&lt;p&gt;Once it was parsed to my liking, I ran into an issue that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt;es only use strings as keys. There &lt;em&gt;is&lt;/em&gt; a way to circumvent it, but there is a &lt;a href=&quot;https://docs.raku.org/language/hashmap#index-entry-non-string_keys&quot;&gt;known bug&lt;/a&gt; in the compiler that casts them to strings anyway.&lt;/p&gt;

&lt;p&gt;Finally, after rewriting my parser and using parameterized hashes as the above documentation suggested, I began fighting their type system. Here is what a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt;‚Äôs declaration looks like:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Hash is Map { }
class Map does Associative does Iterable { }
role Associative[::TValue = Mu, ::TKey = Str(Any)] { }
role Iterable { }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So some functions expect a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt;, others expect an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Iterable&lt;/code&gt; others an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Associative&lt;/code&gt;. With non-parameterized types, they all work great and it just converts it to what it needs at runtime. However, with the parameterized types needed to circumvent the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hash&lt;/code&gt; issue, I would get errors like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Error: Expected Associative[Bag] but found Hash[Bag]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Rather than waste my whole day on the issue, I decided to fall back to ol‚Äô reliable: Python.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;Dataclasses are a fairly recent addition to Python, and are similar to Scala &lt;a href=&quot;https://docs.scala-lang.org/tour/case-classes.html&quot;&gt;case classes&lt;/a&gt;. The idea is they generate the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__init__&lt;/code&gt; and other helper functions for you, and are meant to be used to store data with keys (similar to a &lt;a href=&quot;https://docs.python.org/3/library/collections.html&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;namedtuple&lt;/code&gt;&lt;/a&gt;).&lt;/li&gt;
  &lt;li&gt;To use an object as a key in a dictionary, it has to implement &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__hash__&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__eq__&lt;/code&gt;. By default, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dataclass&lt;/code&gt; does not generate a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__hash__&lt;/code&gt; function for us, but it will with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unsafe_hash=True&lt;/code&gt;. Normally you would want to implement your own &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__hash__&lt;/code&gt; function, but it is safe in this case.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;Now the question flips: if our &lt;em&gt;outermost&lt;/em&gt; bag is our shiny gold bag, how many bags are we required to store inside of it?&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/07/python/main.py&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;dataclasses&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataclass&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;typing&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tuple&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sys&lt;/span&gt;


&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataclass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unsafe_hash&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;adjective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;contains_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;held_bags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contains_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;held_bags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get_contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;total_bags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quantity&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;total_bags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quantity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quantity&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total_bags&lt;/span&gt;


&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataclass&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Rule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bag&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Tuple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parse_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bag_desc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' contain '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Create Bag
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;adjective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag_desc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adjective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Fill in contents
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;_contents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'no other bags.'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;inner_bags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;', '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bag&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inner_bags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;quantity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;adjective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;split&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;inner_bag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;adjective&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quantity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inner_bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Turn the contents into a rule and return
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Rule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;input_file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;stripped&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parse_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stripped&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'shiny'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'gold'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Part 1
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;can_hold_target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;contains_target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;can_hold_target&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Part 2
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;total_contents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_contents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;f'Part 1: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;can_hold_target&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;f'Part 2: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;total_contents&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python main.py input.txt
Part 1: 151
Part 2: 41559
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;As you can see, all we had to add was our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_contents&lt;/code&gt; function to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bag&lt;/code&gt; class. For each bag in the shiny gold bag, it counts not only the bag itself, but all the bags within it as well.&lt;/p&gt;

&lt;p&gt;I don‚Äôt have any implementation-specific comments on this one, as it is pretty straightforward, especially with such a small change from part 1. The only thing I will say is I did not add the CLI that I have added to my Raku solutions because it is much more cumbersome in Python. Every language has its strong suits!&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;While I am bummed that I failed in my goal to write functional Raku for all 25 days of this thing, I think it is important to note that it is best to use the right tool for the job. I think I could have struggled through it in Raku, but I don‚Äôt have the time, patience, or know-how to do that; especially when we‚Äôve got another challenge coming tomorrow! I will continue to try to do the rest of the problems in functional Raku, but if I can‚Äôt do it, at least we‚Äôve already bridged that gap!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Python" /><summary type="html">Well, today was our streak breaker. For the life of me, I could not get Raku to run in a timely manner. I ended up reverting to Python and using a more imperative approach. Nevertheless, I am sharing it here for anyone who cares!</summary></entry></feed>