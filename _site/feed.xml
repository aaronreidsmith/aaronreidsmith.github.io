<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-12-03T08:41:25-06:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Aaron Smith</title><subtitle>Personal website and blog of Aaron Smith</subtitle><author><name>Aaron Smith</name></author><entry><title type="html">Advent of Code: Day 3</title><link href="http://localhost:4000/blog/advent-of-code-day-03/" rel="alternate" type="text/html" title="Advent of Code: Day 3" /><published>2020-12-03T00:00:00-06:00</published><updated>2020-12-03T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-03</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-03/">&lt;p&gt;Today was the first problem that I felt lended itself naturally to a for-loop. While there is nothing wrong with a &lt;a href=&quot;https://two-wrongs.com/myth-of-the-day-functional-programmers-dont-use-loops&quot;&gt;for-loop in functional programming programming&lt;/a&gt;, I wanted to used one of the common substitutes in the functional programmer’s toolbelt: recursion.&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;We are going sledding this week! Our job is to get to the bottom of the mountain following a specific path, and to count how many trees we would run into along the way.&lt;/p&gt;

&lt;p&gt;Given a file that looks like the diagram below, we are to start in the top left of this file and traverse right three spaces and down one space until we hit the bottom, counting the number of hash signs (trees) we encounter.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...#..............#.#....#..#..
...#..#..#..............#..#...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Additionally, this is a magic mountain, so the pattern on each row repeats out to the right infinitely, and we have to account for that.&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/03/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implemenation specific comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub traverse(@mountain, $trees-encountered = 0, $i = 0, $j = 0) {
    if $i &amp;gt; @mountain.elems - 1 {
        $trees-encountered;
    } else {
        my $tree-hit = @mountain[$i][$j] cmp '#' == Same ?? 1 !! 0;
        if $i == @mountain.elems - 1 {
            $trees-encountered + $tree-hit;
        } else {
            traverse(@mountain, $trees-encountered + $tree-hit, $i + 1, $j + 3);
        }
    }
}

sub MAIN($file) {
    say traverse($file.IO.lines.map(-&amp;gt; $line { |$line.comb xx * })); # [1][2][3][4]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
191
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;Other than the below comments, I feel like this reads fairly easily. Basically, we turn our file into a list of infinite lists (described below) and then call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traverse&lt;/code&gt; on that outer list. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traverse&lt;/code&gt; is a &lt;a href=&quot;https://www.geeksforgeeks.org/tail-recursion/&quot;&gt;tail-recursive&lt;/a&gt; function with fairly simple logic:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If we have already passed the bottom, return the number of trees we hit&lt;/li&gt;
  &lt;li&gt;If we are at the bottom of the mountain, see if we are currently hitting a tree and then return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$trees-encountered&lt;/code&gt; with the last tree included&lt;/li&gt;
  &lt;li&gt;Otherwise, add the current tree hit to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$trees-encountered&lt;/code&gt; and go down one row and to the right three columns&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt; has a special meaning when used in front of a list. It flattens any inner lists to the top level. So, for example, if we had &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|((1, 2), (3, 4))&lt;/code&gt;, that would equal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 2, 3, 4)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Reminder that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.comb&lt;/code&gt; splits the input into a list of characters.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xx&lt;/code&gt; is a special operator that takes the input list and concatenates it to itself &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; times (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N = *&lt;/code&gt; here; see below). So, for example, if we had &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 2) xx 2&lt;/code&gt;, that would yield &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((1, 2), (1, 2))&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xx&lt;/code&gt; allows the &lt;a href=&quot;https://docs.raku.org/type/Whatever&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Whatever&lt;/code&gt;&lt;/a&gt; character (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;) on the right hand side, and in that case it returns a lazy, infinite concatenation of the left hand side.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So, to summarize the above comments, we take the line and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comb&lt;/code&gt; it to a list. Then, we concatenate that list infinitely to have a list of lists, which we flatten using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt; operator. Since this happens in a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;, it applies to each line, so we have one finite outer list containing multiple infinite lists. We then traverse the outer list.&lt;/p&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;Given the same file as before, we want to tackle it with five different traversals:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Right 1, down 1&lt;/li&gt;
  &lt;li&gt;Right 3, down 1 (This is the slope we already checked)&lt;/li&gt;
  &lt;li&gt;Right 5, down 1&lt;/li&gt;
  &lt;li&gt;Right 7, down 1&lt;/li&gt;
  &lt;li&gt;Right 1, down 2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then, we must find the product of all the trees we hit with each traversal&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/03/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implemenation specific comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub traverse(@mountain, $i-increment, $j-increment, $trees-encountered = 0, $i = 0, $j = 0) {
    if $i &amp;gt; @mountain.elems - 1 {
        $trees-encountered;
    } else {
        my $tree-hit = @mountain[$i][$j] cmp '#' == Same ?? 1 !! 0;
        if $i == @mountain.elems - 1 {
            $trees-encountered + $tree-hit;
        } else {
            traverse(
                @mountain,
                $i-increment,
                $j-increment,
                $trees-encountered + $tree-hit,
                $i + $i-increment,
                $j + $j-increment
            );
        }
    }
}

sub MAIN($file, Bool :$p2 = False) {
    my @traversals = $p2 ?? (
        (1, 1),
        (1, 3),
        (1, 5),
        (1, 7),
        (2, 1)      # [1]
    ) !! ((1, 3),); # [2]
    say [*] @traversals.map(-&amp;gt; ($i-increment, $j-increment) {
        traverse($file.IO.lines.map(-&amp;gt; $line { |$line.comb xx * }), $i-increment, $j-increment)
    });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
191

# Part 2
$ raku main.raku --p2 input.txt
1478615040
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;Again, we are able to tweak our code slightly and handle both parts one and two in one block. In this case, we added two arguments to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;traverse&lt;/code&gt; to tell it the row step-size and column step-size. We then just add the list of lists corresponding to the five traversals noted above, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; over them and calculate the product using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[*]&lt;/code&gt; operator! In the case of part one, it is a list of size one, so &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[*]&lt;/code&gt; will just return the single element.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;The input file has 323 lines, so we will hit the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$i &amp;gt; @mountain.elems - 1&lt;/code&gt; case with this traversal, so it is a good thing we generalized it in the previous step!&lt;/li&gt;
  &lt;li&gt;Need this to be a list of lists to map over it, so we need the comma to denote the outer list is of size one.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I felt this problem came very serendipitously; I was &lt;em&gt;just&lt;/em&gt; reading about the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xx&lt;/code&gt; operators last night, so I am glad I got to put them to use. Recursion (and more specifically tail recursion) is always a fun approach, and it let us tackle this problem functionally. 3 for 3! Let’s see what tomorrow brings.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Today was the first problem that I felt lended itself naturally to a for-loop. While there is nothing wrong with a for-loop in functional programming programming, I wanted to used one of the common substitutes in the functional programmer’s toolbelt: recursion.</summary></entry><entry><title type="html">Advent of Code: Day 2</title><link href="http://localhost:4000/blog/advent-of-code-day-02/" rel="alternate" type="text/html" title="Advent of Code: Day 2" /><published>2020-12-02T00:00:00-06:00</published><updated>2020-12-02T00:00:00-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-02</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-02/">&lt;p&gt;We’re back again with another functional Raku solution! This problem requires some text parsing as well, which is where Raku (and its older brother Perl) really shine, so that was quite a bit of fun to utilize. Let’s dive right in!&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;Given a file full of lines that look like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1-3 a: ababa
10-14 q: qqqqqqqqq
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Which can be interpretted as a password policy that reads as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The password &quot;ababa&quot; must contain between 1 and 3 (inclusive) &quot;a&quot; characters
The password &quot;qqqqqqqqqq&quot; must contain between 10 and 14 (inclusive) &quot;q&quot; characters
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our job is to find how many passwords are &lt;strong&gt;valid&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/02/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implemenation specific comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;grammar PasswordEntry {
    token TOP { ^(&amp;lt;digit&amp;gt;+)'-'(&amp;lt;digit&amp;gt;+) &amp;lt;.ws&amp;gt; (&amp;lt;[a..z]&amp;gt;)':' &amp;lt;.ws&amp;gt; (&amp;lt;[a..z]&amp;gt;+)$ } # [1]
}

grammar PasswordEntryActions {
    method TOP($/) {                                                          # [2]
        my $range-start  = $/[0].Int;
        my $range-end    = $/[1].Int;
        my $target       = $/[2].Str;
        my $password     = $/[3].Str;
        my $target-count = $password.comb($target).elems;                     # [3]
        make so $range-start &amp;lt;= $target-count &amp;amp;&amp;amp; $target-count &amp;lt;= $range-end;
    }
}

sub MAIN($file) {
    my $actions = PasswordEntryActions.new;
    say $file.IO.lines
          .map(-&amp;gt; $row { PasswordEntry.parse($row, :$actions).made }) # [4]
          .grep(* == True)                                            # [5]
          .elems;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
393
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;We do a couple things here:&lt;/p&gt;

&lt;p&gt;First we pull in all the lines in the file, then parse them using our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PasswordEntry&lt;/code&gt; grammar. See below for the explanation on the grammar.&lt;/p&gt;

&lt;p&gt;When we parse each line, we specify what actions should take place with the parsed text (in this case, we pass it to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PasswordEntryActions&lt;/code&gt; to do post-processing). &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PasswordEntryActions&lt;/code&gt; takes the input (a &lt;a href=&quot;https://docs.raku.org/type/Match&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Match&lt;/code&gt;&lt;/a&gt; object), and determines if the parsed password contains the right number of target characters.&lt;/p&gt;

&lt;p&gt;These are then filtered down to only those that &lt;em&gt;do&lt;/em&gt; contain the right number of characters (valid passwords) and counted.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;We could just define a regex like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;my $regex = /pattern/&lt;/code&gt;, but I wanted to combine the parse step &lt;em&gt;and&lt;/em&gt; the business logic of determining if it is a valid password; we will get into that second part below.
    &lt;ul&gt;
      &lt;li&gt;When definining a grammar, you always have to define a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TOP&lt;/code&gt; token the encompasses everything. If I had a more complex grammar, I could define subtokens that could be used in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TOP&lt;/code&gt; token (or any other defined tokens).&lt;/li&gt;
      &lt;li&gt;For the non-regex folks, the way this reads is:
        &lt;ul&gt;
          &lt;li&gt;Start of line&lt;/li&gt;
          &lt;li&gt;An integer (captured group, see below)&lt;/li&gt;
          &lt;li&gt;Followed by a dash&lt;/li&gt;
          &lt;li&gt;Followed by an integer (captured group, see below)&lt;/li&gt;
          &lt;li&gt;Followed by a space&lt;/li&gt;
          &lt;li&gt;Followed by a single lowercase letter (captured group, see below)&lt;/li&gt;
          &lt;li&gt;Followed by a colon&lt;/li&gt;
          &lt;li&gt;Followed by a space&lt;/li&gt;
          &lt;li&gt;Followed by one or more lowercase letters (captured group, see below)&lt;/li&gt;
          &lt;li&gt;End of line&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Additionally, you’ll notice the four sets of parenthese that define &lt;em&gt;capture groups&lt;/em&gt;, meaning when this grammar parses a line successfully, it will return the four groups in an array.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;When we use the parser (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PasswordEntry.parse&lt;/code&gt;), we are able to supply this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;actions&lt;/code&gt; class that has methods corresponding to the tokens in the parser. This is where any business logic should take place. For example, any type casting or object creation to be used in the outer scope. In this case, like I said above, we want to parse and reduce to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt; in one pass. So what our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TOP&lt;/code&gt; method does is take the match &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$/&lt;/code&gt; (this is a special variable, I would never name something like this), extract the four groups defined in the grammar, and cast them to the correct types. We then count the number of times the target appears in the password and see if it is in range.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comb&lt;/code&gt; takes a string and turns it into a list of characters. When supplied with a string argument (in this case, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$target&lt;/code&gt;), it turns the string into a list &lt;em&gt;and&lt;/em&gt; filters it down to elements that equal the supplied character.&lt;/li&gt;
  &lt;li&gt;There is some special syntax going on on this line. I could have written &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PasswordEntry.parse($row, actions =&amp;gt; $actions)&lt;/code&gt;, and used &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$actions&lt;/code&gt; as a named keyword. But, since my variable has the same name as the target argument, I am able to pass it in as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:$actions&lt;/code&gt;. It reminds me of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;**kwargs&lt;/code&gt; in Python.&lt;/li&gt;
  &lt;li&gt;I &lt;em&gt;hate&lt;/em&gt; that I have to say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;* == True&lt;/code&gt;, but &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt; would not work otherwise, so I guess that is just an edge case.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;Given the same file as before, the interpretation of the lines has changed. Given the same lines as above, the intperpretation should now be:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The password &quot;ababa&quot; must contain an &quot;a&quot; character in position 1 or 3 (but not both)
The password &quot;qqqqqqqqqq&quot; must contain a &quot;q&quot; character in position 10 or 14 (but not both)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; These strings are 1-indexed instead of 0-indexed, so we have to account for that.&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/02/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implemenation specific comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;grammar PasswordEntry {
    token TOP { ^(&amp;lt;digit&amp;gt;+)'-'(&amp;lt;digit&amp;gt;+) &amp;lt;.ws&amp;gt; (&amp;lt;[a..z]&amp;gt;)':' &amp;lt;.ws&amp;gt; (&amp;lt;[a..z]&amp;gt;+)$ }
}

class PartOneActions {
    method TOP($/) {
        my $range-start  = $/[0].Int;
        my $range-end    = $/[1].Int;
        my $target       = $/[2].Str;
        my $password     = $/[3].Str;
        my $target-count = $password.comb($target).elems;
        make so $range-start &amp;lt;= $target-count &amp;amp;&amp;amp; $target-count &amp;lt;= $range-end;
    }
}

class PartTwoActions {
    method TOP($/) {
        my $position-one = $/[0].Int - 1;
        my $position-two = $/[1].Int - 1;
        my $target       = $/[2].Str;
        my @password     = $/[3].Str.comb;
        make so (
            (@password[$position-one] cmp $target) == Same # [1][2]
            xor                                            # [3]
            (@password[$position-two] cmp $target) == Same
        );
    }
}

sub MAIN($file, Bool :$p2 = False) {
    my $actions = $p2 ?? PartTwoActions.new !! PartOneActions.new;
    say $file.IO.lines
          .map(-&amp;gt; $row { PasswordEntry.parse($row, :$actions).made })
          .grep(* == True)
          .elems;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
393

# Part 2
$ raku main.raku --p2 input.txt
690
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;Similarly to &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-01/&quot;&gt;day 1&lt;/a&gt;, we can utilize the code already written and tweak it a little bit. In this case, the grammar stays the same, but the actions taken on each line need to change.&lt;/p&gt;

&lt;p&gt;Again, we provide the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--p2&lt;/code&gt; flag, and then add the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PartTwoActions&lt;/code&gt; class to handle the business logic for the new interpretation of the password policy.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;I had to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmp&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt; here to get proper string comparison (otherwise, Raku tries to cast strings to hexadecimal).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cmp&lt;/code&gt; returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Less&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;More&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Same&lt;/code&gt; instead of a boolean. I couldn’t find a way to cast &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Same&lt;/code&gt; to a boolean, because it casts it as such &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Same -&amp;gt; 0 -&amp;gt; False&lt;/code&gt;, when what we really want is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;, so I had to add the ugly &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;== Same&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt; is a junction operator in Raku, so it has the handy dandy &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xor&lt;/code&gt; operator utilized here.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Another functional and (in my opinion) beautiful solution! In my day job, I actually maintain a grammar defined using &lt;a href=&quot;https://www.antlr.org/&quot;&gt;ANTLR&lt;/a&gt;, so it is fun to see tools with the same concepts in other languages. Looking forward to getting to use grammars more in Raku. See y’all tomorrow!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">We’re back again with another functional Raku solution! This problem requires some text parsing as well, which is where Raku (and its older brother Perl) really shine, so that was quite a bit of fun to utilize. Let’s dive right in!</summary></entry><entry><title type="html">Advent of Code: Day 1</title><link href="http://localhost:4000/blog/advent-of-code-day-01/" rel="alternate" type="text/html" title="Advent of Code: Day 1" /><published>2020-12-01T00:00:00-06:00</published><updated>2020-12-01T07:40:30-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-01</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-01/">&lt;p&gt;Turns out I started blogging just in time for the &lt;a href=&quot;https://adventofcode.com/&quot;&gt;Advent of Code&lt;/a&gt;, an annual series of daily challenges that run from December 1st to December 25th.&lt;/p&gt;

&lt;p&gt;These problems remind me a lot of &lt;a href=&quot;https://projecteuler.net/&quot;&gt;Project Euler&lt;/a&gt;, because they are not concerned with the readability or speed of your code, just the output. That means that any goals one wishes to accomplish should be set personally (there &lt;em&gt;is&lt;/em&gt; technically a leaderboard, but I find you have to be online very late at night to catch the posts and it is not worth the stress during the holiday season).&lt;/p&gt;

&lt;p&gt;My goal, as you may have guessed from my previous posts, is to complete these challenges in &lt;em&gt;at least&lt;/em&gt; Raku and to do so utilizing a functional programming paradigm. Let’s dive into day 1 and see if I can do it!&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;p&gt;I am not going to copy and paste the explanation of the problem here like I do for the Perl Weekly Challenge, because it is &lt;em&gt;so&lt;/em&gt; long and I want to encourage users to go attempt the challenge themselves! Instead, I will write a summary of what the challenge is and my solution.&lt;/p&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;Given a file full of integers (one per line), find the single pair of integers that adds up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2020&lt;/code&gt;, then find the product of those two numbers.&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/01/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implemenation specific comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($file) {
    say $file.IO.lines                           # [1]
          .combinations(2)                       # [2]
          .grep(-&amp;gt; ($a, $b) { $a + $b == 2020 }) # [3]
          .map(-&amp;gt; ($a, $b) { $a * $b })          # [4]
          .head;                                 # [5]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
1020036
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;This is fairly straight forward and I feel Raku reads very cleanly. Basically, we read the entire file into a list (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.lines&lt;/code&gt;), then find all the pairs in that list, filter those pairs down to where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a + $b == 2020&lt;/code&gt;, then multiply those two numbers together!&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;I’m a sucker for good IO. I feel reading/writing files in languages like Java or Scala is so cumbersome that I try to avoid it at all costs. Languages like Raku were &lt;em&gt;built&lt;/em&gt; for text manipultion, so it makes sense that the IO is great, but I just wanted to call out how easy it is to get the lines of a file in a list.&lt;/li&gt;
  &lt;li&gt;As I said in my &lt;a href=&quot;https://aaronreidsmith.github.io/blog/perl-weekly-challenge-089/#specific-comments&quot;&gt;previous post&lt;/a&gt;, I see the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;combinations&lt;/code&gt; feature coming back a lot in these puzzles. I love that it is built right in.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt; is familiar to most &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*nix&lt;/code&gt; users, and it is the equivalent of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter&lt;/code&gt; in more traditional functional languages. In this case, we are filtering down to only pairs that add up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2020&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;At this point this list looks like this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(($a, $b))&lt;/code&gt;, so we still want to map over the outer list and multiply the pair together.&lt;/li&gt;
  &lt;li&gt;Since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; returns a list, we need to grab the first item from that list for pretty printing.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;Given the same file as before, find the &lt;em&gt;3&lt;/em&gt; numbers that add up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2020&lt;/code&gt; and find their product.&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/01/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implemenation specific comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($file, Bool :$p2 = False) {                # [1]
    say $file.IO.lines
          .combinations($p2 ?? 3 !! 2)              # [2]
          .grep(-&amp;gt; @combo { ([+] @combo) == 2020 }) # [3]
          .map(-&amp;gt; @combo { [*] @combo })
          .head;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
1020036

# Part 2
$ raku main.raku --p2 input.txt
286977330
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;Since it is basically the same problem, it only makes sense to modify the script we have already written rather than starting from scratch. Basically, everywhere where we hardcoded &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a, $b&lt;/code&gt; needs to be generalized to some list. In this case, we added a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p2&lt;/code&gt; CLI flag that allows the users to specify if they are doing part 1 or part 2. If they are doing part 2 we find trios instead of pairs, then perform the same “business logic” on that collection.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;Using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:$p2&lt;/code&gt; notation says to Raku “create a command line flag called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--p2&lt;/code&gt; and assign it to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$p2&lt;/code&gt; with a default of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;”. Creating command line interfaces can be kind of a pain in a lot of languages, so I am happy that is built right into the language.&lt;/li&gt;
  &lt;li&gt;This is the check to see if we are doing part 1 or part 2. Raku’s ternary operator is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;condition ?? true !! false&lt;/code&gt; rather than the traditional &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;condition ? true : false&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Since we have to remove all the pair hardcoding, we can generalize it as a list called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@combo&lt;/code&gt; and then just find the sum of the entire combo using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[+]&lt;/code&gt; meta operator. We perform a similar generalization for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; step.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;So far so good with my goal to write Raku solutions functionally! Check my &lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code&quot;&gt;GitHub&lt;/a&gt; to see any other solutions (and any other languages, if I get around to them). This was a fun little dip into the Advent of Code, and I am looking forward to the rest of the month!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Turns out I started blogging just in time for the Advent of Code, an annual series of daily challenges that run from December 1st to December 25th.</summary></entry><entry><title type="html">Perl Weekly Challenge 89</title><link href="http://localhost:4000/blog/perl-weekly-challenge-089/" rel="alternate" type="text/html" title="Perl Weekly Challenge 89" /><published>2020-11-30T00:00:00-06:00</published><updated>2020-12-01T07:40:30-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-089</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-089/">&lt;p&gt;Back again with challenge 89! I was able to tackle this one the day it was released, but I doubt that will be the case going forward.&lt;/p&gt;

&lt;p&gt;Once again, it seems the first task can be tackled easily in a functional way and the second one ends up being more imperative. Hoping I can try to do more things functionally in the future!&lt;/p&gt;

&lt;h2 id=&quot;task-1-gcd-sum&quot;&gt;Task 1: GCD Sum&lt;/h2&gt;

&lt;p&gt;You are given a positive integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to sum &lt;a href=&quot;https://en.wikipedia.org/wiki/Greatest_common_divisor&quot;&gt;GCD&lt;/a&gt; of all possible unique pairs between 1 and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 3
Output: 3

gcd(1,2) + gcd(1,3) + gcd(2,3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 4
Output: 7

gcd(1,2) + gcd(1,3) + gcd(1,4) + gcd(2,3) + gcd(2,4) + gcd(3,4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-089/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any specific implementation comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($N where $N ~~ Int &amp;amp;&amp;amp; $N &amp;gt; 0) {
    my @pairs = (1..$N).combinations(2);                    # [1]
    say [+] @pairs.map(-&amp;gt; @pair { @pair[0] gcd @pair[1] }); # [2][3]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 3
3

$ raku ch-1.raku 4
7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The thought process here is pretty straight forward:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Find all pairs from 1 to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Find the GCD of each pair&lt;/li&gt;
  &lt;li&gt;Sum the GCDs produced in step 2&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You’ll see my functional programming background bubbling up again. In fact, this could honestly be a one-liner if I weren’t going for readability:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;say [+] (1..$N).combinations(2).map(-&amp;gt; @pair { @pair[0] gcd @pair[1] });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Raku provided a great subroutine to find all the pairs in a list (&lt;a href=&quot;https://docs.raku.org/routine/combinations&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;combinations&lt;/code&gt;&lt;/a&gt;). In fact, it is generalized such that you can take more than just pairs (if I didn’t provide a number, it would find &lt;em&gt;all&lt;/em&gt; combinations from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size=0&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size=$N&lt;/code&gt;), so it may come back in future problems!&lt;/li&gt;
  &lt;li&gt;This was an interesting one for me. In Scala, since it is so strongly and statically typed, we know that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@pairs&lt;/code&gt; list contains lists itself, so you could just say: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pairs.map(_._1 gcd _._2)&lt;/code&gt;. In Raku, I had to use the &lt;a href=&quot;https://docs.raku.org/language/functions#Blocks_and_lambdas&quot;&gt;pointy block&lt;/a&gt; notation to give the mapped items a name and, more importantly, a sigil to treat it as a list.&lt;/li&gt;
  &lt;li&gt;I &lt;em&gt;love&lt;/em&gt; that a lot of simple things (like &lt;a href=&quot;https://docs.raku.org/routine/gcd&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gcd&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.raku.org/routine/is-prime&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is-prime&lt;/code&gt;&lt;/a&gt;) are built right into Raku. It saves a lot of boilerplate code and potentially bad implementation of these functions.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-magic-matrix&quot;&gt;Task 2: Magic Matrix&lt;/h2&gt;

&lt;p&gt;Write a script to display matrix as below with numbers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 - 9&lt;/code&gt;. Please make sure numbers are used once.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ a b c ]
[ d e f ]
[ g h i ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So that it satisfies the following:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a + b + c = 15
d + e + f = 15
g + h + i = 15
a + d + g = 15
b + e + h = 15
c + f + i = 15
a + e + i = 15
c + e + g = 15
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-089/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset OddPositiveInt of Int where { $_ ~~ Int &amp;amp;&amp;amp; $_ &amp;gt; 0 &amp;amp;&amp;amp; !($_ %% 2) }

sub MAIN($side-length where $side-length ~~ OddPositiveInt = 3, $debug where $debug ~~ Bool = False) {
    my @matrix = generate-matrix($side-length);
    my @filled-in-matrix = fill-in-matrix(@matrix, $side-length);
    for @filled-in-matrix -&amp;gt; @row {
        say '[ ' ~ @row.join(' ') ~ ' ]';
    }
    if $debug {
        print &quot;\n&quot;;
        validate-matrix(@filled-in-matrix, $side-length);
    }
}

# Generate a 2D matrix that we can fill in with the proper numbers.
# For 3x3 it would output:
#  [0 0 0]
#  [0 0 0]
#  [0 0 0]
sub generate-matrix($side-length) {
    my @matrix = Array.new;
    for ^$side-length -&amp;gt; $i {
        my @row = Array.new;
        for (($i * $side-length) + 1..($i * $side-length) + $side-length) {
            @row.push(0);
        }
        @matrix.push(@row);
    }
    @matrix
}

# Actual business logic here. It takes the empty array and fills it in to be &quot;magic&quot;
# Such that all rows, columns, and the two diagonals add up to $side-length * ($side-length² + 1) / 2
sub fill-in-matrix(@matrix, $side-length) {
    my $num = 1;
    my $row = floor($side-length / 2);
    my $col = $side-length - 1;

    while $num &amp;lt;= $side-length² {                # [1]
        if $row == -1 &amp;amp;&amp;amp; $col == $side-length {  # Condition 3 (see below)
            $col = $side-length - 2;
            $row = 0;
        } else {
            if $col == $side-length {            # Condition 1 (see below)
                $col = 0;
            }
            if $row &amp;lt; 0 {
                $row = $side-length - 1;
            }
        }
        if @matrix[$row][$col] != 0 {           # Condition 2 (see below)
            $col -= 2;
            $row++;
        } else {
            @matrix[$row][$col] = $num;
            $num++;
            $col++;
            $row--;
        }
    }
    @matrix;
}

# Helper function to validate output matrix and print the validation
sub validate-matrix(@matrix, $side-length) {
    my @rows = @matrix;
    my @columns = [Z] @matrix;                                                   # [2]
    my @diagonal = @matrix.kv.map(-&amp;gt; $i, @row { @row[$i] });
    my @counter-diagonal = @matrix.kv.map(-&amp;gt; $i, @row { @row[*-$i-1] });

    my $target = ($side-length * ($side-length² + 1) / 2).Int;

    my $valid-rows = so @rows.map(-&amp;gt; @row { [+] @row }).all == $target;          # [3]
    my $valid-cols = so @columns.map(-&amp;gt; @column { [+] @column }).all == $target;
    my $valid-diag = so ([+] @diagonal) == $target;
    my $valid-counter-diag = so ([+] @counter-diagonal) == $target;

    if $valid-rows &amp;amp;&amp;amp; $valid-cols &amp;amp;&amp;amp; $valid-diag &amp;amp;&amp;amp; $valid-counter-diag {
        for @rows -&amp;gt; @row {
            say @row.join(' + ') ~ ' = ' ~ $target;
        }
        for @columns -&amp;gt; @column {
            say @column.join(' + ') ~ ' = ' ~ $target;
        }
        say @diagonal.join(' + ') ~ ' = ' ~ $target;
        say @counter-diagonal.join(' + ') ~ ' = ' ~ $target;
    } else {
        die &quot;Not a valid magic matrix&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku
[ 2 7 6 ]
[ 9 5 1 ]
[ 4 3 8 ]

# There is an optional `debug` parameter that can be supplied, but the `side-length` argument must also be provided
$ raku ch-2.raku 3 True
[ 2 7 6 ]
[ 9 5 1 ]
[ 4 3 8 ]

2 + 7 + 6 = 15
9 + 5 + 1 = 15
4 + 3 + 8 = 15
2 + 9 + 4 = 15
7 + 5 + 3 = 15
6 + 1 + 8 = 15
2 + 5 + 8 = 15
6 + 5 + 4 = 15
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It should be noted this program only works with odd side-length squares&lt;/p&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Full disclosure, I have done this problem before, so I basically just ported some old code. There are two steps to this problem before we even get to implementation:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Find the pattern for what the sum is
    &lt;ul&gt;
      &lt;li&gt;As seen in the code, you will find it is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N(N²+1)/2&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Draw some “magic matrices” to see if you can find any patterns&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You will find 3 patterns hold true (I am copying these from &lt;a href=&quot;https://www.geeksforgeeks.org/magic-square/&quot;&gt;Geeks for Geeks&lt;/a&gt;):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The position of next number is calculated by decrementing row number of the previous number by 1, and incrementing the column number of the previous number by 1. At any time, if the calculated row position becomes -1, it will wrap around to n-1. Similarly, if the calculated column position becomes n, it will wrap around to 0.&lt;/li&gt;
  &lt;li&gt;If the magic square already contains a number at the calculated position, calculated column position will be decremented by 2, and calculated row position will be incremented by 1.&lt;/li&gt;
  &lt;li&gt;If the calculated row position is -1 &amp;amp; calculated column position is n, the new position would be: (0, n-2).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Basically, we just start in the middle right square and apply the above criteria iteratively and it works for any odd-side-lengthed square.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Raku supports Unicode, so you’ll notice I used &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$side-length²&lt;/code&gt; rather than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$side-length ** 2&lt;/code&gt;. It’s a small feature that I find helps readibilty (but can be hard to write)!&lt;/li&gt;
  &lt;li&gt;This has been called out as a &lt;a href=&quot;https://docs.raku.org/language/traps#Using_[%E2%80%A6]_metaoperator_with_a_list_of_lists&quot;&gt;trick to avoid&lt;/a&gt; because it fails when you get a matrix with 1 row. Since it is being used in a debugging function and if we &lt;em&gt;did&lt;/em&gt; get a 1-row matrix it would be 1x1, so I think it is safe to use here&lt;/li&gt;
  &lt;li&gt;I don’t really like that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;so&lt;/code&gt; is the subroutine used to cast input to a boolean, so I just wanted to call out that (a) that is what these lines are doing and (b) I don’t like the terminology.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I’m really glad I decided to start doing these challenges weekly, and I may even go back and attempt old challenges if I have time.&lt;/p&gt;

&lt;p&gt;With that being said, I am kind of disappointed in myself for just copying old code for task two. For one, I have grown as a programmer since writing that, and two, it seems past-me just copied that code from somewhere on the internet. While it was kind of challenging porting it to Raku, I feel like it was the lazy way out.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Back again with challenge 89! I was able to tackle this one the day it was released, but I doubt that will be the case going forward.</summary></entry><entry><title type="html">Perl Weekly Challenge 88</title><link href="http://localhost:4000/blog/perl-weekly-challenge-088/" rel="alternate" type="text/html" title="Perl Weekly Challenge 88" /><published>2020-11-29T00:00:00-06:00</published><updated>2020-12-01T07:40:30-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-088</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-088/">&lt;p&gt;I have always been a fan of Perl (and its younger brother Raku), but, since leaving the Bioinformatics world, have not found any real-world scenarios to flex those muscles.&lt;/p&gt;

&lt;p&gt;I recently stumbled upon the &lt;a href=&quot;https://perlweeklychallenge.org/&quot;&gt;Perl Weekly Challenge&lt;/a&gt; and decided it would be a great way to keep up-to-date with the community. I participated for the first time this week and thought it would be fun to do a write up of how I approached the problems. In the future, I will start publishing my blogs earlier in the week so that I can include a link to it in my PR.&lt;/p&gt;

&lt;p&gt;So, without further adieu, let’s dive in.&lt;/p&gt;

&lt;h2 id=&quot;task-1-array-of-product&quot;&gt;Task 1: Array of Product&lt;/h2&gt;

&lt;p&gt;You are given an array of positive integers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to return an array &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@M&lt;/code&gt; where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$M[i]&lt;/code&gt; is the product of all elements of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt; except the index &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N[i]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    @N = (5, 2, 1, 4, 3)
Output:
    @M = (24, 60, 120, 30, 40)

    $M[0] = 2 x 1 x 4 x 3 = 24
    $M[1] = 5 x 1 x 4 x 3 = 60
    $M[2] = 5 x 2 x 4 x 3 = 120
    $M[3] = 5 x 2 x 1 x 3 = 30
    $M[4] = 5 x 2 x 1 x 4 = 40
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    @N = (2, 1, 4, 3)
Output:
    @M = (12, 24, 6, 8)

    $M[0] = 1 x 4 x 3 = 12
    $M[1] = 2 x 4 x 3 = 24
    $M[2] = 2 x 1 x 3 = 6
    $M[3] = 2 x 1 x 4 = 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any specific implementation comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset PositiveInt of Int where { $_ ~~ Int &amp;amp;&amp;amp; $_ &amp;gt; 0 } # [1]

sub MAIN(*@N where all(@N) ~~ PositiveInt &amp;amp;&amp;amp; @N.elems &amp;gt; 0) {
    my $product = [*] @N;         # [2]
    my @M = @N.map: $product / *; # [3]
    say @M;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 5 2 1 4 3
[24 60 120 30 40]

$ raku ch-1.raku 2 1 4 3
[12 24 6 8]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;My day job is 100% Scala, so I try to approach everything with an immutable and functional approach, ideally with only one pass through the input list.&lt;/p&gt;

&lt;p&gt;The approach I took reminded me of multiplying fractions by the unit fraction to remove the denominator. For example &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1/4 x 4/4 = 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is the approach applied to example 1 above:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$M[0] = (5 x 2 x 1 x 4 x 3) / 5 = 24
$M[1] = (5 x 2 x 1 x 4 x 3) / 2 = 60
$M[2] = (5 x 2 x 1 x 4 x 3) / 1 = 120
$M[3] = (5 x 2 x 1 x 4 x 3) / 4 = 30
$M[4] = (5 x 2 x 1 x 4 x 3) / 3 = 40
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The problem states we are given an array of positive integers, but it never hurts to validate. Raku gives us the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subset&lt;/code&gt; keyword to easily define subsets of other types. In this case, the element has to be an integer and must be greater than 0. We then use this subset in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; subroutine’s signature.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As we can see from the modifications to example 1 above, we will always have the product of all items in the numerator and current item in the denominator. We just want to calculate that once, and Raku gives us a simple way of doing that through it’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[*]&lt;/code&gt; operator.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This line shows my functional programming background bubbling up. Basically, for each item in the list, we want &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$product / $item&lt;/code&gt;, and we want the output collected into a list. This is a &lt;em&gt;textbook&lt;/em&gt; case for a map function, so you can see that is what I went with.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;To a non-Raku user, this may be a little confusing because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; in a map &lt;em&gt;literally&lt;/em&gt; means &lt;a href=&quot;https://docs.raku.org/type/Whatever&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;whatever&lt;/code&gt;&lt;/a&gt; (more specifically, “whatever input I received”) and &lt;em&gt;not&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multiply&lt;/code&gt;. The Scala equivalent would be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N.map(item =&amp;gt; product / item)&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-spiral-matrix&quot;&gt;Task 2: Spiral Matrix&lt;/h2&gt;

&lt;p&gt;You are given &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m x n&lt;/code&gt; matrix of positive integers.&lt;/p&gt;

&lt;p&gt;Write a script to print spiral matrix as list.&lt;/p&gt;

&lt;h3 id=&quot;example-1-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    [ 1, 2, 3 ]
    [ 4, 5, 6 ]
    [ 7, 8, 9 ]
Ouput:
    [ 1, 2, 3, 6, 9, 8, 7, 4, 5 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2-1&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    [  1,  2,  3,  4 ]
    [  5,  6,  7,  8 ]
    [  9, 10, 11, 12 ]
    [ 13, 14, 15, 16 ]
Output:
    [ 1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any specific implementation comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset PositiveInt of Int where { $_ ~~ Int &amp;amp;&amp;amp; $_ &amp;gt; 0 }

enum Direction &amp;lt;NORTH EAST SOUTH WEST&amp;gt;;

sub MAIN(*@input where all(@input) ~~ PositiveInt &amp;amp;&amp;amp; @input.elems &amp;gt; 0) {
    # Ensure our input is exactly square
    my $side-length = @input.elems.sqrt;
    $side-length.Int == $side-length or die &quot;Must be a square matrix&quot;;

    # Turn our CLI input into a list of lists (containing both the value and a flag for if we have visted it)
    my @matrix = gather {
        loop (my $i = 0; $i &amp;lt; @input.elems; $i += $side-length) {
            my @row = @input[$i..^$i + $side-length].map({ Hash.new('value', $_, 'visited', False) });
            take @row;
        }
    }

    # Output list and helper function for adding to it
    my @output;
    sub visit-cell($i, $j) {
        my %cell = @matrix[$i][$j];
        if !%cell{'visited'} {
            @output.push(%cell{'value'});
        }
        @matrix[$i][$j]{'visited'} = True;
    }

    # Control vars used below
    my ($min-row, $min-col) = 0, 0;
    my ($max-row, $max-col) = @matrix.elems - 1, @matrix.tail.elems - 1;
    my ($current-row, $current-col, $current-direction) = $min-row, $min-col, EAST;

    # Iterate through matrix in the given directions. Check if we are in a corner or if we have already
    # visited the next cell to determine if we should turn
    while @output.elems != @input.elems {
        visit-cell($current-row, $current-col);
        given $current-direction {
            when EAST {
                if $current-col == $max-col || @matrix[$current-row][$current-col+1]{'visited'} {
                    $current-direction = SOUTH;
                    $current-row += 1;
                } else {
                    $current-col += 1;
                }
            }
            when SOUTH {
                if ($current-row == $max-row &amp;amp;&amp;amp; $current-col == $max-col) || @matrix[$current-row+1][$current-col]{'visited'} {
                    $current-direction = WEST;
                    $current-col -= 1;
                } else {
                    $current-row += 1;
                }
            }
            when WEST {
                if $current-col == $min-col || @matrix[$current-row][$current-col-1]{'visited'} {
                    $current-direction = NORTH;
                    $current-row -= 1;
                } else {
                    $current-col -= 1;
                }
            }
            when NORTH {
                # No need to check for special case here, because we always start in the top left
                if @matrix[$current-row-1][$current-col]{'visited'} {
                    $current-direction = EAST;
                    $current-col += 1;
                } else {
                    $current-row -= 1;
                }
            }
        }
    }
    say @output;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 1 2 3 4 5 6 7 8 9
[1 2 3 6 9 8 7 4 5]

$ raku ch-2.raku 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
[1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I &lt;em&gt;tried&lt;/em&gt; to do this one functionally, but I just couldn’t find a way to do it.&lt;/p&gt;

&lt;p&gt;The basics of the above program are as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We take some input and make sure it is square
    &lt;ul&gt;
      &lt;li&gt;Couldn’t find a better way to do this, but I am all ears if anyone knows. Scala has an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isWhole&lt;/code&gt; function on its number classes, so I basically did that check myself:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; my $side-length = @input.elems.sqrt;
 $side-length.Int == $side-length or die &quot;Must be a square matrix&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Convert that into an actual matrix that looks like this (using example 1):&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [
     [{value: 1, visited: False}, {value: 2, visited: False}, {value: 3, visited: False}],
     [{value: 4, visited: False}, {value: 5, visited: False}, {value: 6, visited: False}],
     [{value: 7, visited: False}, {value: 8, visited: False}, {value: 9, visited: False}],
 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Starting in the top left corner, walk to the right (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EAST&lt;/code&gt;) with the following logic: if we hit the edge or a visited cell, turn right, else keep going.
    &lt;ul&gt;
      &lt;li&gt;We always “visit” the current cell by marking it visted and adding it to the output&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;That’s it!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;What I like about this solution is that it is pretty simple. In fact, steps one and two could be drastically simplified if this program trusted that it would always get a square matrix rather than a 1D matrix from the command line. Additionally, as a fan of pattern matching, I am glad I got to use a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given/when&lt;/code&gt; clause here.&lt;/p&gt;

&lt;p&gt;What I dislike about this solution is the mutability (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output.push()&lt;/code&gt;) and the fragility of it. For example, if the problem were tweaked to walk counter clockwise, I would basically have to re-write the actual “business logic” of this solution.&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;This was a fun dive back into the world of Perl, and I am looking forward to more of these challenges and blogs going forward.&lt;/p&gt;

&lt;p&gt;I am hoping someone can prove me wrong and solve the second problem functionally. Looking forward to seeing everyone’s solutions and interacting more with the community!&lt;/p&gt;

&lt;h4 id=&quot;ps&quot;&gt;PS&lt;/h4&gt;

&lt;p&gt;It seems the theme I am using for my blog does not support &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;raku&lt;/code&gt; code highlighting yet. I am using Jekyll; any plugin I can use to circumvent this?&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">I have always been a fan of Perl (and its younger brother Raku), but, since leaving the Bioinformatics world, have not found any real-world scenarios to flex those muscles.</summary></entry></feed>