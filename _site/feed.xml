<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-12-01T08:43:17-06:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Aaron Smith</title><subtitle>Personal website and blog of Aaron Smith</subtitle><author><name>Aaron Smith</name></author><entry><title type="html">Sabbatical</title><link href="http://localhost:4000/personal/sabbatical/" rel="alternate" type="text/html" title="Sabbatical" /><published>2021-06-20T00:00:00-05:00</published><updated>2021-06-20T00:00:00-05:00</updated><id>http://localhost:4000/personal/sabbatical</id><content type="html" xml:base="http://localhost:4000/personal/sabbatical/">&lt;p&gt;Today is Father’s Day in the U.S. I have an almost-11-month-old son who I should be spending time with, but I feel the need to post a blog because I have been doing so weekly since November 2020. However, I find no joy in it today or even recently. I still enjoy doing the occasional Perl Weekly Challenge (I was only able to get &lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-117/aaronreidsmith/raku/ch-1.raku&quot;&gt;Part 1&lt;/a&gt; done before the deadline this week), but writing about it has become a source of burnout. I don’t even think I have readers out there, but I figured it would be worth sharing my thoughts on the matter rather than just disappearing. I will still blog from time to time, but I will no longer put the pressure on myself to do it weekly. With that, I am going to go spend time with my family.&lt;/p&gt;

&lt;p&gt;Cheers,&lt;br /&gt;
Aaron&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Personal" /><summary type="html">Today is Father’s Day in the U.S. I have an almost-11-month-old son who I should be spending time with, but I feel the need to post a blog because I have been doing so weekly since November 2020. However, I find no joy in it today or even recently. I still enjoy doing the occasional Perl Weekly Challenge (I was only able to get Part 1 done before the deadline this week), but writing about it has become a source of burnout. I don’t even think I have readers out there, but I figured it would be worth sharing my thoughts on the matter rather than just disappearing. I will still blog from time to time, but I will no longer put the pressure on myself to do it weekly. With that, I am going to go spend time with my family.</summary></entry><entry><title type="html">Perl Weekly Challenge 115</title><link href="http://localhost:4000/blog/perl-weekly-challenge-115/" rel="alternate" type="text/html" title="Perl Weekly Challenge 115" /><published>2021-06-07T00:00:00-05:00</published><updated>2021-06-07T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-115</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-115/">&lt;p&gt;I had a very busy weekend and didn’t get the opportunity to post this during the actual week of the challenge, but I will post both 115 and 116 today!&lt;/p&gt;

&lt;h2 id=&quot;task-1-string-chain&quot;&gt;Task 1: String Chain&lt;/h2&gt;

&lt;p&gt;You are given an array of strings.&lt;/p&gt;

&lt;p&gt;Write a script to find out if the given strings can be chained to form a circle. Print 1 if found otherwise 0.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A string $S can be put before another string $T in circle if the last character of $S is same as first character of $T.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @S = (&quot;abc&quot;, &quot;dea&quot;, &quot;cd&quot;)
Output: 1 as we can form circle e.g. &quot;abc&quot;, &quot;cd&quot;, &quot;dea&quot;.

Input: @S = (&quot;ade&quot;, &quot;cbd&quot;, &quot;fgh&quot;)
Output: 0 as we can't form circle.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@S) returns Int {
  my @solutions = @S.race.permutations.grep: -&amp;gt; @permutation { # [1][2]
    my $valid = True;
    for @permutation Z (|@permutation[1..*], @permutation.head) -&amp;gt; ($a, $b) { # [3]
      if $a.comb.tail ne $b.comb.head {
        $valid = False;
        last;
      }
    }
    $valid;
  }
  (@solutions.elems &amp;gt; 0).Int;
}

sub MAIN(*@S where all(@S) ~~ Str) {
  say challenge(@S);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku abc dea cd
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;For this problem, we start by finding all the permutations of our input. So for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&quot;abc&quot;, &quot;dea&quot;, &quot;cd&quot;)&lt;/code&gt; we would get &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((abc dea cd) (abc cd dea) (dea abc cd) (dea cd abc) (cd abc dea) (cd dea abc))&lt;/code&gt;. We then take each one individually and compare each element pairwise. Since the last element needs to be compared to the first element, we have the special zip discussed in #3 below. If the last element of each string matches the first element of the next string, then we have a valid chain; otherwise, we exit early. Finally, we convert the boolean &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@solutions.elems &amp;gt; 0&lt;/code&gt; to an integer to match the problem.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;We can process each permutation separately and order does not matter, so we convert our input to a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RaceSeq&lt;/code&gt; as early as possible.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;permutations&lt;/code&gt; only works for positionals with size &amp;lt; 20, or else it will blow up the stack.&lt;/li&gt;
  &lt;li&gt;If we have the list &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a, b, c)&lt;/code&gt; here, what we are trying to generate is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((a, b), (b, c), (c, a))&lt;/code&gt;. In Scala, this could be written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(list :+ list.head).sliding(2)&lt;/code&gt;, but Raku doesn’t have that functionality, so this line does the same thing by creating a second list with the first element moved to the end, &lt;em&gt;and then&lt;/em&gt; zipping.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-largest-multiple&quot;&gt;Task 2: Largest Multiple&lt;/h2&gt;

&lt;p&gt;You are given a list of positive integers (0-9), single digit.&lt;/p&gt;

&lt;p&gt;Write a script to find the largest multiple of 2 that can be formed from the list.&lt;/p&gt;

&lt;h3 id=&quot;examples-1&quot;&gt;Examples&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @N = (1, 0, 2, 6)
Output: 6210

Input: @N = (1, 4, 2, 8)
Output: 8412

Input: @N = (4, 1, 7, 6)
Output: 7614
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-115/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@N) returns Int {
  @N.race.permutations.map(*.join.Int).grep(* %% 2).max; # [1]
}

sub MAIN(*@N where all(@N) ~~ /^&amp;lt;digit&amp;gt;$/) { # [2]
  say challenge(@N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 1 0 2 6
6210
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Once again, we find all the permutations and then map all of them to integers. We then filter them to only numbers divisible by 2, and then find the max. Easy peasy!&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Raku has a cool built-in operator for “divisible by” which comes in handy in these situations.&lt;/li&gt;
  &lt;li&gt;The question says to only accept positive integers between 0 and 9, in other words, a digit, so we enforce that at runtime using this regex.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Permutations and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RaceSeq&lt;/code&gt; make for fairly efficient and readable solutions this week! See y’all in Challenge 116.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">I had a very busy weekend and didn’t get the opportunity to post this during the actual week of the challenge, but I will post both 115 and 116 today!</summary></entry><entry><title type="html">Perl Weekly Challenge 116</title><link href="http://localhost:4000/blog/perl-weekly-challenge-116/" rel="alternate" type="text/html" title="Perl Weekly Challenge 116" /><published>2021-06-07T00:00:00-05:00</published><updated>2021-06-07T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-116</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-116/">&lt;p&gt;Part 1 was probably the hardest this week, but I ended up being able to adapt a solution from an existing Python library.&lt;/p&gt;

&lt;h2 id=&quot;task-1-number-sequence&quot;&gt;Task 1: Number Sequence&lt;/h2&gt;

&lt;p&gt;You are given a number &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N &amp;gt;= 10&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to split the given number such that the difference between two consecutive numbers is always 1 and it shouldn’t have leading 0.&lt;/p&gt;

&lt;p&gt;Print the given number if it’s impossible to split the number.&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $N = 1234
Output: 1,2,3,4

Input: $N = 91011
Output: 9,10,11

Input: $N = 10203
Output: 10203 as it is impossible to split satisfying the conditions.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-116/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Raku adaptation of Python's more-itertools.partitions: https://git.io/JZL8Q
sub partitions(Str $S) {
  my @sequence = $S.comb;
  my $n = @sequence.elems;
  my @partitions = gather for (1..^$n).combinations -&amp;gt; @combination {
    my @partition = gather for (0, |@combination) Z (|@combination, $n) -&amp;gt; ($i, $j) {
      take [@sequence[$i..^$j]];
    }
    take @partition;
  }
  gather for @partitions -&amp;gt; @partition {
    # Filter out elements with leading zeros
    my @invalid = @partition.grep(*.head eq '0');
    if @invalid.elems == 0 {
      take @partition.map(*.join.Int);
    }
  }
}

sub challenge(Int $N where $N &amp;gt;= 10) returns Str {
  my $S = $N.Str;
  my $solution = partitions($S).first: -&amp;gt; @partition {         # [1]
    my @zipped = @partition[0..*-1] Z @partition[1..*];        # [2]
    my @filtered = @zipped.grep(-&amp;gt; ($a, $b) { $b - $a == 1 }); # [3]
    @zipped.elems &amp;gt; 0 &amp;amp;&amp;amp; @zipped.elems == @filtered.elems;     # [4]
  }

  with $solution { # [5]
    $solution.join(',');
  } else {
    $S
  }
}

sub MAIN(Int $N) {
  say challenge($N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 1234
1,2,3,4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I won’t focus on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;partitions&lt;/code&gt; function too much, as it is just a means to and end. At a high level, it takes a string (let’s say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1234&lt;/code&gt;) and returns a list that looks like this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((1234) (1 234) (12 34) (123 4) (1 2 34) (1 23 4) (12 3 4) (1 2 3 4))&lt;/code&gt;; basically every permutation of every size split possible (with order maintained). Once we have that list of partitions, we want to find the first one that satisfies our condition – each element is 1 less than the next element. If we found one, return it as a comma-separated string. Otherwise, return the input.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first&lt;/code&gt; is kind of like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;collectFirst&lt;/code&gt; in Scala; it will return either the element that matches the condition or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; if nothing matches.&lt;/li&gt;
  &lt;li&gt;To compare our elements pairwise, we need to zip them up like so. In Scala this could be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;partition.init.zip(partition.tail)&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;partition.sliding(2)&lt;/code&gt;, but again, Raku doesn’t have those cool functions.&lt;/li&gt;
  &lt;li&gt;Now that we have the zipped up, we filter it to down to elements that match our condition.&lt;/li&gt;
  &lt;li&gt;Finally, if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@filtered&lt;/code&gt; didn’t remove anything, then this is a winner! We also need to check if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@zipped&lt;/code&gt; is non-empty, because a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@partition&lt;/code&gt; of size 1 will cause that.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; is the same as saying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if $solution.defined&lt;/code&gt;, since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$solution&lt;/code&gt; can be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-sum-of-squares&quot;&gt;Task 2: Sum of Squares&lt;/h2&gt;

&lt;p&gt;You are given a number &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N &amp;gt;= 10&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to find out if the given number &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; is such that sum of squares of all digits is a perfect square. Print 1 if it is otherwise 0.&lt;/p&gt;

&lt;h3 id=&quot;examples-1&quot;&gt;Examples&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $N = 34
Ouput: 1 as 3^2 + 4^2 =&amp;gt; 9 + 16 =&amp;gt; 25 =&amp;gt; 5^2

Input: $N = 50
Output: 1 as 5^2 + 0^2 =&amp;gt; 25 + 0 =&amp;gt; 25 =&amp;gt; 5^2

Input: $N = 52
Output: 0 as 5^2 + 2^2 =&amp;gt; 25 + 4 =&amp;gt; 29
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-116/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Int $N where $N &amp;gt;= 10) returns Int {
  my $square-sum = $N.comb.map(*²).sum;     # [1][2]
  $square-sum.sqrt.narrow ~~ Int ?? 1 !! 0; # [3]
}

sub MAIN(Int $N) {
  say challenge($N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 34
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;We convert the input number to a list of digits, then square each digit, then sum all the squares. We then check if the sum of squares is an integer (i.e., a perfect square). If so, we return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;, else &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;I like the first part support of Unicode in Raku. It makes it very clear we are squaring each element of a list.&lt;/li&gt;
  &lt;li&gt;I don’t like this – this takes 2 passes (one for squaring and one for summing). In Scala, I would write &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list.foldLeft(0)((runningSum, elem) =&amp;gt; runningSum + math.pow(elem, 2))&lt;/code&gt;, which only takes one pass. However, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;math.pow&lt;/code&gt; is uglier than it is in Raku, so you win some you lose some.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;narrow&lt;/code&gt; returns the most granular numerical type that this number matches (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sqrt&lt;/code&gt; returns a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Numeric&lt;/code&gt;). If it is an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;, this is a perfect square.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Two fun challenges this week! Glad I am ahead of the curve and won’t be behind due to a busy weekend this week.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Part 1 was probably the hardest this week, but I ended up being able to adapt a solution from an existing Python library.</summary></entry><entry><title type="html">Perl Weekly Challenge 114</title><link href="http://localhost:4000/blog/perl-weekly-challenge-114/" rel="alternate" type="text/html" title="Perl Weekly Challenge 114" /><published>2021-05-28T00:00:00-05:00</published><updated>2021-05-28T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-114</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-114/">&lt;p&gt;Both of this week’s solutions look remarkably similar, because we were able to utilize the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first&lt;/code&gt; subroutine for each one!&lt;/p&gt;

&lt;h2 id=&quot;task-1-next-palindrome-number&quot;&gt;Task 1: Next Palindrome Number&lt;/h2&gt;

&lt;p&gt;You are given a positive integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to find out the next Palindrome Number higher than the given integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $N = 1234
Output: 1331

Input: $N = 999
Output: 1001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-114/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Int $N) returns Int {
  ($N^..Inf).first(-&amp;gt; $num { $num == $num.flip }, :v); # [1][2][3]
}

sub MAIN(Int $N) {
  say challenge($N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 1234
1331
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This is fairly straightforward; we create an infinite range from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; to infinity. This range will be lazily evaluated, so we don’t have to worry about memory. Then we find the first instance where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$num&lt;/code&gt; is equal to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$num.flip&lt;/code&gt;. That’s it!&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Ranges are lazily evaluated, so it is safe to have these seemingly infinite range constructors.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$num.flip&lt;/code&gt; &lt;em&gt;technically&lt;/em&gt; returns a string, but &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt; will coerce it to an integer (since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eq&lt;/code&gt; should be used for string equality). This is convenient, but also kind of scary that conversions are happening without us knowing.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first&lt;/code&gt; returns both the index and value of that index by default. Since we only want the value, we pass in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:v&lt;/code&gt; flag to specify that.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-higher-integer-set-bits&quot;&gt;Task 2: Higher Integer Set Bits&lt;/h2&gt;

&lt;p&gt;You are given a positive integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to find the next higher integer having the same number of 1 bits in binary representation as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $N = 3
Output: 5

Binary representation of $N is 011. There are two 1 bits. So the next higher integer is 5 having the same the number of 1 bits i.e. 101.

Input: $N = 12
Output: 17

Binary representation of $N is 1100. There are two 1 bits. So the next higher integer is 17 having the same number of 1 bits i.e. 10001.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-114/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub bits(Int $base-ten) returns Int {
  $base-ten.base(2).comb.grep(* eq '1').elems; # [1][2][3][4]
}

sub challenge(Int $N where $N &amp;gt; 0) returns Int {
  my $bits = bits($N);
  ($N^..Inf).first(-&amp;gt; $num { bits($num) == $bits }, :v);
}

sub MAIN(Int $N) {
  say challenge($N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 12
17
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The meat of this lies in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bits&lt;/code&gt; function. It finds the number of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; bits for a given integer. Given that, we again construct a range from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; to infinity and find the first number that has the same number of bits as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/base&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base&lt;/code&gt;&lt;/a&gt; is a cool function to convert a number to any other base. So &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;9.base(3) eq '100'&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;255.base(16) eq 'FF'&lt;/code&gt;. We use it to convert base 10 to base 2.&lt;/li&gt;
  &lt;li&gt;Once we have it in base 2, we need to convert it to a list of digits, so we use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comb&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Once it has been converted to a list of digits, we filter (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt;) for digits that equal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;. Since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base&lt;/code&gt; converted to a string, we use string equality (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eq&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Finally, we just count the elements that equal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;elems&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Lazy evaluation is one of the pillars of functional programming, so it is cool to see it exist in Raku. Always happy when I can break these down into a line or two!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Both of this week’s solutions look remarkably similar, because we were able to utilize the first subroutine for each one!</summary></entry><entry><title type="html">Perl Weekly Challenge 112</title><link href="http://localhost:4000/blog/perl-weekly-challenge-113/" rel="alternate" type="text/html" title="Perl Weekly Challenge 112" /><published>2021-05-22T00:00:00-05:00</published><updated>2021-05-22T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-113</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-113/">&lt;p&gt;Task 1 allowed for some functional programming using some cool built-ins in Raku. Task 2 built on some code I wrote for &lt;a href=&quot;https://aaronreidsmith.github.io/blog/perl-weekly-challenge-094/#task-2-binary-tree-to-linked-list&quot;&gt;Challenge 94&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;task-1-represent-integer&quot;&gt;Task 1: Represent Integer&lt;/h2&gt;

&lt;p&gt;You are given a positive integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; and a digit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$D&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to check if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; can be represented as a sum of positive integers having &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$D&lt;/code&gt; at least once. If check passes print 1 otherwise 0.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $N = 25, $D = 7
Output: 0 as there are 2 numbers between 1 and 25 having the digit 7 i.e. 7 and 17. If we add up both we don't get 25.

Input: $N = 24, $D = 7
Output: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-113/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset PositiveInt of Int where * &amp;gt; 0; # [1]

sub challenge(PositiveInt $N, PositiveInt $D) returns Int {
  my $output = (1..^$N)   # [2]
    .race                 # [3]
    .grep(*.contains($D)) # [4]
    .combinations(2..*)   # [5]
    .map(*.sum)           # [6]
    .any == $N;           # [7]
  $output.Bool.Int;       # [8]
}

sub MAIN(PositiveInt $N, PositiveInt $D) {
  say challenge($N, $D);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 24 7
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This function first generates a list of integers from 0 to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N - 1&lt;/code&gt; (no need to include 0 or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; itself, since 0 is not positive and. we want things that add up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;). It then filters those down to only numbers that contain &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$D&lt;/code&gt;. It then finds all combinations of size 2 or larger to evaluate, and finds the sum of those combinations. Finally, it simply checks if any of the sums add up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;. I like that we can easily just chain these methods together; makes it very easy to read.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;The question says we should only allow positive integers. To do this, we can easily create a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subset&lt;/code&gt; of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; and add a condition using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;where&lt;/code&gt; (in this case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;where * &amp;gt; 0&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;As mentioned above, no need to include &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;, so we filter them using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;..^&lt;/code&gt; range creator. It includes the bottom number and excludes the top number.&lt;/li&gt;
  &lt;li&gt;We don’t need this list in any order, since we will end up with a boolean (and eventually integer) at the end. So we want to perform all of our actions as quickly as possible, and we don’t care about order. &lt;a href=&quot;https://docs.raku.org/routine/race&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;race&lt;/code&gt;&lt;/a&gt; creates a &lt;a href=&quot;https://docs.raku.org/type/RaceSeq&quot;&gt;RaceSeq&lt;/a&gt;, which allows us to process a list in parallel without regards to order.&lt;/li&gt;
  &lt;li&gt;We filter (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt;) down to numbers that contains &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$D&lt;/code&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contains&lt;/code&gt; coerces the left-hand argument to a String, so this is the same as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.Str.contains($d)&lt;/code&gt;. This is actually a documented &lt;a href=&quot;https://docs.raku.org/language/traps#Lists_become_strings,_so_beware_.contains()&quot;&gt;trap&lt;/a&gt; that I &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-04/&quot;&gt;fell into&lt;/a&gt; during Advent of Code, but it works in my favor this time.&lt;/li&gt;
  &lt;li&gt;We want to examine all combinations of size 2 or larger, which can easily be created using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2..*&lt;/code&gt; syntax.&lt;/li&gt;
  &lt;li&gt;Once we have all the combinations, it is a simple matter to find their sums by mapping over each combination (and using the built-in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum&lt;/code&gt; method).&lt;/li&gt;
  &lt;li&gt;Once we have a list of sums, we want to see if &lt;em&gt;any&lt;/em&gt; equal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;. So we just call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.any&lt;/code&gt; on the list and get our answer!&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;any&lt;/code&gt; returns a &lt;a href=&quot;https://docs.raku.org/routine/any&quot;&gt;Junction&lt;/a&gt;, so we have to coerce it to a boolean, and then an integer to get the output that the challenge expects.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-recreate-binary-tree&quot;&gt;Task 2: Recreate Binary Tree&lt;/h2&gt;

&lt;p&gt;You are given a Binary Tree.&lt;/p&gt;

&lt;p&gt;Write a script to replace each node of the tree with the sum of all the remaining nodes.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example&lt;/h3&gt;

&lt;h4 id=&quot;input-binary-tree&quot;&gt;Input Binary Tree&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        1
       / \
      2   3
     /   / \
    4   5   6
     \
      7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;output-binary-tree&quot;&gt;Output Binary Tree&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        27
       /  \
      26  25
     /   /  \
    24  23  22
     \
     21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-113/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset NodeValue of Str where { $_ ~~ /^&amp;lt;digit&amp;gt;$/ || $_ eq 'Nil' }

class Node {
  has Node $.left  is rw = Nil;
  has Node $.right is rw = Nil;
  has Int  $.value is rw = 0;
}

# Adapted from https://rosettacode.org/wiki/Visualize_a_tree#Raku
sub format-tree(
  Node $root,
  Str :$indent = '',
  :@mid = ('├─', '│ '),
  :@end = ('└─', '  ')
) returns Str {
  sub visit(Node $node, *@pre) {
    with $node {
      |gather {
        take @pre[0] ~ $node.value;
        my @children = ($node.right, $node.left).grep(*.defined);
        my $end = @children.end;
        for @children.kv -&amp;gt; $_, $child {
          when $end { take visit($child, (@pre[1] X~ @end)) }
          default   { take visit($child, (@pre[1] X~ @mid)) }
        }
      }
    }
  }
  visit($root, $indent xx 2).join(&quot;\n&quot;);
}

sub build-tree(@array, $root is copy = Nil, Int $i = 0) returns Node {
  if $i &amp;lt; @array.elems &amp;amp;&amp;amp; @array[$i] ne 'Nil' {
    $root       = Node.new(value =&amp;gt; @array[$i].Int);
    $root.left  = build-tree(@array, $root.left, 2 * $i + 1);
    $root.right = build-tree(@array, $root.right, 2 * $i + 2);
  }
  $root;
}

sub challenge(Node $root is copy, @values = ()) returns Node {
  sub extract-values(Node $root) returns Positional {                           # [1]
    with $root {                                                                # [2]
      ($root.value, |extract-values($root.left), |extract-values($root.right)); # [3]
    }
  }

  with $root {
    my @node-values = @values.elems &amp;gt; 0 ?? @values !! extract-values($root); # [4]
    $root.value = @node-values.grep(* != $root.value).sum;                   # [5]
    challenge($root.left, @node-values);                                     # [6]
    challenge($root.right, @node-values);
  }
  $root;
}

sub MAIN(*@nodes where all(@nodes) ~~ NodeValue) {
  my $root = build-tree(@nodes);
  say format-tree(challenge($root));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 1 2 3 4 Nil 5 6 Nil 7 Nil Nil
27
├─25
│ ├─22
│ └─23
└─26
  └─24
    └─21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I will only be discussing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; subroutine, as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build-tree&lt;/code&gt; was written in my Challenge 94 blog, along with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeValue&lt;/code&gt; subset and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt; class. Additionally, I couldn’t find a good way to actually print this tree out, so I copied &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;format-tree&lt;/code&gt; from &lt;a href=&quot;https://rosettacode.org/wiki/Visualize_a_tree#Raku&quot;&gt;Rosetta Code&lt;/a&gt;; it has some issues (the 24 is not obvious that it is the left branch), but it works overall.&lt;/p&gt;

&lt;p&gt;As for the actual &lt;em&gt;new&lt;/em&gt; code that I wrote, given a tree, we simply need to traverse it once to find the values (storing it in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@node-values&lt;/code&gt;). Then, traverse it a second time and changing the values at each node to the sum of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@node-values&lt;/code&gt; excluding the current value. So for the root node, it would be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@node-values.grep(* != 1).sum&lt;/code&gt;. Once we have done that, since we changed the tree in place, we can just return the root.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;This is defined within &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; because it is not really needed outside of it. Additionally, this logic can’t be included as part of the main flow of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; since we use a copy of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$root&lt;/code&gt;. Since we traverse recursively, our list of values would be different on each recursive call.&lt;/li&gt;
  &lt;li&gt;This &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; guard prevents us from trying to run the logic/recurse even more if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$root&lt;/code&gt; is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;This is a simple prefix traversal (where we visit the current node, then left, then right). Since we have the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; guard, this will prevent &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; values. So for the example input we would end up with this list: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 2, 3, 4, 5, 6, 7)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;We only want to call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extract-values&lt;/code&gt; on the first call (since the tree is constantly changing), so we only run it if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@values&lt;/code&gt; is empty (and then pass in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@node-values&lt;/code&gt; on subsequent calls).&lt;/li&gt;
  &lt;li&gt;Like I showed above, we just need to sum all the values are not &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$root.value&lt;/code&gt;. Another way to do this would have been &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@node-values.sum - $root.value&lt;/code&gt;, which honestly might have been faster since it doesn’t require traversing twice. Oh well!&lt;/li&gt;
  &lt;li&gt;These recursive calls will &lt;em&gt;technically&lt;/em&gt; return their &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$root&lt;/code&gt;, but since they aren’t assigned to anything, they are just ignored.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;The hardest part of this week’s challenge was honestly trying to find a way to print a binary tree! I tried translating some algorithms from other languages, and eventually settled on the one I used. Let me know if there are any good ones out there!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Task 1 allowed for some functional programming using some cool built-ins in Raku. Task 2 built on some code I wrote for Challenge 94.</summary></entry><entry><title type="html">Perl Weekly Challenge 112</title><link href="http://localhost:4000/blog/perl-weekly-challenge-112/" rel="alternate" type="text/html" title="Perl Weekly Challenge 112" /><published>2021-05-15T00:00:00-05:00</published><updated>2021-05-15T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-112</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-112/">&lt;p&gt;A little string manipulation and recursion today. My solution to task 2 is &lt;em&gt;almost&lt;/em&gt; the same as my solution to &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-10/&quot;&gt;Advent of Code 2020: Day 10 (part 2)&lt;/a&gt;!&lt;/p&gt;

&lt;h2 id=&quot;task-1-canonical-path&quot;&gt;Task 1: Canonical Path&lt;/h2&gt;

&lt;p&gt;You are given a string path, starting with a slash ‘/’.&lt;/p&gt;

&lt;p&gt;Write a script to convert the given absolute path to the simplified canonical path.&lt;/p&gt;

&lt;p&gt;In a Unix-style file system:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- A period '.' refers to the current directory
- A double period '..' refers to the directory up a level
- Multiple consecutive slashes ('//') are treated as a single slash '/'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The canonical path format:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- The path starts with a single slash '/'.
- Any two directories are separated by a single slash '/'.
- The path does not end with a trailing '/'.
- The path only contains the directories on the path from the root directory to the target file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: &quot;/a/&quot;
Output: &quot;/a&quot;

Input: &quot;/a/b//c/&quot;
Output: &quot;/a/b/c&quot;

Input: &quot;/a/b/c/../..&quot;
Output: &quot;/a&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-112/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Str $path is copy) returns Str {                  # [1]
  die &quot;Must be an absolute path&quot; unless $path.starts-with('/'); # [2]
  
  $path = $path.substr(1);                              # [3]
  $path = $path.subst(/\/ ** 2..*/, '/', :global);      # [4][5]
  $path = $path.substr(0, *-1) if $path.ends-with('/'); # [6]

  my @output;
  for $path.split('/') -&amp;gt; $dir {
    given $dir {
      when '.' { Nil }                            # [7]
      when '..' {
        die &quot;Illegal path&quot; if @output.elems == 0;
        @output.pop;
      }
      default { @output.push($dir) }
    }
  }
  '/' ~ @output.join('/')
}

sub MAIN(Str $path) {
  say challenge($path);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku /a/b//c
/a/b/c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;We basically just follow the following steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Does the path start with a slash?
    &lt;ul&gt;
      &lt;li&gt;If yes, remove it and continue.&lt;/li&gt;
      &lt;li&gt;If not, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;die&lt;/code&gt;, since the problem indicates we are given a path starting with a slash.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Replace any duplicate slashes with a single slash.&lt;/li&gt;
  &lt;li&gt;Remove the trailing slash if it exists.&lt;/li&gt;
  &lt;li&gt;We should now have something that looks like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a/b/c&lt;/code&gt; and we split it into a list that looks like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a, b, c)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Iterate through the above list and take one of three actions depending on what item we encounter:
    &lt;ul&gt;
      &lt;li&gt;If we hit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.&lt;/code&gt;, it is just redundant and we can continue.&lt;/li&gt;
      &lt;li&gt;If we hit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;..&lt;/code&gt;, we need to remove the most recent item from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt;. As a caveat, if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt; is empty and we encounter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;..&lt;/code&gt;, it will throw an error.&lt;/li&gt;
      &lt;li&gt;If we hit anything else (i.e., a normal directory), we can just add it to the end of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Finally, we just join &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt; into a path using slashes, and prepend a slash onto it to make it an absolute path.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Since we are mutating &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$path&lt;/code&gt; within the subroutine, we need to declare it as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is copy&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The question says our input must start with a slash. So we die &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unless&lt;/code&gt; it has the correct input.&lt;/li&gt;
  &lt;li&gt;If we reach this line, that means the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$path&lt;/code&gt; &lt;em&gt;does&lt;/em&gt; start with a slash, and we need to remove it using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;substr&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;We want to replace any instance where there are two or more slashes in a row. That is what this regex means &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/\/ ** 2..*/&lt;/code&gt;; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\/&lt;/code&gt; means “literal slash” and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2..*&lt;/code&gt; means “two or more times.” We replace all of these instances with a single slash, and we want to do it for the whole string, hence &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:global&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;As an aside, I hate that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;substr&lt;/code&gt; (substring) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subst&lt;/code&gt; (substitute) are so close in spelling. I feel the former should be named &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slice&lt;/code&gt; and the latter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replace&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;If our path ends with a slash, we want to remove it so that when we &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;split&lt;/code&gt; we don’t get an empty entry.&lt;/li&gt;
  &lt;li&gt;Don’t really know if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; is the right thing to do here. In Scala, it would just be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;case &quot;.&quot; =&amp;gt;&lt;/code&gt; with nothing on the right-hand side of the arrow. I figured an empty block or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; is safe since we don’t want this case to fall into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-climb-stairs&quot;&gt;Task 2: Climb Stairs&lt;/h2&gt;

&lt;p&gt;You are given &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; steps to climb&lt;/p&gt;

&lt;p&gt;Write a script to find out the distinct ways to climb to the top. You are allowed to climb either 1 or 2 steps at a time.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $n = 3
Output: 3

    Option 1: 1 step + 1 step + 1 step
    Option 2: 1 step + 2 steps
    Option 3: 2 steps + 1 step

Input: $n = 4
Output: 5

    Option 1: 1 step + 1 step + 1 step + 1 step
    Option 2: 1 step + 1 step + 2 steps
    Option 3: 2 steps + 1 step + 1 step
    Option 4: 1 step + 2 steps + 1 step
    Option 5: 2 steps + 2 steps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-112/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use experimental :cached; # [1]

sub challenge(
  $max where Int,
  @paths where Positional = (^$max), # [2][3]
  $current-step where Int = 0
) is cached {
  given $current-step {
    when * == $max { 1 }
    when * &amp;gt; $max  { 0 }
    default {
      challenge($max, @paths, $current-step + 1) +
      challenge($max, @paths, $current-step + 2)
    }
  }
}

sub MAIN(Int $n) {
  say challenge($n);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 4
5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This one is actually pretty straight forward, even if it doesn’t seem as such. Basically, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; will construct a list from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0..^$n&lt;/code&gt;; so for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n = 3&lt;/code&gt; we would get &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(0, 1, 2)&lt;/code&gt;. Starting at step &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; we check 2 conditions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Are we at the top of the steps? If so, stop and mark this path as valid (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Are we &lt;em&gt;above&lt;/em&gt; the top of the steps? If so, stop and mark this path as &lt;em&gt;invalid&lt;/em&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If we don’t match either of the above conditions, we try &lt;em&gt;both&lt;/em&gt; a step size of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; recursively. So essentially this is a brute force approach, but it is efficient because we have memoized our subroutine using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is cached&lt;/code&gt; trait. This means that once it has done the computation for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge(3, (0, 1, 2), 2)&lt;/code&gt;, the next time it sees that same input, it will always return the same result. Since a step size of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; will have some overlap in individual steps, this makes this approach incredibly efficient.&lt;/p&gt;

&lt;p&gt;Since the end conditions only return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt; block actually handles summing the valid paths.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is cached&lt;/code&gt; is an experimental feature and needs to be explicitly imported.&lt;/li&gt;
  &lt;li&gt;Normally you see me write &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int $foo&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$foo where Int&lt;/code&gt;. This fails for positionals and hashes; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int @foo&lt;/code&gt; indicates a &lt;em&gt;positional of ints&lt;/em&gt; (since the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@&lt;/code&gt; sigil already indicates it is a positional). So why didn’t I just do that? I tried. It fails with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expected Positional[Int] but got Range (^10)&lt;/code&gt;, which I think is stupid. So this is a way to &lt;em&gt;kind of&lt;/em&gt; strongly-type it; better than nothing I guess.&lt;/li&gt;
  &lt;li&gt;I think it is cool that I can use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$max&lt;/code&gt; in the default of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@paths&lt;/code&gt; here!&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Pretty easy this week, but that is mostly because I was able to copy an older solution of mine for task two. Should I have done something new/different? Probably, but oh well. See y’all next week!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">A little string manipulation and recursion today. My solution to task 2 is almost the same as my solution to Advent of Code 2020: Day 10 (part 2)!</summary></entry><entry><title type="html">Perl Weekly Challenge 111</title><link href="http://localhost:4000/blog/perl-weekly-challenge-111/" rel="alternate" type="text/html" title="Perl Weekly Challenge 111" /><published>2021-05-08T00:00:00-05:00</published><updated>2021-05-08T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-111</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-111/">&lt;p&gt;I was apparently &lt;a href=&quot;https://perlweeklychallenge.org/blog/meet-the-champion-2021-04/&quot;&gt;the champion&lt;/a&gt; of the &lt;em&gt;Perl Weekly Challenge&lt;/em&gt; for last month, which is pretty cool! I encourage folks to go read my interview with Mohammad Anwar, who runs the &lt;em&gt;Perl Weekly Challenge&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;task-1-search-matrix&quot;&gt;Task 1: Search Matrix&lt;/h2&gt;

&lt;p&gt;You are given 5x5 matrix filled with integers such that each row is sorted from left to right, and the first integer of each row is greater than the last integer of the previous row.&lt;/p&gt;

&lt;p&gt;Write a script to find a given integer in the matrix using an efficient search algorithm.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Matrix: [  1,  2,  3,  5,  7 ]
        [  9, 11, 15, 19, 20 ]
        [ 23, 24, 25, 29, 31 ]
        [ 32, 33, 39, 40, 42 ]
        [ 45, 47, 48, 49, 50 ]

Input: 35
Output: 0 since it is missing in the matrix

Input: 39
Output: 1 as it exists in the matrix
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-111/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@list-of-lists, Int $N) returns Int {
  my $output = 0;
  for (0..^@list-of-lists.end) Z (0^..@list-of-lists.end) -&amp;gt; ($i, $j) { # [1]
    if @list-of-lists[$i].head == $N || @list-of-lists[$j].head == $N { # [2]
      $output = 1;
      last;
    } elsif @list-of-lists[$i].head &amp;lt; $N &amp;lt; @list-of-lists[$j].head {
      $output = (any(@list-of-lists[$i][1..*]) ~~ $N).Int;              # [3]
      last;
    } elsif $j == @list-of-lists.end &amp;amp;&amp;amp; $N &amp;gt; @list-of-lists[$j].head {  # [4]
      $output = (any(@list-of-lists[$j][1..*]) ~~ $N).Int;
      last;
    }
  }
  $output;
}

sub MAIN(Int $N) {
  my @list-of-lists = (   # [5]
    ( 1,  2,  3,  5,  7),
    ( 9, 11, 15, 19, 20),
    (23, 24, 25, 29, 31),
    (32, 33, 39, 40, 42),
    (45, 47, 48, 49, 50)
  );
  say challenge(@list-of-lists, $N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 35
0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I don’t know if this is the most efficient method, but it is &lt;em&gt;an&lt;/em&gt; efficient method, which is what the question calls for. The naive solution would be something like this, which has a complexity of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(n+k)&lt;/code&gt; where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; is the number of elements total (25) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt; is the cost of flattening the structure (likely just 4 appends).&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;any(@list-of-lists.flat) ~~ $N
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;My approach, instead, looks at the first element of each sublist to determine if it should even bother looking in that sublist. If so, it will drop down and check items 2 through 5 of the sublist (I assume this happens in order using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;any&lt;/code&gt;). if not, it will skip the list entirely and jump to the next sublist.&lt;/p&gt;

&lt;p&gt;I &lt;em&gt;think&lt;/em&gt; my approach has a complexity of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(n+k)&lt;/code&gt; where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; is the number of sub-lists (5) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt; is the number of elements in that list (minus the first one, so 4). So we will &lt;em&gt;at most&lt;/em&gt; do 9 checks and be able to determine if the item exists in a sublist. On average, we will have fewer checks than that.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;This looks complex, but this is just making a list that looks like this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((0, 1), (1, 2), (2, 3), (3, 4))&lt;/code&gt; so that we can look at two sublists at a time. The second sublist is necessary so we can check the top end of the range easily.&lt;/li&gt;
  &lt;li&gt;Check the head of the first list and head of the second sublist to see if we can skip searching a sublist.&lt;/li&gt;
  &lt;li&gt;If it is in the range of a sublist, we can drop into it and use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;any&lt;/code&gt;, which I am pretty sure just searches from left to right. At most this will search all 4 elements (we skip the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; item), and will end early if it finds the element.&lt;/li&gt;
  &lt;li&gt;If this is the last iteration and we still haven’t found &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;, we need to drop into the last sublist, just for full coverage.&lt;/li&gt;
  &lt;li&gt;We could set this up to be dynamic and passed in at run time, but I figured it would be okay to hardcode for our purposes.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-ordered-letters&quot;&gt;Task 2: Ordered Letters&lt;/h2&gt;

&lt;p&gt;Given a word, you can sort its letters alphabetically (case-insensitive). For example, “beekeeper” becomes “beeeeekpr” and “dictionary” becomes “acdiinorty”.&lt;/p&gt;

&lt;p&gt;Write a script to find the longest English words that don’t change when their letters are sorted.&lt;/p&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-111/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use LibCurl::HTTP :subs; # Imports jget

sub get-english-words {
  my %words = jget('https://raw.githubusercontent.com/dwyl/english-words/master/words_dictionary.json'); # [1]
  %words.keys;                                                                                           # [2]
}

sub challenge(Int $threshold) {
  my @words = get-english-words;
  my @matching-words = gather for @words.race -&amp;gt; $word {         # [3]
    my @chars = $word.comb;
    if @chars.elems &amp;gt;= $threshold &amp;amp;&amp;amp; @chars.sort.join eq $word { # [4]
      take $word;
    }
  }
  @matching-words.sort;
}

multi sub MAIN(Int $threshold = 7) { # [5]
  for challenge($threshold) -&amp;gt; $word {
    say $word;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku
adelops
aegilops
alloquy
beefily
begorry
belloot
billowy
deglory
egilops
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;So this question is pretty vague. The first problem we have is, how do we get a list of all English words? Rather than ship a text file around with my code, we can pull some at run time from an API. I couldn’t find a decent free API, so I just found &lt;a href=&quot;https://github.com/dwyl/english-words&quot;&gt;this GitHub repo&lt;/a&gt; that has a JSON file full of words. Does it have all the words? I have no idea, but it will certainly work for our purposes.&lt;/p&gt;

&lt;p&gt;Basically, once that is pulled down, we just split each word into characters, sort them, and compare them to the original word. However, we check against &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$threshold&lt;/code&gt; first, so we don’t do the expensive computation on every word.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Passing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:sub&lt;/code&gt; flag to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;use LibCurl:HTTP&lt;/code&gt; imports its individual subroutines, including &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jget&lt;/code&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jget&lt;/code&gt; calls the URL and unpacks the returns JSON into a hash.&lt;/li&gt;
  &lt;li&gt;I don’t know why the author of the above GitHub repo chose this format, but instead of using a JSON array, they used a format like this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&quot;word&quot;: 1}&lt;/code&gt;, so we only need the keys.&lt;/li&gt;
  &lt;li&gt;Since we need to process all of these words, and the order doesn’t matter (since we will sort later), we can cast this list to a &lt;a href=&quot;https://docs.raku.org/type/RaceSeq&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RaceSeq&lt;/code&gt;&lt;/a&gt; that will process in parallel without definite order.&lt;/li&gt;
  &lt;li&gt;Check the threshold first, so we don’t do the expensive computation if it is short. If it passes that check, sort the characters and compare to the original word. If it also passes that check, we can take this work and add it to our output.&lt;/li&gt;
  &lt;li&gt;The question asks us to find the longest English &lt;strong&gt;words&lt;/strong&gt; (plural). The single longest word is 8 characters (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aegilops&lt;/code&gt;, which is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Aegilops&quot;&gt;genus of plant&lt;/a&gt;), so I bumped the threshold down to 7 to give the longest English &lt;strong&gt;words&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I have never gotten to do web requests in Raku, so it was fun learning about different packages for that. There is even the &lt;a href=&quot;https://cro.services/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cro&lt;/code&gt;&lt;/a&gt; project for setting up APIs; maybe I will get a chance to use that in the future. See y’all next week!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">I was apparently the champion of the Perl Weekly Challenge for last month, which is pretty cool! I encourage folks to go read my interview with Mohammad Anwar, who runs the Perl Weekly Challenge.</summary></entry><entry><title type="html">Perl Weekly Challenge 110</title><link href="http://localhost:4000/blog/perl-weekly-challenge-110/" rel="alternate" type="text/html" title="Perl Weekly Challenge 110" /><published>2021-05-01T00:00:00-05:00</published><updated>2021-05-01T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-110</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-110/">&lt;p&gt;A couple IO-related challenges this week with nice functional solutions. 🙂&lt;/p&gt;

&lt;h2 id=&quot;task-1-valid-phone-numbers&quot;&gt;Task 1: Valid Phone Numbers&lt;/h2&gt;

&lt;p&gt;You are given a text file.&lt;/p&gt;

&lt;p&gt;Write a script to display all valid phone numbers in the given text file.&lt;/p&gt;

&lt;h3 id=&quot;acceptable-phone-number-formats&quot;&gt;Acceptable Phone Number Formats&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+nn  nnnnnnnnnn
(nn) nnnnnnnnnn
nnnn nnnnnnnnnn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;input-file&quot;&gt;Input File&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0044 1148820341
 +44 1148820341
  44-11-4882-0341
(44) 1148820341
  00 1148820341
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0044 1148820341
 +44 1148820341
(44) 1148820341
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-110/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Str $file-path) returns Str {
  $file-path
    .IO
    .lines
    .grep(* ~~ /                                         # [1]
      ^                                                  # [2]
      &amp;lt;space&amp;gt;*                                           # [3]
      [\+&amp;lt;digit&amp;gt; ** 2 | \(&amp;lt;digit&amp;gt; ** 2\) | &amp;lt;digit&amp;gt; ** 4] # [4]
      &amp;lt;space&amp;gt;                                            # [5]
      &amp;lt;digit&amp;gt; ** 10                                      # [6]
      $                                                  # [7]
    /)
    .join(&quot;\n&quot;);
}

sub MAIN(Str $file-path) {
  say challenge($file-path);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku test.txt
0044 1148820341
 +44 1148820341
(44) 1148820341
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The basics here are pretty simple – for each line in the file, check if it matches our regex. If so, keep it, otherwise, drop it. Finally, join all matching lines together using the newline character. See below for comments on the regex itself.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Spaces in regexes in Raku are insignificant unless we put the &lt;a href=&quot;https://docs.raku.org/language/regexes#Sigspace&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:s&lt;/code&gt; modifier&lt;/a&gt; (or “ratchet”) in front of the opening forward slash. This allows us to break the logic up over multiple lines and even add comments.&lt;/li&gt;
  &lt;li&gt;Match the beginning of the line; this is a universal regex metacharacter.&lt;/li&gt;
  &lt;li&gt;Match zero or more spaces. The example file had different levels of space at the beginning of each line, but all of it was insignificant.&lt;/li&gt;
  &lt;li&gt;This line matches what I will call our “prefix.” It will match exactly one of the following:
    &lt;ul&gt;
      &lt;li&gt;A literal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; character follow by two digits.&lt;/li&gt;
      &lt;li&gt;A literal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&lt;/code&gt; character followed by two digits followed by a literal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;)&lt;/code&gt; character.&lt;/li&gt;
      &lt;li&gt;Four digits in a row.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Each valid phone number had a space between the prefix and the last 10 digits, so this matches a literal space.&lt;/li&gt;
  &lt;li&gt;All valid phone numbers end in exactly 10 numbers&lt;/li&gt;
  &lt;li&gt;Match the end of the line to verify there is nothing else in the matching line.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-transpose-file&quot;&gt;Task 2: Transpose File&lt;/h2&gt;

&lt;p&gt;You are given a text file.&lt;/p&gt;

&lt;p&gt;Write a script to transpose the contents of the given file.&lt;/p&gt;

&lt;h3 id=&quot;input-file-1&quot;&gt;Input File&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name,age,sex
Mohammad,45,m
Joe,20,m
Julie,35,f
Cristina,10,f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;output-1&quot;&gt;Output&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name,Mohammad,Joe,Julie,Cristina
age,45,20,35,10
sex,m,m,f,f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-110/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use Text::CSV; # Imports `csv` function

sub challenge(Str $file-path) returns Str {
  my @lines = csv(in =&amp;gt; $file-path, headers =&amp;gt; &quot;auto&quot;); # [1] 
  my $names = ('name', |@lines.map(*&amp;lt;name&amp;gt;)).join(','); # [2]
  my $ages  = ('age', |@lines.map(*&amp;lt;age&amp;gt;)).join(',');
  my $sexes = ('sex', |@lines.map(*&amp;lt;sex&amp;gt;)).join(',');
  ($names, $ages, $sexes).join(&quot;\n&quot;);                   # [3]
}

sub MAIN(Str $file-path) {
  say challenge($file-path);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku test.csv
name,Mohammad,Joe,Julie,Cristina
age,45,20,35,10
sex,m,m,f,f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The bulk of the hard work is done for us by using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text::CSV&lt;/code&gt; module. It allows us to pull the file into a list of hashes, and then do the logical work on that list. See below for how we apply the logic.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;csv&lt;/code&gt; with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;headers&lt;/code&gt; option allows us to pull the CSV file into a list of hashes that looks like this:&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [
   {age =&amp;gt; 45, name =&amp;gt; Mohammad, sex =&amp;gt; m}
   {age =&amp;gt; 20, name =&amp;gt; Joe, sex =&amp;gt; m}
   {age =&amp;gt; 35, name =&amp;gt; Julie, sex =&amp;gt; f}
   {age =&amp;gt; 10, name =&amp;gt; Cristina, sex =&amp;gt; f}
 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Once we have the list of hashes above, we need three individual strings (one for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;age&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sex&lt;/code&gt; respectively). To do this, we just need to extract the respective key for each item in the list; we can do this via a &lt;a href=&quot;https://docs.raku.org/routine/map&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;&lt;/a&gt; function. Additionally, we prepend the respective key using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&quot;key&quot;, |@list)&lt;/code&gt; syntax. For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;, this is what the output list looks like: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(name Mohammad Joe Julie Cristina)&lt;/code&gt;. Finally, we join the output list using commas.&lt;/li&gt;
  &lt;li&gt;Once we have the 3 key lists, we simply have to join them using the newline character as shown in the example output.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I am going through an exercise at my day job where I refactor code from a more imperative approach to a more functional approach. Functional programming should not be used for everything, but when we can use it, it often allows for much more readable and predictable code.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">A couple IO-related challenges this week with nice functional solutions. 🙂</summary></entry><entry><title type="html">Perl Weekly Challenge 109</title><link href="http://localhost:4000/blog/perl-weekly-challenge-109/" rel="alternate" type="text/html" title="Perl Weekly Challenge 109" /><published>2021-04-24T00:00:00-05:00</published><updated>2021-04-24T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-109</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-109/">&lt;p&gt;Two fun tasks this week that were both able to be solved in a functional manner 🎉&lt;/p&gt;

&lt;h2 id=&quot;task-1-chowla-numbers&quot;&gt;Task 1: Chowla Numbers&lt;/h2&gt;

&lt;p&gt;Write a script to generate first 20 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Chowla Numbers&lt;/code&gt;, named after, &lt;strong&gt;Sarvadaman D. S. Chowla&lt;/strong&gt;, a London born Indian American mathematician. It is defined as:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C(n) = sum of divisors of n except 1 and n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0, 0, 0, 2, 0, 5, 0, 6, 3, 7, 0, 15, 0, 9, 8, 14, 0, 20, 0, 21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-109/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Int $n) returns Int {
    (2..$n / 2).grep($n %% *).sum; # [1][2]
}

sub MAIN(Int $terms = 20) {
    say (1..$terms).map(&amp;amp;challenge).join(', '); # [3]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku
0, 0, 0, 2, 0, 5, 0, 6, 3, 7, 0, 15, 0, 9, 8, 14, 0, 20, 0, 21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Basically we find all the factors of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; excluding (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt;), then just sum them. We do this for the range &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1..$terms&lt;/code&gt; (in this case 20) and join them all with a comma to match the provided output.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;To find the factors of a given number, we only have to look at numbers from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n / 2&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; itself. Since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; are excluded from Chowla numbers by definition, we just go from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n / 2&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt; is Raku’s version of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter&lt;/code&gt;. Additionally, Raku has a built-in operator for “is divisible by” (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%%&lt;/code&gt;). Finally, we are able to use the “whatever star” since this is such a simple anonymous function. So basically, for each potential factor, we check if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; is divisible by that number.&lt;/li&gt;
  &lt;li&gt;Since the challenge operates on each number individually (rather than all 20 at once), we map the function over each number and join the output with a comma.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-four-squares-puzzle&quot;&gt;Task 2: Four Squares Puzzle&lt;/h2&gt;

&lt;p&gt;You are given four squares as below with numbers named a, b, c, d, e, f, g.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;              (1)                    (3)
        ╔══════════════╗      ╔══════════════╗
        ║              ║      ║              ║
        ║      a       ║      ║      e       ║
        ║              ║ (2)  ║              ║  (4)
        ║          ┌───╫──────╫───┐      ┌───╫─────────┐
        ║          │   ║      ║   │      │   ║         │
        ║          │ b ║      ║ d │      │ f ║         │
        ║          │   ║      ║   │      │   ║         │
        ║          │   ║      ║   │      │   ║         │
        ╚══════════╪═══╝      ╚═══╪══════╪═══╝         │
                   │       c      │      │      g      │
                   │              │      │             │
                   │              │      │             │
                   └──────────────┘      └─────────────┘
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Write a script to place the given unique numbers in the square box so that sum of numbers in each box is the same.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 1,2,3,4,5,6,7

Output:

    a = 6
    b = 4
    c = 1
    d = 5
    e = 2
    f = 3
    g = 7

    Box 1: a + b = 6 + 4 = 10
    Box 2: b + c + d = 4 + 1 + 5 = 10
    Box 3: d + e + f = 5 + 2 + 3 = 10
    Box 4: f + g = 3 + 7 = 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-109/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@nums where @nums.elems == 7) returns Str {
  my @solution = @nums
    .sort                                     # [1]
    .permutations                             # [2]
    .reverse                                  # [3]
    .first: -&amp;gt; ($a, $b, $c, $d, $e, $f, $g) { # [4][5]
      $a + $b == $b + $c + $d &amp;amp;&amp;amp;
      $b + $c + $d == $d + $e + $f &amp;amp;&amp;amp;
      $d + $e + $f == $f + $g
    };

  if @solution.elems == 1 {                       # [6]
    &quot;Unable to find a solution for given input.&quot;;
  } else {
    (&amp;lt;a b c d e f g&amp;gt; Z @solution)                 # [7][8]
      .map(-&amp;gt; ($key, $value) { &quot;$key = $value&quot; }) # [9]
      .join(&quot;\n&quot;);
  }
}

sub MAIN(*@nums where all(@nums) ~~ Int) {
  say challenge(@nums);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 1 2 3 4 5 6 7
a = 7
b = 3
c = 2
d = 5
e = 1
f = 4
g = 6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Raku helps us out quite a bit here with its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;permutations&lt;/code&gt; function. Basically, the actual squares are irrelevant and all we need to check is:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$a + $b == $b + $c + $d &amp;amp;&amp;amp;
$b + $c + $d == $d + $e + $f &amp;amp;&amp;amp;
$d + $e + $f == $f + $g
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So we just go through each permutation of the 7 numbers we are given (5040 permutations, so should be quick) and find the first instance where the above condition is true.&lt;/p&gt;

&lt;p&gt;You’ll also notice our output is different from the example output. That is because the following pairs are interchangeable:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$g&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$b&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$f&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$c&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$e&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since we maximize &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt;, our output is different, but still correct.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$g&lt;/code&gt; have to be comparatively big numbers compared to the rest, so we sort our input (and later reverse it) and start checking those permutations first.&lt;/li&gt;
  &lt;li&gt;Raku will automatically generate all permutations of a list with this function. It only works with &amp;lt;20 terms, which is perfect for this use case.&lt;/li&gt;
  &lt;li&gt;As I said in (1), we are reversing our list of permutations to start with the ones where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt; is greatest.&lt;/li&gt;
  &lt;li&gt;I have decided to start using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first: -&amp;gt; {}&lt;/code&gt; syntax for multi-line anonymous functions rather than the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first(-&amp;gt;  {})&lt;/code&gt; syntax, as I feel the trailing parenthesis looks out of place.&lt;/li&gt;
  &lt;li&gt;Raku allows us to unpack our individual permutation into variables, so &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$g&lt;/code&gt; are all assigned in this one line.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first&lt;/code&gt; returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; if it can’t find a match. &lt;em&gt;However&lt;/em&gt;, assigning &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; to a positional variable (denoted by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@&lt;/code&gt; sigil) will generate a list that looks like this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Any)]&lt;/code&gt;, so we check for size equal to 1 rather than checking if it is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;To get our numbers assigned to their letters, we need to zip them with the sequence &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt;. The output of this is a list that looks like this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((a 7) (b 3) (c 2) (d 5) (e 1) (f 4) (g 6))&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&amp;gt;&lt;/code&gt; syntax allows us to make a list of space-separated terms. It also makes each term a string automagically; it is basically shorthand for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;('a', 'b', 'c', 'd', 'e', 'f', 'g')&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;When we map over this list of pairs, we unpack each pair into its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$key&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$value&lt;/code&gt; and turn that into a string of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$key = $value&lt;/code&gt;. We then join this list of strings using newlines to match the provided output.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I’m always happy when I can find a functional solution to these problems, so I had fun this week. 🙂 See y’all next week!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Two fun tasks this week that were both able to be solved in a functional manner 🎉</summary></entry><entry><title type="html">Perl Weekly Challenge 108</title><link href="http://localhost:4000/blog/perl-weekly-challenge-108/" rel="alternate" type="text/html" title="Perl Weekly Challenge 108" /><published>2021-04-12T00:00:00-05:00</published><updated>2021-04-12T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-108</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-108/">&lt;p&gt;Task 1 this week is kind of a joke, but task 2 was interesting!&lt;/p&gt;

&lt;h2 id=&quot;task-1-locate-memory&quot;&gt;Task 1: Locate Memory&lt;/h2&gt;

&lt;p&gt;Write a script to declare a variable or constant and print its location in the memory.&lt;/p&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-108/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Any $variable) returns Int {
    $variable.WHERE;
}

sub MAIN {
    my $variable = rand;      # [1][2]
    say challenge($variable);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku
140444494947864
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Raku has the &lt;a href=&quot;https://docs.raku.org/routine/WHERE&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt;&lt;/a&gt; method built into it that “Returns an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; representing the memory address of the object,” we simply need to utilize that.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rand&lt;/code&gt; is a built-in subroutine that returns a random integer.&lt;/li&gt;
  &lt;li&gt;Following the Scala style, I would normally use parentheses for subroutines that are not “pure” and write this as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rand()&lt;/code&gt;, but Raku complains with the following error: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unsupported use of rand().  In Raku please use: rand.&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-bell-numbers&quot;&gt;Task 2: Bell Numbers&lt;/h2&gt;

&lt;p&gt;Write a script to display top 10 Bell Numbers. Please refer to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell_number&quot;&gt;Wikipedia page&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;B&lt;sub&gt;0&lt;/sub&gt;: 1, as you can only have one partition of zero element set.&lt;/li&gt;
  &lt;li&gt;B&lt;sub&gt;1&lt;/sub&gt;: 1, as you can only have one partition of one element set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{a}&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B&lt;sub&gt;2&lt;/sub&gt;: 2&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{a}{b}
{a,b}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B&lt;sub&gt;3&lt;/sub&gt;: 5&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{a}{b}{c}
{a,b}{c}
{a}{b,c}
{a,c}{b}
{a,b,c}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B&lt;sub&gt;4&lt;/sub&gt;: 15&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{a}{b}{c}{d}
{a,b,c,d}
{a,b}{c,d}
{a,c}{b,d}
{a,d}{b,c}
{a,b}{c}{d}
{a,c}{b}{d}
{a,d}{b}{c}
{b,c}{a}{d}
{b,d}{a}{c}
{c,d}{a}{b}
{a}{b,c,d}
{b}{a,c,d}
{c}{a,b,d}
{d}{a,b,c}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-108/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use experimental :cached;

sub challenge(Int $n where $n &amp;gt;= 0) is cached returns Int {            # [1]
    given $n {
        when 0|1 { 1 }
        default {
            my $n-minus-one = $n - 1;
            gather for (0..$n-minus-one) -&amp;gt; $k {                       # [2]
                take (^$n-minus-one).combinations($k) * challenge($k); # [2]
            }.sum
        }
    }
}

sub MAIN(Int $n = 10) {
    say (^$n).map(&amp;amp;challenge);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku
(1 1 2 5 15 52 203 877 4140 21147)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;!-- Allow inlining of math functionality --&gt;
&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], [&quot;\\(&quot;,&quot;\\)&quot;] ],
      processEscapes: true
    }
  });
&lt;/script&gt;

&lt;!-- Import math functionality --&gt;
&lt;script type=&quot;text/javascript&quot; async=&quot;&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The question asks for the “top 10 Bell Numbers.” Since this is an ever-increasing sequence, there is no “top,” so I interpreted that to mean &lt;em&gt;first&lt;/em&gt; 10 Bell numbers.&lt;/p&gt;

&lt;p&gt;At first glance, this code has nothing to do with the input sequences, but digging into the above-linked Wikipedia entry, we find this equation:&lt;/p&gt;

&lt;p&gt;$ B_{n+1} = \sum_{k=0}^{n}{n \choose k}B_{k} $&lt;/p&gt;

&lt;p&gt;This tells us that each Bell number is built upon by the previous Bell numbers. And we know the first two Bell numbers, so we can follow this.&lt;/p&gt;

&lt;p&gt;Let’s re-write this to calculate $ B_{2} $ and see how it works; remember, since we are calculating for $ B_{n+1} $, we use $ n = 1 $.&lt;/p&gt;

&lt;p&gt;$ B_{2} = \sum_{k=0}^{1}{1 \choose k}B_{k} $&lt;/p&gt;

&lt;p&gt;Which can be expanded as:&lt;/p&gt;

&lt;p&gt;$ B_{2} = {1 \choose 0}B_{0} + {1 \choose 1}B_{1} $&lt;/p&gt;

&lt;p&gt;Which can be reduced to:&lt;/p&gt;

&lt;p&gt;$ B_{2} = (1)(1) + (1)(1) = 2 $&lt;/p&gt;

&lt;p&gt;So $ B_{2} = 2 $ and we can use that to calculate $ B_{3} $ and so on.&lt;/p&gt;

&lt;p&gt;Now that we have the algorithm figured out, and decided we are going to apply it to the &lt;em&gt;first&lt;/em&gt; 10 terms, it’s a simple matter to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; the function over the sequence from 0 (inclusive) to 10 (exclusive).&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Since this is a recursive function, once we calculate $ B_{2} $ we will use it in $ B_{3} $, $ B_{4} $ and so on. No use re-calculating it every time, so we memoize this function using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is cached&lt;/code&gt; trait.&lt;/li&gt;
  &lt;li&gt;gather/take is a construct to build up a sequence using a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Supply&lt;/code&gt; (in this case, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&lt;/code&gt; loop).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I love me some pattern matching and recursion, coming from a Scala day job, so it is fun to use those constructs in other languages, especially Raku. 🙂&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Task 1 this week is kind of a joke, but task 2 was interesting!</summary></entry></feed>