<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-05-22T15:57:55-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Aaron Smith</title><subtitle>Personal website and blog of Aaron Smith</subtitle><author><name>Aaron Smith</name></author><entry><title type="html">Perl Weekly Challenge 112</title><link href="http://localhost:4000/blog/perl-weekly-challenge-113/" rel="alternate" type="text/html" title="Perl Weekly Challenge 112" /><published>2021-05-22T00:00:00-05:00</published><updated>2021-05-22T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-113</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-113/">&lt;p&gt;Task 1 allowed for some functional programming using some cool built-ins in Raku. Task 2 built on some code I wrote for &lt;a href=&quot;https://aaronreidsmith.github.io/blog/perl-weekly-challenge-094/#task-2-binary-tree-to-linked-list&quot;&gt;Challenge 94&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;task-1-represent-integer&quot;&gt;Task 1: Represent Integer&lt;/h2&gt;

&lt;p&gt;You are given a positive integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; and a digit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$D&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to check if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; can be represented as a sum of positive integers having &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$D&lt;/code&gt; at least once. If check passes print 1 otherwise 0.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $N = 25, $D = 7
Output: 0 as there are 2 numbers between 1 and 25 having the digit 7 i.e. 7 and 17. If we add up both we don't get 25.

Input: $N = 24, $D = 7
Output: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-113/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset PositiveInt of Int where * &amp;gt; 0; # [1]

sub challenge(PositiveInt $N, PositiveInt $D) returns Int {
  my $output = (1..^$N)   # [2]
    .race                 # [3]
    .grep(*.contains($D)) # [4]
    .combinations(2..*)   # [5]
    .map(*.sum)           # [6]
    .any == $N;           # [7]
  $output.Bool.Int;       # [8]
}

sub MAIN(PositiveInt $N, PositiveInt $D) {
  say challenge($N, $D);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 24 7
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This function first generates a list of integers from 0 to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N - 1&lt;/code&gt; (no need to include 0 or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; itself, since 0 is not positive and. we want things that add up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;). It then filters those down to only numbers that contain &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$D&lt;/code&gt;. It then finds all combinations of size 2 or larger to evaluate, and finds the sum of those combinations. Finally, it simply checks if any of the sums add up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;. I like that we can easily just chain these methods together; makes it very easy to read.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;The question says we should only allow positive integers. To do this, we can easily create a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subset&lt;/code&gt; of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; and add a condition using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;where&lt;/code&gt; (in this case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;where * &amp;gt; 0&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;As mentioned above, no need to include &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;, so we filter them using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;..^&lt;/code&gt; range creator. It includes the bottom number and excludes the top number.&lt;/li&gt;
  &lt;li&gt;We don’t need this list in any order, since we will end up with a boolean (and eventually integer) at the end. So we want to perform all of our actions as quickly as possible, and we don’t care about order. &lt;a href=&quot;https://docs.raku.org/routine/race&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;race&lt;/code&gt;&lt;/a&gt; creates a &lt;a href=&quot;https://docs.raku.org/type/RaceSeq&quot;&gt;RaceSeq&lt;/a&gt;, which allows us to process a list in parallel without regards to order.&lt;/li&gt;
  &lt;li&gt;We filter (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt;) down to numbers that contains &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$D&lt;/code&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contains&lt;/code&gt; coerces the left-hand argument to a String, so this is the same as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*.Str.contains($d)&lt;/code&gt;. This is actually a documented &lt;a href=&quot;https://docs.raku.org/language/traps#Lists_become_strings,_so_beware_.contains()&quot;&gt;trap&lt;/a&gt; that I &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-04/&quot;&gt;fell into&lt;/a&gt; during Advent of Code, but it works in my favor this time.&lt;/li&gt;
  &lt;li&gt;We want to examine all combinations of size 2 or larger, which can easily be created using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2..*&lt;/code&gt; syntax.&lt;/li&gt;
  &lt;li&gt;Once we have all the combinations, it is a simple matter to find their sums by mapping over each combination (and using the built-in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sum&lt;/code&gt; method).&lt;/li&gt;
  &lt;li&gt;Once we have a list of sums, we want to see if &lt;em&gt;any&lt;/em&gt; equal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;. So we just call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.any&lt;/code&gt; on the list and get our answer!&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;any&lt;/code&gt; returns a &lt;a href=&quot;https://docs.raku.org/routine/any&quot;&gt;Junction&lt;/a&gt;, so we have to coerce it to a boolean, and then an integer to get the output that the challenge expects.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-recreate-binary-tree&quot;&gt;Task 2: Recreate Binary Tree&lt;/h2&gt;

&lt;p&gt;You are given a Binary Tree.&lt;/p&gt;

&lt;p&gt;Write a script to replace each node of the tree with the sum of all the remaining nodes.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example&lt;/h3&gt;

&lt;h4 id=&quot;input-binary-tree&quot;&gt;Input Binary Tree&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        1
       / \
      2   3
     /   / \
    4   5   6
     \
      7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;output-binary-tree&quot;&gt;Output Binary Tree&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        27
       /  \
      26  25
     /   /  \
    24  23  22
     \
     21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-113/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset NodeValue of Str where { $_ ~~ /^&amp;lt;digit&amp;gt;$/ || $_ eq 'Nil' }

class Node {
  has Node $.left  is rw = Nil;
  has Node $.right is rw = Nil;
  has Int  $.value is rw = 0;
}

# Adapted from https://rosettacode.org/wiki/Visualize_a_tree#Raku
sub format-tree(
  Node $root,
  Str :$indent = '',
  :@mid = ('├─', '│ '),
  :@end = ('└─', '  ')
) returns Str {
  sub visit(Node $node, *@pre) {
    with $node {
      |gather {
        take @pre[0] ~ $node.value;
        my @children = ($node.right, $node.left).grep(*.defined);
        my $end = @children.end;
        for @children.kv -&amp;gt; $_, $child {
          when $end { take visit($child, (@pre[1] X~ @end)) }
          default   { take visit($child, (@pre[1] X~ @mid)) }
        }
      }
    }
  }
  visit($root, $indent xx 2).join(&quot;\n&quot;);
}

sub build-tree(@array, $root is copy = Nil, Int $i = 0) returns Node {
  if $i &amp;lt; @array.elems &amp;amp;&amp;amp; @array[$i] ne 'Nil' {
    $root       = Node.new(value =&amp;gt; @array[$i].Int);
    $root.left  = build-tree(@array, $root.left, 2 * $i + 1);
    $root.right = build-tree(@array, $root.right, 2 * $i + 2);
  }
  $root;
}

sub challenge(Node $root is copy, @values = ()) returns Node {
  sub extract-values(Node $root) returns Positional {                           # [1]
    with $root {                                                                # [2]
      ($root.value, |extract-values($root.left), |extract-values($root.right)); # [3]
    }
  }

  with $root {
    my @node-values = @values.elems &amp;gt; 0 ?? @values !! extract-values($root); # [4]
    $root.value = @node-values.grep(* != $root.value).sum;                   # [5]
    challenge($root.left, @node-values);                                     # [6]
    challenge($root.right, @node-values);
  }
  $root;
}

sub MAIN(*@nodes where all(@nodes) ~~ NodeValue) {
  my $root = build-tree(@nodes);
  say format-tree(challenge($root));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 1 2 3 4 Nil 5 6 Nil 7 Nil Nil
27
├─25
│ ├─22
│ └─23
└─26
  └─24
    └─21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I will only be discussing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; subroutine, as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;build-tree&lt;/code&gt; was written in my Challenge 94 blog, along with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NodeValue&lt;/code&gt; subset and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Node&lt;/code&gt; class. Additionally, I couldn’t find a good way to actually print this tree out, so I copied &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;format-tree&lt;/code&gt; from &lt;a href=&quot;https://rosettacode.org/wiki/Visualize_a_tree#Raku&quot;&gt;Rosetta Code&lt;/a&gt;; it has some issues (the 24 is not obvious that it is the left branch), but it works overall.&lt;/p&gt;

&lt;p&gt;As for the actual &lt;em&gt;new&lt;/em&gt; code that I wrote, given a tree, we simply need to traverse it once to find the values (storing it in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@node-values&lt;/code&gt;). Then, traverse it a second time and changing the values at each node to the sum of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@node-values&lt;/code&gt; excluding the current value. So for the root node, it would be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@node-values.grep(* != 1).sum&lt;/code&gt;. Once we have done that, since we changed the tree in place, we can just return the root.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;This is defined within &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; because it is not really needed outside of it. Additionally, this logic can’t be included as part of the main flow of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; since we use a copy of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$root&lt;/code&gt;. Since we traverse recursively, our list of values would be different on each recursive call.&lt;/li&gt;
  &lt;li&gt;This &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; guard prevents us from trying to run the logic/recurse even more if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$root&lt;/code&gt; is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;This is a simple prefix traversal (where we visit the current node, then left, then right). Since we have the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; guard, this will prevent &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; values. So for the example input we would end up with this list: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 2, 3, 4, 5, 6, 7)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;We only want to call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extract-values&lt;/code&gt; on the first call (since the tree is constantly changing), so we only run it if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@values&lt;/code&gt; is empty (and then pass in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@node-values&lt;/code&gt; on subsequent calls).&lt;/li&gt;
  &lt;li&gt;Like I showed above, we just need to sum all the values are not &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$root.value&lt;/code&gt;. Another way to do this would have been &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@node-values.sum - $root.value&lt;/code&gt;, which honestly might have been faster since it doesn’t require traversing twice. Oh well!&lt;/li&gt;
  &lt;li&gt;These recursive calls will &lt;em&gt;technically&lt;/em&gt; return their &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$root&lt;/code&gt;, but since they aren’t assigned to anything, they are just ignored.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;The hardest part of this week’s challenge was honestly trying to find a way to print a binary tree! I tried translating some algorithms from other languages, and eventually settled on the one I used. Let me know if there are any good ones out there!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Task 1 allowed for some functional programming using some cool built-ins in Raku. Task 2 built on some code I wrote for Challenge 94.</summary></entry><entry><title type="html">Perl Weekly Challenge 112</title><link href="http://localhost:4000/blog/perl-weekly-challenge-112/" rel="alternate" type="text/html" title="Perl Weekly Challenge 112" /><published>2021-05-15T00:00:00-05:00</published><updated>2021-05-15T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-112</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-112/">&lt;p&gt;A little string manipulation and recursion today. My solution to task 2 is &lt;em&gt;almost&lt;/em&gt; the same as my solution to &lt;a href=&quot;https://aaronreidsmith.github.io/blog/advent-of-code-day-10/&quot;&gt;Advent of Code 2020: Day 10 (part 2)&lt;/a&gt;!&lt;/p&gt;

&lt;h2 id=&quot;task-1-canonical-path&quot;&gt;Task 1: Canonical Path&lt;/h2&gt;

&lt;p&gt;You are given a string path, starting with a slash ‘/’.&lt;/p&gt;

&lt;p&gt;Write a script to convert the given absolute path to the simplified canonical path.&lt;/p&gt;

&lt;p&gt;In a Unix-style file system:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- A period '.' refers to the current directory
- A double period '..' refers to the directory up a level
- Multiple consecutive slashes ('//') are treated as a single slash '/'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The canonical path format:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- The path starts with a single slash '/'.
- Any two directories are separated by a single slash '/'.
- The path does not end with a trailing '/'.
- The path only contains the directories on the path from the root directory to the target file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: &quot;/a/&quot;
Output: &quot;/a&quot;

Input: &quot;/a/b//c/&quot;
Output: &quot;/a/b/c&quot;

Input: &quot;/a/b/c/../..&quot;
Output: &quot;/a&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-112/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Str $path is copy) returns Str {                  # [1]
  die &quot;Must be an absolute path&quot; unless $path.starts-with('/'); # [2]
  
  $path = $path.substr(1);                              # [3]
  $path = $path.subst(/\/ ** 2..*/, '/', :global);      # [4][5]
  $path = $path.substr(0, *-1) if $path.ends-with('/'); # [6]

  my @output;
  for $path.split('/') -&amp;gt; $dir {
    given $dir {
      when '.' { Nil }                            # [7]
      when '..' {
        die &quot;Illegal path&quot; if @output.elems == 0;
        @output.pop;
      }
      default { @output.push($dir) }
    }
  }
  '/' ~ @output.join('/')
}

sub MAIN(Str $path) {
  say challenge($path);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku /a/b//c
/a/b/c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;We basically just follow the following steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Does the path start with a slash?
    &lt;ul&gt;
      &lt;li&gt;If yes, remove it and continue.&lt;/li&gt;
      &lt;li&gt;If not, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;die&lt;/code&gt;, since the problem indicates we are given a path starting with a slash.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Replace any duplicate slashes with a single slash.&lt;/li&gt;
  &lt;li&gt;Remove the trailing slash if it exists.&lt;/li&gt;
  &lt;li&gt;We should now have something that looks like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a/b/c&lt;/code&gt; and we split it into a list that looks like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(a, b, c)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Iterate through the above list and take one of three actions depending on what item we encounter:
    &lt;ul&gt;
      &lt;li&gt;If we hit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.&lt;/code&gt;, it is just redundant and we can continue.&lt;/li&gt;
      &lt;li&gt;If we hit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;..&lt;/code&gt;, we need to remove the most recent item from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt;. As a caveat, if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt; is empty and we encounter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;..&lt;/code&gt;, it will throw an error.&lt;/li&gt;
      &lt;li&gt;If we hit anything else (i.e., a normal directory), we can just add it to the end of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Finally, we just join &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt; into a path using slashes, and prepend a slash onto it to make it an absolute path.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Since we are mutating &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$path&lt;/code&gt; within the subroutine, we need to declare it as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is copy&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The question says our input must start with a slash. So we die &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unless&lt;/code&gt; it has the correct input.&lt;/li&gt;
  &lt;li&gt;If we reach this line, that means the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$path&lt;/code&gt; &lt;em&gt;does&lt;/em&gt; start with a slash, and we need to remove it using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;substr&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;We want to replace any instance where there are two or more slashes in a row. That is what this regex means &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/\/ ** 2..*/&lt;/code&gt;; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\/&lt;/code&gt; means “literal slash” and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2..*&lt;/code&gt; means “two or more times.” We replace all of these instances with a single slash, and we want to do it for the whole string, hence &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:global&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;As an aside, I hate that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;substr&lt;/code&gt; (substring) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subst&lt;/code&gt; (substitute) are so close in spelling. I feel the former should be named &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;slice&lt;/code&gt; and the latter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;replace&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;If our path ends with a slash, we want to remove it so that when we &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;split&lt;/code&gt; we don’t get an empty entry.&lt;/li&gt;
  &lt;li&gt;Don’t really know if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; is the right thing to do here. In Scala, it would just be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;case &quot;.&quot; =&amp;gt;&lt;/code&gt; with nothing on the right-hand side of the arrow. I figured an empty block or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; is safe since we don’t want this case to fall into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-climb-stairs&quot;&gt;Task 2: Climb Stairs&lt;/h2&gt;

&lt;p&gt;You are given &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; steps to climb&lt;/p&gt;

&lt;p&gt;Write a script to find out the distinct ways to climb to the top. You are allowed to climb either 1 or 2 steps at a time.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $n = 3
Output: 3

    Option 1: 1 step + 1 step + 1 step
    Option 2: 1 step + 2 steps
    Option 3: 2 steps + 1 step

Input: $n = 4
Output: 5

    Option 1: 1 step + 1 step + 1 step + 1 step
    Option 2: 1 step + 1 step + 2 steps
    Option 3: 2 steps + 1 step + 1 step
    Option 4: 1 step + 2 steps + 1 step
    Option 5: 2 steps + 2 steps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-112/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use experimental :cached; # [1]

sub challenge(
  $max where Int,
  @paths where Positional = (^$max), # [2][3]
  $current-step where Int = 0
) is cached {
  given $current-step {
    when * == $max { 1 }
    when * &amp;gt; $max  { 0 }
    default {
      challenge($max, @paths, $current-step + 1) +
      challenge($max, @paths, $current-step + 2)
    }
  }
}

sub MAIN(Int $n) {
  say challenge($n);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 4
5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This one is actually pretty straight forward, even if it doesn’t seem as such. Basically, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; will construct a list from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0..^$n&lt;/code&gt;; so for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n = 3&lt;/code&gt; we would get &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(0, 1, 2)&lt;/code&gt;. Starting at step &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; we check 2 conditions:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Are we at the top of the steps? If so, stop and mark this path as valid (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Are we &lt;em&gt;above&lt;/em&gt; the top of the steps? If so, stop and mark this path as &lt;em&gt;invalid&lt;/em&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If we don’t match either of the above conditions, we try &lt;em&gt;both&lt;/em&gt; a step size of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; recursively. So essentially this is a brute force approach, but it is efficient because we have memoized our subroutine using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is cached&lt;/code&gt; trait. This means that once it has done the computation for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge(3, (0, 1, 2), 2)&lt;/code&gt;, the next time it sees that same input, it will always return the same result. Since a step size of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; will have some overlap in individual steps, this makes this approach incredibly efficient.&lt;/p&gt;

&lt;p&gt;Since the end conditions only return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt; block actually handles summing the valid paths.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is cached&lt;/code&gt; is an experimental feature and needs to be explicitly imported.&lt;/li&gt;
  &lt;li&gt;Normally you see me write &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int $foo&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$foo where Int&lt;/code&gt;. This fails for positionals and hashes; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int @foo&lt;/code&gt; indicates a &lt;em&gt;positional of ints&lt;/em&gt; (since the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@&lt;/code&gt; sigil already indicates it is a positional). So why didn’t I just do that? I tried. It fails with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;expected Positional[Int] but got Range (^10)&lt;/code&gt;, which I think is stupid. So this is a way to &lt;em&gt;kind of&lt;/em&gt; strongly-type it; better than nothing I guess.&lt;/li&gt;
  &lt;li&gt;I think it is cool that I can use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$max&lt;/code&gt; in the default of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@paths&lt;/code&gt; here!&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Pretty easy this week, but that is mostly because I was able to copy an older solution of mine for task two. Should I have done something new/different? Probably, but oh well. See y’all next week!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">A little string manipulation and recursion today. My solution to task 2 is almost the same as my solution to Advent of Code 2020: Day 10 (part 2)!</summary></entry><entry><title type="html">Perl Weekly Challenge 111</title><link href="http://localhost:4000/blog/perl-weekly-challenge-111/" rel="alternate" type="text/html" title="Perl Weekly Challenge 111" /><published>2021-05-08T00:00:00-05:00</published><updated>2021-05-08T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-111</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-111/">&lt;p&gt;I was apparently &lt;a href=&quot;https://perlweeklychallenge.org/blog/meet-the-champion-2021-04/&quot;&gt;the champion&lt;/a&gt; of the &lt;em&gt;Perl Weekly Challenge&lt;/em&gt; for last month, which is pretty cool! I encourage folks to go read my interview with Mohammad Anwar, who runs the &lt;em&gt;Perl Weekly Challenge&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;task-1-search-matrix&quot;&gt;Task 1: Search Matrix&lt;/h2&gt;

&lt;p&gt;You are given 5x5 matrix filled with integers such that each row is sorted from left to right, and the first integer of each row is greater than the last integer of the previous row.&lt;/p&gt;

&lt;p&gt;Write a script to find a given integer in the matrix using an efficient search algorithm.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Matrix: [  1,  2,  3,  5,  7 ]
        [  9, 11, 15, 19, 20 ]
        [ 23, 24, 25, 29, 31 ]
        [ 32, 33, 39, 40, 42 ]
        [ 45, 47, 48, 49, 50 ]

Input: 35
Output: 0 since it is missing in the matrix

Input: 39
Output: 1 as it exists in the matrix
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-111/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@list-of-lists, Int $N) returns Int {
  my $output = 0;
  for (0..^@list-of-lists.end) Z (0^..@list-of-lists.end) -&amp;gt; ($i, $j) { # [1]
    if @list-of-lists[$i].head == $N || @list-of-lists[$j].head == $N { # [2]
      $output = 1;
      last;
    } elsif @list-of-lists[$i].head &amp;lt; $N &amp;lt; @list-of-lists[$j].head {
      $output = (any(@list-of-lists[$i][1..*]) ~~ $N).Int;              # [3]
      last;
    } elsif $j == @list-of-lists.end &amp;amp;&amp;amp; $N &amp;gt; @list-of-lists[$j].head {  # [4]
      $output = (any(@list-of-lists[$j][1..*]) ~~ $N).Int;
      last;
    }
  }
  $output;
}

sub MAIN(Int $N) {
  my @list-of-lists = (   # [5]
    ( 1,  2,  3,  5,  7),
    ( 9, 11, 15, 19, 20),
    (23, 24, 25, 29, 31),
    (32, 33, 39, 40, 42),
    (45, 47, 48, 49, 50)
  );
  say challenge(@list-of-lists, $N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 35
0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I don’t know if this is the most efficient method, but it is &lt;em&gt;an&lt;/em&gt; efficient method, which is what the question calls for. The naive solution would be something like this, which has a complexity of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(n+k)&lt;/code&gt; where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; is the number of elements total (25) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt; is the cost of flattening the structure (likely just 4 appends).&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;any(@list-of-lists.flat) ~~ $N
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;My approach, instead, looks at the first element of each sublist to determine if it should even bother looking in that sublist. If so, it will drop down and check items 2 through 5 of the sublist (I assume this happens in order using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;any&lt;/code&gt;). if not, it will skip the list entirely and jump to the next sublist.&lt;/p&gt;

&lt;p&gt;I &lt;em&gt;think&lt;/em&gt; my approach has a complexity of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(n+k)&lt;/code&gt; where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; is the number of sub-lists (5) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt; is the number of elements in that list (minus the first one, so 4). So we will &lt;em&gt;at most&lt;/em&gt; do 9 checks and be able to determine if the item exists in a sublist. On average, we will have fewer checks than that.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;This looks complex, but this is just making a list that looks like this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((0, 1), (1, 2), (2, 3), (3, 4))&lt;/code&gt; so that we can look at two sublists at a time. The second sublist is necessary so we can check the top end of the range easily.&lt;/li&gt;
  &lt;li&gt;Check the head of the first list and head of the second sublist to see if we can skip searching a sublist.&lt;/li&gt;
  &lt;li&gt;If it is in the range of a sublist, we can drop into it and use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;any&lt;/code&gt;, which I am pretty sure just searches from left to right. At most this will search all 4 elements (we skip the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; item), and will end early if it finds the element.&lt;/li&gt;
  &lt;li&gt;If this is the last iteration and we still haven’t found &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;, we need to drop into the last sublist, just for full coverage.&lt;/li&gt;
  &lt;li&gt;We could set this up to be dynamic and passed in at run time, but I figured it would be okay to hardcode for our purposes.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-ordered-letters&quot;&gt;Task 2: Ordered Letters&lt;/h2&gt;

&lt;p&gt;Given a word, you can sort its letters alphabetically (case-insensitive). For example, “beekeeper” becomes “beeeeekpr” and “dictionary” becomes “acdiinorty”.&lt;/p&gt;

&lt;p&gt;Write a script to find the longest English words that don’t change when their letters are sorted.&lt;/p&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-111/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use LibCurl::HTTP :subs; # Imports jget

sub get-english-words {
  my %words = jget('https://raw.githubusercontent.com/dwyl/english-words/master/words_dictionary.json'); # [1]
  %words.keys;                                                                                           # [2]
}

sub challenge(Int $threshold) {
  my @words = get-english-words;
  my @matching-words = gather for @words.race -&amp;gt; $word {         # [3]
    my @chars = $word.comb;
    if @chars.elems &amp;gt;= $threshold &amp;amp;&amp;amp; @chars.sort.join eq $word { # [4]
      take $word;
    }
  }
  @matching-words.sort;
}

multi sub MAIN(Int $threshold = 7) { # [5]
  for challenge($threshold) -&amp;gt; $word {
    say $word;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku
adelops
aegilops
alloquy
beefily
begorry
belloot
billowy
deglory
egilops
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;So this question is pretty vague. The first problem we have is, how do we get a list of all English words? Rather than ship a text file around with my code, we can pull some at run time from an API. I couldn’t find a decent free API, so I just found &lt;a href=&quot;https://github.com/dwyl/english-words&quot;&gt;this GitHub repo&lt;/a&gt; that has a JSON file full of words. Does it have all the words? I have no idea, but it will certainly work for our purposes.&lt;/p&gt;

&lt;p&gt;Basically, once that is pulled down, we just split each word into characters, sort them, and compare them to the original word. However, we check against &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$threshold&lt;/code&gt; first, so we don’t do the expensive computation on every word.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Passing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:sub&lt;/code&gt; flag to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;use LibCurl:HTTP&lt;/code&gt; imports its individual subroutines, including &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jget&lt;/code&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jget&lt;/code&gt; calls the URL and unpacks the returns JSON into a hash.&lt;/li&gt;
  &lt;li&gt;I don’t know why the author of the above GitHub repo chose this format, but instead of using a JSON array, they used a format like this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&quot;word&quot;: 1}&lt;/code&gt;, so we only need the keys.&lt;/li&gt;
  &lt;li&gt;Since we need to process all of these words, and the order doesn’t matter (since we will sort later), we can cast this list to a &lt;a href=&quot;https://docs.raku.org/type/RaceSeq&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RaceSeq&lt;/code&gt;&lt;/a&gt; that will process in parallel without definite order.&lt;/li&gt;
  &lt;li&gt;Check the threshold first, so we don’t do the expensive computation if it is short. If it passes that check, sort the characters and compare to the original word. If it also passes that check, we can take this work and add it to our output.&lt;/li&gt;
  &lt;li&gt;The question asks us to find the longest English &lt;strong&gt;words&lt;/strong&gt; (plural). The single longest word is 8 characters (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aegilops&lt;/code&gt;, which is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Aegilops&quot;&gt;genus of plant&lt;/a&gt;), so I bumped the threshold down to 7 to give the longest English &lt;strong&gt;words&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I have never gotten to do web requests in Raku, so it was fun learning about different packages for that. There is even the &lt;a href=&quot;https://cro.services/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cro&lt;/code&gt;&lt;/a&gt; project for setting up APIs; maybe I will get a chance to use that in the future. See y’all next week!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">I was apparently the champion of the Perl Weekly Challenge for last month, which is pretty cool! I encourage folks to go read my interview with Mohammad Anwar, who runs the Perl Weekly Challenge.</summary></entry><entry><title type="html">Perl Weekly Challenge 110</title><link href="http://localhost:4000/blog/perl-weekly-challenge-110/" rel="alternate" type="text/html" title="Perl Weekly Challenge 110" /><published>2021-05-01T00:00:00-05:00</published><updated>2021-05-01T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-110</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-110/">&lt;p&gt;A couple IO-related challenges this week with nice functional solutions. 🙂&lt;/p&gt;

&lt;h2 id=&quot;task-1-valid-phone-numbers&quot;&gt;Task 1: Valid Phone Numbers&lt;/h2&gt;

&lt;p&gt;You are given a text file.&lt;/p&gt;

&lt;p&gt;Write a script to display all valid phone numbers in the given text file.&lt;/p&gt;

&lt;h3 id=&quot;acceptable-phone-number-formats&quot;&gt;Acceptable Phone Number Formats&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+nn  nnnnnnnnnn
(nn) nnnnnnnnnn
nnnn nnnnnnnnnn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;input-file&quot;&gt;Input File&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0044 1148820341
 +44 1148820341
  44-11-4882-0341
(44) 1148820341
  00 1148820341
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0044 1148820341
 +44 1148820341
(44) 1148820341
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-110/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Str $file-path) returns Str {
  $file-path
    .IO
    .lines
    .grep(* ~~ /                                         # [1]
      ^                                                  # [2]
      &amp;lt;space&amp;gt;*                                           # [3]
      [\+&amp;lt;digit&amp;gt; ** 2 | \(&amp;lt;digit&amp;gt; ** 2\) | &amp;lt;digit&amp;gt; ** 4] # [4]
      &amp;lt;space&amp;gt;                                            # [5]
      &amp;lt;digit&amp;gt; ** 10                                      # [6]
      $                                                  # [7]
    /)
    .join(&quot;\n&quot;);
}

sub MAIN(Str $file-path) {
  say challenge($file-path);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku test.txt
0044 1148820341
 +44 1148820341
(44) 1148820341
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The basics here are pretty simple – for each line in the file, check if it matches our regex. If so, keep it, otherwise, drop it. Finally, join all matching lines together using the newline character. See below for comments on the regex itself.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Spaces in regexes in Raku are insignificant unless we put the &lt;a href=&quot;https://docs.raku.org/language/regexes#Sigspace&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:s&lt;/code&gt; modifier&lt;/a&gt; (or “ratchet”) in front of the opening forward slash. This allows us to break the logic up over multiple lines and even add comments.&lt;/li&gt;
  &lt;li&gt;Match the beginning of the line; this is a universal regex metacharacter.&lt;/li&gt;
  &lt;li&gt;Match zero or more spaces. The example file had different levels of space at the beginning of each line, but all of it was insignificant.&lt;/li&gt;
  &lt;li&gt;This line matches what I will call our “prefix.” It will match exactly one of the following:
    &lt;ul&gt;
      &lt;li&gt;A literal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; character follow by two digits.&lt;/li&gt;
      &lt;li&gt;A literal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&lt;/code&gt; character followed by two digits followed by a literal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;)&lt;/code&gt; character.&lt;/li&gt;
      &lt;li&gt;Four digits in a row.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Each valid phone number had a space between the prefix and the last 10 digits, so this matches a literal space.&lt;/li&gt;
  &lt;li&gt;All valid phone numbers end in exactly 10 numbers&lt;/li&gt;
  &lt;li&gt;Match the end of the line to verify there is nothing else in the matching line.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-transpose-file&quot;&gt;Task 2: Transpose File&lt;/h2&gt;

&lt;p&gt;You are given a text file.&lt;/p&gt;

&lt;p&gt;Write a script to transpose the contents of the given file.&lt;/p&gt;

&lt;h3 id=&quot;input-file-1&quot;&gt;Input File&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name,age,sex
Mohammad,45,m
Joe,20,m
Julie,35,f
Cristina,10,f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;output-1&quot;&gt;Output&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name,Mohammad,Joe,Julie,Cristina
age,45,20,35,10
sex,m,m,f,f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-110/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use Text::CSV; # Imports `csv` function

sub challenge(Str $file-path) returns Str {
  my @lines = csv(in =&amp;gt; $file-path, headers =&amp;gt; &quot;auto&quot;); # [1] 
  my $names = ('name', |@lines.map(*&amp;lt;name&amp;gt;)).join(','); # [2]
  my $ages  = ('age', |@lines.map(*&amp;lt;age&amp;gt;)).join(',');
  my $sexes = ('sex', |@lines.map(*&amp;lt;sex&amp;gt;)).join(',');
  ($names, $ages, $sexes).join(&quot;\n&quot;);                   # [3]
}

sub MAIN(Str $file-path) {
  say challenge($file-path);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku test.csv
name,Mohammad,Joe,Julie,Cristina
age,45,20,35,10
sex,m,m,f,f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The bulk of the hard work is done for us by using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text::CSV&lt;/code&gt; module. It allows us to pull the file into a list of hashes, and then do the logical work on that list. See below for how we apply the logic.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;csv&lt;/code&gt; with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;headers&lt;/code&gt; option allows us to pull the CSV file into a list of hashes that looks like this:&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [
   {age =&amp;gt; 45, name =&amp;gt; Mohammad, sex =&amp;gt; m}
   {age =&amp;gt; 20, name =&amp;gt; Joe, sex =&amp;gt; m}
   {age =&amp;gt; 35, name =&amp;gt; Julie, sex =&amp;gt; f}
   {age =&amp;gt; 10, name =&amp;gt; Cristina, sex =&amp;gt; f}
 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Once we have the list of hashes above, we need three individual strings (one for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;age&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sex&lt;/code&gt; respectively). To do this, we just need to extract the respective key for each item in the list; we can do this via a &lt;a href=&quot;https://docs.raku.org/routine/map&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;&lt;/a&gt; function. Additionally, we prepend the respective key using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&quot;key&quot;, |@list)&lt;/code&gt; syntax. For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;, this is what the output list looks like: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(name Mohammad Joe Julie Cristina)&lt;/code&gt;. Finally, we join the output list using commas.&lt;/li&gt;
  &lt;li&gt;Once we have the 3 key lists, we simply have to join them using the newline character as shown in the example output.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I am going through an exercise at my day job where I refactor code from a more imperative approach to a more functional approach. Functional programming should not be used for everything, but when we can use it, it often allows for much more readable and predictable code.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">A couple IO-related challenges this week with nice functional solutions. 🙂</summary></entry><entry><title type="html">Perl Weekly Challenge 109</title><link href="http://localhost:4000/blog/perl-weekly-challenge-109/" rel="alternate" type="text/html" title="Perl Weekly Challenge 109" /><published>2021-04-24T00:00:00-05:00</published><updated>2021-04-24T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-109</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-109/">&lt;p&gt;Two fun tasks this week that were both able to be solved in a functional manner 🎉&lt;/p&gt;

&lt;h2 id=&quot;task-1-chowla-numbers&quot;&gt;Task 1: Chowla Numbers&lt;/h2&gt;

&lt;p&gt;Write a script to generate first 20 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Chowla Numbers&lt;/code&gt;, named after, &lt;strong&gt;Sarvadaman D. S. Chowla&lt;/strong&gt;, a London born Indian American mathematician. It is defined as:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C(n) = sum of divisors of n except 1 and n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0, 0, 0, 2, 0, 5, 0, 6, 3, 7, 0, 15, 0, 9, 8, 14, 0, 20, 0, 21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-109/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Int $n) returns Int {
    (2..$n / 2).grep($n %% *).sum; # [1][2]
}

sub MAIN(Int $terms = 20) {
    say (1..$terms).map(&amp;amp;challenge).join(', '); # [3]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku
0, 0, 0, 2, 0, 5, 0, 6, 3, 7, 0, 15, 0, 9, 8, 14, 0, 20, 0, 21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Basically we find all the factors of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; excluding (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt;), then just sum them. We do this for the range &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1..$terms&lt;/code&gt; (in this case 20) and join them all with a comma to match the provided output.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;To find the factors of a given number, we only have to look at numbers from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n / 2&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; itself. Since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; are excluded from Chowla numbers by definition, we just go from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n / 2&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt; is Raku’s version of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter&lt;/code&gt;. Additionally, Raku has a built-in operator for “is divisible by” (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%%&lt;/code&gt;). Finally, we are able to use the “whatever star” since this is such a simple anonymous function. So basically, for each potential factor, we check if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; is divisible by that number.&lt;/li&gt;
  &lt;li&gt;Since the challenge operates on each number individually (rather than all 20 at once), we map the function over each number and join the output with a comma.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-four-squares-puzzle&quot;&gt;Task 2: Four Squares Puzzle&lt;/h2&gt;

&lt;p&gt;You are given four squares as below with numbers named a, b, c, d, e, f, g.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;              (1)                    (3)
        ╔══════════════╗      ╔══════════════╗
        ║              ║      ║              ║
        ║      a       ║      ║      e       ║
        ║              ║ (2)  ║              ║  (4)
        ║          ┌───╫──────╫───┐      ┌───╫─────────┐
        ║          │   ║      ║   │      │   ║         │
        ║          │ b ║      ║ d │      │ f ║         │
        ║          │   ║      ║   │      │   ║         │
        ║          │   ║      ║   │      │   ║         │
        ╚══════════╪═══╝      ╚═══╪══════╪═══╝         │
                   │       c      │      │      g      │
                   │              │      │             │
                   │              │      │             │
                   └──────────────┘      └─────────────┘
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Write a script to place the given unique numbers in the square box so that sum of numbers in each box is the same.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 1,2,3,4,5,6,7

Output:

    a = 6
    b = 4
    c = 1
    d = 5
    e = 2
    f = 3
    g = 7

    Box 1: a + b = 6 + 4 = 10
    Box 2: b + c + d = 4 + 1 + 5 = 10
    Box 3: d + e + f = 5 + 2 + 3 = 10
    Box 4: f + g = 3 + 7 = 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-109/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@nums where @nums.elems == 7) returns Str {
  my @solution = @nums
    .sort                                     # [1]
    .permutations                             # [2]
    .reverse                                  # [3]
    .first: -&amp;gt; ($a, $b, $c, $d, $e, $f, $g) { # [4][5]
      $a + $b == $b + $c + $d &amp;amp;&amp;amp;
      $b + $c + $d == $d + $e + $f &amp;amp;&amp;amp;
      $d + $e + $f == $f + $g
    };

  if @solution.elems == 1 {                       # [6]
    &quot;Unable to find a solution for given input.&quot;;
  } else {
    (&amp;lt;a b c d e f g&amp;gt; Z @solution)                 # [7][8]
      .map(-&amp;gt; ($key, $value) { &quot;$key = $value&quot; }) # [9]
      .join(&quot;\n&quot;);
  }
}

sub MAIN(*@nums where all(@nums) ~~ Int) {
  say challenge(@nums);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 1 2 3 4 5 6 7
a = 7
b = 3
c = 2
d = 5
e = 1
f = 4
g = 6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Raku helps us out quite a bit here with its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;permutations&lt;/code&gt; function. Basically, the actual squares are irrelevant and all we need to check is:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$a + $b == $b + $c + $d &amp;amp;&amp;amp;
$b + $c + $d == $d + $e + $f &amp;amp;&amp;amp;
$d + $e + $f == $f + $g
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So we just go through each permutation of the 7 numbers we are given (5040 permutations, so should be quick) and find the first instance where the above condition is true.&lt;/p&gt;

&lt;p&gt;You’ll also notice our output is different from the example output. That is because the following pairs are interchangeable:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$g&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$b&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$f&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$c&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$e&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since we maximize &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt;, our output is different, but still correct.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$g&lt;/code&gt; have to be comparatively big numbers compared to the rest, so we sort our input (and later reverse it) and start checking those permutations first.&lt;/li&gt;
  &lt;li&gt;Raku will automatically generate all permutations of a list with this function. It only works with &amp;lt;20 terms, which is perfect for this use case.&lt;/li&gt;
  &lt;li&gt;As I said in (1), we are reversing our list of permutations to start with the ones where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt; is greatest.&lt;/li&gt;
  &lt;li&gt;I have decided to start using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first: -&amp;gt; {}&lt;/code&gt; syntax for multi-line anonymous functions rather than the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first(-&amp;gt;  {})&lt;/code&gt; syntax, as I feel the trailing parenthesis looks out of place.&lt;/li&gt;
  &lt;li&gt;Raku allows us to unpack our individual permutation into variables, so &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$g&lt;/code&gt; are all assigned in this one line.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first&lt;/code&gt; returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; if it can’t find a match. &lt;em&gt;However&lt;/em&gt;, assigning &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; to a positional variable (denoted by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@&lt;/code&gt; sigil) will generate a list that looks like this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Any)]&lt;/code&gt;, so we check for size equal to 1 rather than checking if it is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;To get our numbers assigned to their letters, we need to zip them with the sequence &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt;. The output of this is a list that looks like this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((a 7) (b 3) (c 2) (d 5) (e 1) (f 4) (g 6))&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&amp;gt;&lt;/code&gt; syntax allows us to make a list of space-separated terms. It also makes each term a string automagically; it is basically shorthand for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;('a', 'b', 'c', 'd', 'e', 'f', 'g')&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;When we map over this list of pairs, we unpack each pair into its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$key&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$value&lt;/code&gt; and turn that into a string of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$key = $value&lt;/code&gt;. We then join this list of strings using newlines to match the provided output.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I’m always happy when I can find a functional solution to these problems, so I had fun this week. 🙂 See y’all next week!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Two fun tasks this week that were both able to be solved in a functional manner 🎉</summary></entry><entry><title type="html">Perl Weekly Challenge 108</title><link href="http://localhost:4000/blog/perl-weekly-challenge-108/" rel="alternate" type="text/html" title="Perl Weekly Challenge 108" /><published>2021-04-12T00:00:00-05:00</published><updated>2021-04-12T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-108</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-108/">&lt;p&gt;Task 1 this week is kind of a joke, but task 2 was interesting!&lt;/p&gt;

&lt;h2 id=&quot;task-1-locate-memory&quot;&gt;Task 1: Locate Memory&lt;/h2&gt;

&lt;p&gt;Write a script to declare a variable or constant and print its location in the memory.&lt;/p&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-108/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Any $variable) returns Int {
    $variable.WHERE;
}

sub MAIN {
    my $variable = rand;      # [1][2]
    say challenge($variable);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku
140444494947864
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Raku has the &lt;a href=&quot;https://docs.raku.org/routine/WHERE&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt;&lt;/a&gt; method built into it that “Returns an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; representing the memory address of the object,” we simply need to utilize that.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rand&lt;/code&gt; is a built-in subroutine that returns a random integer.&lt;/li&gt;
  &lt;li&gt;Following the Scala style, I would normally use parentheses for subroutines that are not “pure” and write this as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rand()&lt;/code&gt;, but Raku complains with the following error: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unsupported use of rand().  In Raku please use: rand.&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-bell-numbers&quot;&gt;Task 2: Bell Numbers&lt;/h2&gt;

&lt;p&gt;Write a script to display top 10 Bell Numbers. Please refer to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell_number&quot;&gt;Wikipedia page&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;B&lt;sub&gt;0&lt;/sub&gt;: 1, as you can only have one partition of zero element set.&lt;/li&gt;
  &lt;li&gt;B&lt;sub&gt;1&lt;/sub&gt;: 1, as you can only have one partition of one element set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{a}&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B&lt;sub&gt;2&lt;/sub&gt;: 2&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{a}{b}
{a,b}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B&lt;sub&gt;3&lt;/sub&gt;: 5&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{a}{b}{c}
{a,b}{c}
{a}{b,c}
{a,c}{b}
{a,b,c}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B&lt;sub&gt;4&lt;/sub&gt;: 15&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{a}{b}{c}{d}
{a,b,c,d}
{a,b}{c,d}
{a,c}{b,d}
{a,d}{b,c}
{a,b}{c}{d}
{a,c}{b}{d}
{a,d}{b}{c}
{b,c}{a}{d}
{b,d}{a}{c}
{c,d}{a}{b}
{a}{b,c,d}
{b}{a,c,d}
{c}{a,b,d}
{d}{a,b,c}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-108/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use experimental :cached;

sub challenge(Int $n where $n &amp;gt;= 0) is cached returns Int {            # [1]
    given $n {
        when 0|1 { 1 }
        default {
            my $n-minus-one = $n - 1;
            gather for (0..$n-minus-one) -&amp;gt; $k {                       # [2]
                take (^$n-minus-one).combinations($k) * challenge($k); # [2]
            }.sum
        }
    }
}

sub MAIN(Int $n = 10) {
    say (^$n).map(&amp;amp;challenge);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku
(1 1 2 5 15 52 203 877 4140 21147)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;!-- Allow inlining of math functionality --&gt;
&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], [&quot;\\(&quot;,&quot;\\)&quot;] ],
      processEscapes: true
    }
  });
&lt;/script&gt;

&lt;!-- Import math functionality --&gt;
&lt;script type=&quot;text/javascript&quot; async=&quot;&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The question asks for the “top 10 Bell Numbers.” Since this is an ever-increasing sequence, there is no “top,” so I interpreted that to mean &lt;em&gt;first&lt;/em&gt; 10 Bell numbers.&lt;/p&gt;

&lt;p&gt;At first glance, this code has nothing to do with the input sequences, but digging into the above-linked Wikipedia entry, we find this equation:&lt;/p&gt;

&lt;p&gt;$ B_{n+1} = \sum_{k=0}^{n}{n \choose k}B_{k} $&lt;/p&gt;

&lt;p&gt;This tells us that each Bell number is built upon by the previous Bell numbers. And we know the first two Bell numbers, so we can follow this.&lt;/p&gt;

&lt;p&gt;Let’s re-write this to calculate $ B_{2} $ and see how it works; remember, since we are calculating for $ B_{n+1} $, we use $ n = 1 $.&lt;/p&gt;

&lt;p&gt;$ B_{2} = \sum_{k=0}^{1}{1 \choose k}B_{k} $&lt;/p&gt;

&lt;p&gt;Which can be expanded as:&lt;/p&gt;

&lt;p&gt;$ B_{2} = {1 \choose 0}B_{0} + {1 \choose 1}B_{1} $&lt;/p&gt;

&lt;p&gt;Which can be reduced to:&lt;/p&gt;

&lt;p&gt;$ B_{2} = (1)(1) + (1)(1) = 2 $&lt;/p&gt;

&lt;p&gt;So $ B_{2} = 2 $ and we can use that to calculate $ B_{3} $ and so on.&lt;/p&gt;

&lt;p&gt;Now that we have the algorithm figured out, and decided we are going to apply it to the &lt;em&gt;first&lt;/em&gt; 10 terms, it’s a simple matter to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; the function over the sequence from 0 (inclusive) to 10 (exclusive).&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Since this is a recursive function, once we calculate $ B_{2} $ we will use it in $ B_{3} $, $ B_{4} $ and so on. No use re-calculating it every time, so we memoize this function using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is cached&lt;/code&gt; trait.&lt;/li&gt;
  &lt;li&gt;gather/take is a construct to build up a sequence using a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Supply&lt;/code&gt; (in this case, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&lt;/code&gt; loop).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I love me some pattern matching and recursion, coming from a Scala day job, so it is fun to use those constructs in other languages, especially Raku. 🙂&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Task 1 this week is kind of a joke, but task 2 was interesting!</summary></entry><entry><title type="html">Perl Weekly Challenge 107</title><link href="http://localhost:4000/blog/perl-weekly-challenge-107/" rel="alternate" type="text/html" title="Perl Weekly Challenge 107" /><published>2021-04-10T00:00:00-05:00</published><updated>2021-04-10T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-107</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-107/">&lt;p&gt;I wrote this week’s answers several days ago, but forgot to commit them. I ended up getting a new laptop and had to rewrite them. I think they ended up the same, but I guess no one knows for sure!&lt;/p&gt;

&lt;h2 id=&quot;task-1-self-descriptive-numbers&quot;&gt;Task 1: Self-descriptive Numbers&lt;/h2&gt;

&lt;p&gt;Write a script to display the first three self-descriptive numbers. As per &lt;a href=&quot;https://en.wikipedia.org/wiki/Self-descriptive_number&quot;&gt;wikipedia&lt;/a&gt;, the definition of “self-descriptive number” is:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In mathematics, a self-descriptive number is an integer m that in a given base b is b digits long in which each digit d at position n (the most significant digit being at position 0, and the least significant at position b−1) counts how many instances of digit n are in m.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1210 is a four-digit self-descriptive number:

    Position 0 has value 1 i.e. there is only one 0 in the number
    Position 1 has value 2 i.e. there are two 1 in the number
    Position 2 has value 1 i.e. there is only one 2 in the number
    Position 3 has value 0 i.e. there is no 3 in the number
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Expected output:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1210, 2020, 21200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-107/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Int $n) returns Str { # [1]
    my @output;
    for (^∞) -&amp;gt; $i {                # [2][3]
        my @digits = $i.comb;
        my $valid = True;
        for @digits.kv -&amp;gt; $index, $value {
            $valid = @digits.grep($index).elems == $value;
            last unless $valid;     # [4]
        }
        @output.push($i) if $valid; # [5]
        last if @output.elems == $n;
    }
    @output.join(', ');
}

sub MAIN(Int $n = 3) {
    say challenge($n);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku
1210, 2020, 21200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;We begin by defining a list to hold our output, then kick of an infinite loop starting at 0. For each number, we convert it to a list of digits (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.comb&lt;/code&gt;). For each index, value pair, we check if the input number has &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$value&lt;/code&gt; number of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$index&lt;/code&gt; digits. So for 1210 we would check if it had 1 zero, 2 ones, 1 two, and 0 threes. If it meets the conditions, we add it to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt;. Finally, if we have found all 3 that we are looking for, we break out of the infinite loop and return.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;We make this generic by accepting the argument &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt;, but the fourth self-describing number is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3,211,000&lt;/code&gt;, and the fifth is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;42,101,000&lt;/code&gt;, so this method would get slow very quickly.&lt;/li&gt;
  &lt;li&gt;We &lt;em&gt;could&lt;/em&gt; have said &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loop&lt;/code&gt; to start an infinite loop, but then we wouldn’t have access to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$i&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;When using this method, we always have to use the carrot (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^&lt;/code&gt;) to say we are not including infinity. This is because it is impossible to be inclusive of infinity.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unless&lt;/code&gt; is just the opposite of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt;. I feel this reads better than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;last if !$valid&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;I find the post-fix way of using conditionals to read better a lot of the time in Raku, as seen here.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-list-methods&quot;&gt;Task 2: List Methods&lt;/h2&gt;

&lt;p&gt;Write a script to list methods of a package/class.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;p&gt;Class definition:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package Calc;

use strict;
use warnings;

sub new { bless {}, shift; }
sub add { }
sub mul { }
sub div { }

1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Expected output:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BEGIN
mul
div
new
add
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-107/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Used for testing
class Calc {      # [1]
    method add {}
    method mul {}
    method div {}
}

sub challenge(Any $class) returns Str {     # [2]
    $class.^methods.map(*.gist).join(&quot;\n&quot;); # [3][4]
}

sub MAIN {
    say challenge(Calc.new);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku
add
mul
div
BUILDALL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The example shows a class definition in Perl, but we are using Raku, so we can just define our class using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt; keyword as shown. Additionally, we have a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BUILDALL&lt;/code&gt; method instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BEGIN&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Raku gives us the &lt;a href=&quot;https://docs.raku.org/language/classtut#Introspection&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^methods&lt;/code&gt;&lt;/a&gt; meta method to introspect an object’s methods, so we just have to utilize that on the input object!&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;In Perl, we have to define classes in their own file, but in Raku we can just use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt; keyword.&lt;/li&gt;
  &lt;li&gt;All objects inherit from &lt;a href=&quot;https://docs.raku.org/type/Any&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt;&lt;/a&gt;, so we are just saying we accept any class here.&lt;/li&gt;
  &lt;li&gt;Raku provides us a nice introspection method, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^methods&lt;/code&gt;, which returns a list of defined methods and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BUILDALL&lt;/code&gt;. We can also pass in the flag &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:local&lt;/code&gt; meaning “only show us methods defined in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Calc&lt;/code&gt; and not super classes,” or we could pass in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:all&lt;/code&gt; meaning “show us all methods that can act on this class.”&lt;/li&gt;
  &lt;li&gt;The returned type is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List[Method]&lt;/code&gt;, so to cast everything to a string, we need to call each method’s &lt;a href=&quot;https://docs.raku.org/routine/gist&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gist&lt;/code&gt;&lt;/a&gt; method.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Once again, Raku makes these challenges super easy. Looking forward to something tougher in the future!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">I wrote this week’s answers several days ago, but forgot to commit them. I ended up getting a new laptop and had to rewrite them. I think they ended up the same, but I guess no one knows for sure!</summary></entry><entry><title type="html">Perl Weekly Challenge 106</title><link href="http://localhost:4000/blog/perl-weekly-challenge-106/" rel="alternate" type="text/html" title="Perl Weekly Challenge 106" /><published>2021-03-29T00:00:00-05:00</published><updated>2021-03-29T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-106</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-106/">&lt;p&gt;Task 2 &lt;em&gt;seems&lt;/em&gt; like it would be difficult, but once again, Raku has built-in mechanisms to help us out!&lt;/p&gt;

&lt;h2 id=&quot;task-1-maximum-gap&quot;&gt;Task 1: Maximum Gap&lt;/h2&gt;

&lt;p&gt;You are given an array of integers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to display the maximum difference between two successive elements once the array is sorted.&lt;/p&gt;

&lt;p&gt;If the array contains only 1 element then display 0.&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @N = (2, 9, 3, 5)
Output: 4

Input: @N = (1, 3, 8, 2, 0)
Output: 5

Input: @N = (5)
Output: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-106/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@N where all(@N) ~~ Int) returns Int {   # [1]
    if @N.elems == 1 {
        0;
    } else {
        my @sorted = @N.sort;
        my @zipped = @sorted[0..*-1] Z @sorted[1..*];  # [2]
        @zipped.map(-&amp;gt; ($a, $b) { abs($b - $a) }).max; # [3]
    }
}

sub MAIN(*@N where all(@N) ~~ Int) {
    say challenge(@N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 2 9 3 5
4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This one is probably easier to walk through with an example. If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt; only has one element, we just return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;, so we won’t discuss that path.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We get this input: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N = (2, 9, 3, 5)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;We sort it so we have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@sorted = (2, 3, 5, 9)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;We generate two lists: One of everything but the last element (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@sorted[0..*-1] = (2, 3, 5)&lt;/code&gt;) and one of everything but the first element (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@sorted[1..*] = (3, 5, 9)&lt;/code&gt;). Then we zip them together so we have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@zipped = ((2, 3), (3, 5), (5, 9))&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;For each pair, we find the difference between the numbers, so we end up with this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 2, 4)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Finally, we call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.max&lt;/code&gt; and return the maximum difference, which is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4&lt;/code&gt; in this case.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Raku has so many different sequence types (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Positional&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Seq&lt;/code&gt;, etc.) that I have not figured out a good way to parameterize positional inputs. This is the best I can come up with, but for long sequences, it is incredibly slow.&lt;/li&gt;
  &lt;li&gt;The “whatever star” is signaling the last index of the list, in this case. So we are simply generating a list containing everything but the last item zipped with a list containing everything but the last item (see above for example).&lt;/li&gt;
  &lt;li&gt;In theory, we could have negative numbers in our input, so it is necessary to have the call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abs&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-decimal-string&quot;&gt;Task 2: Decimal String&lt;/h2&gt;

&lt;p&gt;You are given a numerator and denominator i.e. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$D&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to convert the fraction into decimal string. If the fractional part is recurring then put it in parentheses.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $N = 1, $D = 3
Output: &quot;0.(3)&quot;

Input: $N = 1, $D = 2
Output: &quot;0.5&quot;

Input: $N = 5, $D = 66
Output: &quot;0.0(75)&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-106/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Numeric $N, Numeric $D) returns Str {                  # [1]
    my ($base, $repeating) = ($N / $D).base-repeating;               # [2]
    $repeating = $repeating eq '' ?? $repeating !! &quot;\($repeating\)&quot;; # [3]
    $base ~ $repeating;                                              # [4]
}

sub MAIN(Numeric $N, Numeric $D) {
    say challenge($N, $D);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 1 7
0.(142857)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This looks suspiciously small for what seems like a complex problem. All the logic happens in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base-repeating&lt;/code&gt; (which I will detail below). All we have to do is supply the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt;, and the rest of the code is just for formatting!&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;In theory someone could pass in arbitrary decimal numbers, so we accept &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Numeric&lt;/code&gt; instead of just &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/base-repeating&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base-repeating&lt;/code&gt;&lt;/a&gt; operates on a &lt;a href=&quot;https://docs.raku.org/type/Rational&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rational&lt;/code&gt;&lt;/a&gt;, which is Raku’s way of saying fraction. It splits the fraction into pieces – the base and the repeating portion. For something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5 / 2&lt;/code&gt;, it would return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;('2.5', '')&lt;/code&gt;. For something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 / 3&lt;/code&gt;, we would get &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'0.', '3')&lt;/code&gt;. Once we have that, we just have to format like the question asks.&lt;/li&gt;
  &lt;li&gt;If the repeated section is empty, we want to just leave it alone. Otherwise, we want to wrap it in parentheses as the challenge states.&lt;/li&gt;
  &lt;li&gt;We could also have written &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;$base$repeating&quot;&lt;/code&gt; to concatenate the pieces, but that is harder to read, so I used the string concatenation operator (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I don’t know whether or not to consider it cheating when Raku has all the cool built-ins. I guess we’re just using the tools we are provided, but it feels too easy. 😅&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Task 2 seems like it would be difficult, but once again, Raku has built-in mechanisms to help us out!</summary></entry><entry><title type="html">Perl Weekly Challenge 105</title><link href="http://localhost:4000/blog/perl-weekly-challenge-105/" rel="alternate" type="text/html" title="Perl Weekly Challenge 105" /><published>2021-03-27T00:00:00-05:00</published><updated>2021-03-27T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-105</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-105/">&lt;p&gt;This week’s challenges are short and sweet, but still give us the opportunity to explore some interesting Raku-isms!&lt;/p&gt;

&lt;h2 id=&quot;task-1-nth-root&quot;&gt;Task 1: Nth root&lt;/h2&gt;

&lt;p&gt;You are given positive numbers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$k&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to find out the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;th root of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$k&lt;/code&gt;. For more information, please take a look at the &lt;a href=&quot;https://en.wikipedia.org/wiki/Nth_root#Computing_principal_roots&quot;&gt;wiki page&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $N = 5, $k = 248832
Output: 12

Input: $N = 5, $k = 34
Output: 2.02
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-105/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Numeric $N, Numeric $k) returns Str { # [1]
    my $root = $k ** (1 / $N);
    $root.round(.01).Str;                           # [2]
}

sub MAIN(Num $N, Num $k) {
    say challenge($N, $k);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 5 248832
12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;!-- Allow inlining of math functionality --&gt;
&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], [&quot;\\(&quot;,&quot;\\)&quot;] ],
      processEscapes: true
    }
  });
&lt;/script&gt;

&lt;!-- Import math functionality --&gt;
&lt;script type=&quot;text/javascript&quot; async=&quot;&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
&lt;/script&gt;

&lt;p&gt;This solution relies on the fact that $ \sqrt[N]{k} $ can be rewritten as $ k^{1/N} $ (which is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$k ** (1 / $N)&lt;/code&gt; in Raku). So we simply have to do that and round to the appropriate amount of decimal places (the example shows 2 or less, so that is what we do as well).&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;The examples just show integers, but this function should theoretically be able to take any numeric value, so we use &lt;a href=&quot;https://docs.raku.org/type/Numeric&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Numeric&lt;/code&gt;&lt;/a&gt; for both of our input types.&lt;/li&gt;
  &lt;li&gt;Raku’s &lt;a href=&quot;https://docs.raku.org/routine/round&quot;&gt;round&lt;/a&gt; function is interesting in that you don’t specify the number of decimals, you specify some arbitrary scale, and it will round to the &lt;em&gt;closest multiple of that scale&lt;/em&gt;. So &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; would round to an integer and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.01&lt;/code&gt; would round to two decimals. Additionally, it will drop trailing zeros (and even the decimal if the rounded number only has zeros as decimals).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-the-name-game&quot;&gt;Task 2: The Name Game&lt;/h2&gt;

&lt;p&gt;You are given a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$name&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to display the lyrics to the Shirley Ellis song The Name Game. Please checkout the &lt;a href=&quot;https://en.m.wikipedia.org/wiki/The_Name_Game&quot;&gt;wiki page&lt;/a&gt; for more information.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $name = &quot;Katie&quot;
Output:

    Katie, Katie, bo-batie,
    Bonana-fanna fo-fatie
    Fee fi mo-matie
    Katie!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-105/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Str $name) returns Str {
    my $X = $name.wordcase;                                             # [1]
    my $Y = $X ~~ /^[A|E|I|O|U|Y]&amp;lt;-[aeiouy]&amp;gt;/ ?? $X.lc !! $X.substr(1); # [2]

    qq:to/END/;                                                         # [3]
    $X, $X, bo-{$X.starts-with('B') ?? '' !! 'b'}$Y                     # [4]
    Bonana-fanna fo-{$X.starts-with('F') ?? '' !! 'f'}$Y
    Fee fi mo-{$X.starts-with('M') ?? '' !! 'm'}$Y
    $X!
    END
}

sub MAIN(Str $name) {
    say challenge($name);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku Aaron
Aaron, Aaron, bo-baron
Bonana-fanna fo-faron
Fee fi mo-maron
Aaron!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;According to the wikipedia page, the structure can be broken down like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(X), (X), bo-b(Y)
Bonana-fanna fo-f(Y)
Fee fi mo-m(Y)
(X)!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The only caveat it adds is:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;If the name starts with a b, f, or m, that sound simply is not repeated. For example: Billy becomes &quot;Billy Billy bo-illy&quot;; Fred becomes &quot;bonana fanna fo-red&quot;; Marsha becomes &quot;fee fi mo-arsha&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I actually don’t think this caveat is enough. For example, my son’s name is Everett, and if we just cut off the first letter of his name as the wiki suggests, we would get things like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bverett&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fverett&lt;/code&gt;. So, I added an additional stipulation: any name that starts with a vowel followed by a consonant should keep the &lt;em&gt;entirety&lt;/em&gt; of the name as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Y&lt;/code&gt;, otherwise it is just &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X&lt;/code&gt; minus the first letter.&lt;/p&gt;

&lt;p&gt;Once we have found &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Y&lt;/code&gt;, we just slot them into the song. Easy peasy!&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/wordcase&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wordcase&lt;/code&gt;&lt;/a&gt; makes the first letter uppercase, and the rest lowercase.&lt;/li&gt;
  &lt;li&gt;This checks to see if the first letter is a vowel (including &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Y&lt;/code&gt;) directly followed a consonant. If that is the case, keep the entirety of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$X&lt;/code&gt; and just convert it to lowercase to make sense in the song. Otherwise, take the &lt;a href=&quot;https://docs.raku.org/routine/substr&quot;&gt;substring&lt;/a&gt; of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$X&lt;/code&gt; from index 1 to the end.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/language/quoting#Heredocs:_:to&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;qq&lt;/code&gt;&lt;/a&gt; is an easy way to make multi-line strings that include interpolation. In this case, we say “the rest of this up until &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;END&lt;/code&gt; is a literal string.” Additionally, since all lines are indented to the same depth, it strips of leading indentation.&lt;/li&gt;
  &lt;li&gt;Since this whole construct is interpolated, we are able to embed the special cases for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M&lt;/code&gt; directly into the output string.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Like I said, short and sweet! See y’all next week!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">This week’s challenges are short and sweet, but still give us the opportunity to explore some interesting Raku-isms!</summary></entry><entry><title type="html">Perl Weekly Challenge 104</title><link href="http://localhost:4000/blog/perl-weekly-challenge-104/" rel="alternate" type="text/html" title="Perl Weekly Challenge 104" /><published>2021-03-21T00:00:00-05:00</published><updated>2021-03-21T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-104</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-104/">&lt;p&gt;This week had some fun topics like &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_(computer_science)&quot;&gt;recursion&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoization&lt;/a&gt;, and IO/data validation!&lt;/p&gt;

&lt;h2 id=&quot;task-1-fusc-sequence&quot;&gt;Task 1: FUSC Sequence&lt;/h2&gt;

&lt;p&gt;Write a script to generate first 50 members of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FUSC&lt;/code&gt; Sequence. Please refer to &lt;a href=&quot;http://oeis.org/A002487&quot;&gt;OEIS&lt;/a&gt; for more information.&lt;/p&gt;

&lt;p&gt;The sequence defined as below:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fusc(0) = 0
fusc(1) = 1
for n &amp;gt; 1:
when n is even: fusc(n) = fusc(n / 2),
when n is odd: fusc(n) = fusc((n-1)/2) + fusc((n+1)/2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use experimental :cached; # [1]

sub fusc(Int(Rat) $n) is cached returns Int { # [2]
    given $n {
        when 0      { 0 }
        when 1      { 1 }
        when * %% 2 { fusc($n / 2) }                            # [3]
        default     { fusc(($n - 1) / 2) + fusc(($n + 1) / 2) } # [4]
    }
}

sub MAIN(Int $terms = 50) {
    say (^$terms).map(&amp;amp;fusc); # [4]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku
(0 1 1 2 1 3 2 3 1 4 3 5 2 5 3 4 1 5 4 7 3 8 5 7 2 7 5 8 3 7 4 5 1 6 5 9 4 11 7 10 3 11 8 13 5 12 7 9 2 9)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I feel like this is pretty straight forward, and aligns well to the definition of the FUSC sequence. When we look at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt;, we run through the following logic:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Is it 0? Return 0.&lt;/li&gt;
  &lt;li&gt;Is it 1? Return 1.&lt;/li&gt;
  &lt;li&gt;Is it even? Return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc($n / 2)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Otherwise, return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(($n - 1) / 2) + fusc(($n + 1) / 2)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The function recurses until it ends up in one of the two stopping conditions (0 or 1). So obviously &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(50)&lt;/code&gt; is going to go through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(49)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(48)&lt;/code&gt;, etc. See below for how we make this efficient.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Caching in Raku is an experimental feature, so we have to import it (and add the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is cached&lt;/code&gt; trait to our subroutine). The basic idea is that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc($n)&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; the same value, so once we calculate it once, we can just look it up later. Adding this trait essentially adds a hash behind the scenes that checks if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc($n)&lt;/code&gt; already exists. If it does, it just returns that value, otherwise, it will actually calculate the value and store it in the hash before returning.&lt;/li&gt;
  &lt;li&gt;Notice the function signature takes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int(Rat)&lt;/code&gt;. This means that this function will accept either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; &lt;em&gt;or&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rat&lt;/code&gt; (&lt;a href=&quot;https://docs.raku.org/type/Rat&quot;&gt;Rational number&lt;/a&gt;) types, but it will coerce the input to an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;. The reason for this is that division in Raku will generate a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rat&lt;/code&gt; type, even for something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2 / 1&lt;/code&gt;. So we need to convert it to an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; on the recursive calls. This saves use from having to write &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(($n / 2).Int)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Raku has a special “is divisible by” operator. So instead of saying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n % 2 == 0&lt;/code&gt;, we can say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n %% 2&lt;/code&gt;. Also notice that in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; block, we have to use the “whatever star” (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;) to do this operation; this is because we can’t &lt;a href=&quot;https://docs.raku.org/language/operators#index-entry-smartmatch_operator&quot;&gt;smartmatch&lt;/a&gt; against &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%% 2&lt;/code&gt;, so we need to be more explicit.&lt;/li&gt;
  &lt;li&gt;Remember when passing a function as an argument (in this case to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;), it has a special &lt;a href=&quot;https://docs.raku.org/language/variables#index-entry-sigil_&amp;amp;&quot;&gt;sigil&lt;/a&gt; – &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-nim-game&quot;&gt;Task 2: NIM Game&lt;/h2&gt;

&lt;p&gt;Write a script to simulate the NIM Game.&lt;/p&gt;

&lt;p&gt;It is played between 2 players. For the purpose of this task, let assume you play against the machine.&lt;/p&gt;

&lt;p&gt;There are 3 simple rules to follow:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) You have 12 tokens
b) Each player can pick 1, 2 or 3 tokens at a time
c) The player who picks the last token wins the game
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Formats a message defined as plural to be singular if $n == 1
sub format(Str $message, Int $n) returns Str {
    $n == 1 ?? $message.trans(['are', 'tokens'] =&amp;gt; ['is', 'token']) !! $message; # [1]
}

sub challenge(Int $n) {
    my $remaining = $n;

    # Defined within the challenge sub because it references $remaining
    sub default-prompt returns Any {
        prompt(format(&quot;There are $remaining tokens. How many would you like to pick up? (1, 2, 3) &quot;, $remaining)); # [2]
    }

    my $input = default-prompt;
    my $most-recent-move;
    while $remaining &amp;gt; 0 {
        given $input {
            when 1|2|3 {
                if $input &amp;gt; $remaining {
                    $input = prompt(&quot;There are only $remaining tokens left. Please enter a valid number &quot;)
                } else {
                    say format(&quot;You take $input tokens&quot;, $input);
                    $remaining -= $input;
                    $most-recent-move = 'You';

                    last if $remaining == 0;

                    # If there are only 3 or less tokens, take all of them. Otherwise, take a random number between 1 and 3
                    my $bot-move = $remaining ~~ 1|2|3 ?? $remaining !! (1..3).pick;
                    say format(&quot;The computer takes $bot-move tokens&quot;, $bot-move);
                    $remaining -= $bot-move;
                    $most-recent-move = 'Computer';

                    last if $remaining == 0;

                    $input = default-prompt;
                }
            }
            default { $input = prompt('Please enter 1, 2, or 3 ') }
        }
    }
    say $most-recent-move eq 'Computer' ?? 'The computer wins!' !! 'You win!'; # [3]
}

sub MAIN(Int $n where $n &amp;gt; 0 = 12) { # [4]
    challenge($n);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku
There are 12 tokens. How many would you like to pick up? (1, 2, 3) 3
You take 3 tokens
The computer takes 3 tokens
There are 6 tokens. How many would you like to pick up? (1, 2, 3) 2
You take 2 tokens
The computer takes 3 tokens
There is 1 token. How many would you like to pick up? (1, 2, 3) 1
You take 1 token
You win!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This task is basically an exercise in IO (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prompt&lt;/code&gt;) and data validation (did I get what I expect?). We follow the following steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Ask the user to give us a number (1, 2, or 3).
    &lt;ul&gt;
      &lt;li&gt;Did they give it to us? Move on to step 2.&lt;/li&gt;
      &lt;li&gt;Otherwise, keep asking for a valid input (doesn’t matter if they gave us an invalid number, a string, etc.).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Do a special check to see if their number is higher than the remaining tokens (only happens when there are 3 or fewer tokens). If so, keep prompting them for a valid input.&lt;/li&gt;
  &lt;li&gt;Now that we know we have valid input, decrement &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$remaining&lt;/code&gt; to reflect the number of token the user took.&lt;/li&gt;
  &lt;li&gt;If there are 0 tokens left, exit the loop and print that the user won.&lt;/li&gt;
  &lt;li&gt;Otherwise, there are tokens left, and it is the computer’s turn. Our bot is semi-smart, so if there are 3 or fewer tokens take all of them (and win). Otherwise, take a random valid number of tokens.&lt;/li&gt;
  &lt;li&gt;If there are 0 tokens left, exit the loop and print that th computer won.&lt;/li&gt;
  &lt;li&gt;Finally, if there are still tokens left, repeat steps 1-6 until there are 0 tokens left.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;This is simply a helper function, so we can write all of our prompts like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;There are $n tokens remaining&quot;&lt;/code&gt; and they will get properly formatted if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; is 1. This is very specific to this question, obviously, but it is useful. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trans&lt;/code&gt; basically just translates all &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;are&lt;/code&gt; instances to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is&lt;/code&gt; and all &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tokens&lt;/code&gt; instances to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;token&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;You’ll notice a few things about this subroutine. First, we don’t have to define it with parentheses if it doesn’t take any arguments. Second, it returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt; because we don’t know what we are going to get from the user. Third, it is defined &lt;em&gt;inside&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; because it is acting as a &lt;a href=&quot;https://simple.wikipedia.org/wiki/Closure_(computer_science)&quot;&gt;closure&lt;/a&gt;, meaning it references variables defined outside itself (in this case, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$remaining&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Raku is kind of strange in that if you want to do string equality you have to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eq&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;This function signature specifies that it takes an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; that is greater than 0, and if it is not provided, it defaults to 12.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Raku gives us some cool tools to make these challenges easier. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; syntax was especially helpful in both of these challenges (and in others)!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">This week had some fun topics like recursion, memoization, and IO/data validation!</summary></entry></feed>