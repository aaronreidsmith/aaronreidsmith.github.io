<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-12-01T16:51:26-06:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Aaron Smith</title><subtitle>Personal website and blog of Aaron Smith</subtitle><author><name>Aaron Smith</name></author><entry><title type="html">Advent of Code: Day 1</title><link href="http://localhost:4000/blog/advent-of-code-day-01/" rel="alternate" type="text/html" title="Advent of Code: Day 1" /><published>2020-12-01T00:00:00-06:00</published><updated>2020-12-01T07:40:30-06:00</updated><id>http://localhost:4000/blog/advent-of-code-day-01</id><content type="html" xml:base="http://localhost:4000/blog/advent-of-code-day-01/">&lt;p&gt;Turns out I started blogging just in time for the &lt;a href=&quot;https://adventofcode.com/&quot;&gt;Advent of Code&lt;/a&gt;, an annual series of daily challenges that run from December 1st to December 25th.&lt;/p&gt;

&lt;p&gt;These problems remind me a lot of &lt;a href=&quot;https://projecteuler.net/&quot;&gt;Project Euler&lt;/a&gt;, because they are not concerned with the readbility or speed of your code, just the output. That means that any goals one wishes to accomplish should be set personally (there &lt;em&gt;is&lt;/em&gt; technically a leaderboard, but I find you have to be online very late at night to catch the posts and it is not worth the stress during the holiday season).&lt;/p&gt;

&lt;p&gt;My goal, as you may have guessed from my previous posts, is to complete these challenges in &lt;em&gt;at least&lt;/em&gt; Raku and to do so utilizing a functional programming paradigm. Let’s dive into day 1 and see if I can do it!&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;

&lt;p&gt;I am not going to copy and paste the explanation of the problem here like I do for the Perl Weekly Challenge, because it is &lt;em&gt;so&lt;/em&gt; long and I want to encourage users to go attempt the challenge themselves! Instead, I will write a summary of what the challenge is and my solution.&lt;/p&gt;

&lt;h3 id=&quot;part-1&quot;&gt;Part 1&lt;/h3&gt;

&lt;p&gt;Given a file full of integers (one per line), find the single pair of integers that adds up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2020&lt;/code&gt;, then find the product of those two numbers.&lt;/p&gt;

&lt;h4 id=&quot;solution&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/01/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implemenation specific comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($file) {
    say $file.IO.lines                           # [1]
          .combinations(2)                       # [2]
          .grep(-&amp;gt; ($a, $b) { $a + $b == 2020 }) # [3]
          .map(-&amp;gt; ($a, $b) { $a * $b })          # [4]
          .head;                                 # [5]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku main.raku input.txt
1020036
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;This is fairly straight forward and I feel Raku reads very cleanly. Basically, we read the entire file into a list (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IO.lines&lt;/code&gt;), then find all the pairs in that list, filter those pairs down to where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a + $b == 2020&lt;/code&gt;, then multiply those two numbers together!&lt;/p&gt;

&lt;h5 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;I’m a sucker for good IO. I feel reading/writing files in languages like Java or Scala is so cumbersome that I try to avoid it at all costs. Languages like Raku were &lt;em&gt;built&lt;/em&gt; for text manipultion, so it makes sense that the IO is great, but I just wanted to call out how easy it is to get the lines of a file in a list.&lt;/li&gt;
  &lt;li&gt;As I said in my &lt;a href=&quot;https://aaronreidsmith.github.io/blog/perl-weekly-challenge-089/#specific-comments&quot;&gt;previous post&lt;/a&gt;, I see the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;combinations&lt;/code&gt; feature coming back a lot in these puzzles. I love that it is built right in.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt; is familiar to most &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*nix&lt;/code&gt; users, and it is the equivalent of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter&lt;/code&gt; in more traditional functional languages. In this case, we are filtering down to only pairs that add up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2020&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;At this point this list looks like this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(($a, $b))&lt;/code&gt;, so we still want to map over the outer list and multiply the pair together.&lt;/li&gt;
  &lt;li&gt;Since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; returns a list, we need to grab the first item from that list for pretty printing.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;part-2&quot;&gt;Part 2&lt;/h3&gt;

&lt;p&gt;Given the same file as before, find the &lt;em&gt;3&lt;/em&gt; numbers that add up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2020&lt;/code&gt; and find their product.&lt;/p&gt;

&lt;h4 id=&quot;solution-1&quot;&gt;Solution&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code/blob/main/2020/01/raku/main.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implemenation specific comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($file, Bool :$p2 = False) {                # [1]
    say $file.IO.lines
          .combinations($p2 ?? 3 !! 2)              # [2]
          .grep(-&amp;gt; @combo { ([+] @combo) == 2020 }) # [3]
          .map(-&amp;gt; @combo { [*] @combo })
          .head;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Part 1
$ raku main.raku input.txt
1020036

# Part 2
$ raku main.raku --p2 input.txt
286977330
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h4&gt;

&lt;p&gt;Since it is basically the same problem, it only makes sense to modify the script we have already written rather than starting from scratch. Basically, everywhere where we hardcoded &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a, $b&lt;/code&gt; needs to be generalized to some list. In this case, we added a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;p2&lt;/code&gt; CLI flag that allows the users to specify if they are doing part 1 or part 2. If they are doing part 2 we find trios instead of pairs, then perform the same “business logic” on that collection.&lt;/p&gt;

&lt;h5 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h5&gt;

&lt;ol&gt;
  &lt;li&gt;Using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:$p2&lt;/code&gt; notation says to Raku “create a command line flag called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--p2&lt;/code&gt; and assign it to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$p2&lt;/code&gt; with a default of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;”. Creating command line interfaces can be kind of a pain in a lot of languages, so I am happy that is built right into the language.&lt;/li&gt;
  &lt;li&gt;This is the check to see if we are doing part 1 or part 2. Raku’s ternary operator is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;condition ?? true !! false&lt;/code&gt; rather than the traditional &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;condition ? true : false&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Since we have to remove all the pair hardcoding, we can generalize it as a list called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@combo&lt;/code&gt; and then just find the sum of the entire combo using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[+]&lt;/code&gt; meta operator. We perform a similar generalization for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; step.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;So far so good with my goal to write Raku solutions functionally! Check my &lt;a href=&quot;https://github.com/aaronreidsmith/advent-of-code&quot;&gt;GitHub&lt;/a&gt; to see any other solutions (and any other languages, if I get around to them). This was a fun little dip into the Advent of Code, and I am looking forward to the rest of the month!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Advent of Code" /><category term="Raku" /><summary type="html">Turns out I started blogging just in time for the Advent of Code, an annual series of daily challenges that run from December 1st to December 25th.</summary></entry><entry><title type="html">Perl Weekly Challenge 89</title><link href="http://localhost:4000/blog/perl-weekly-challenge-089/" rel="alternate" type="text/html" title="Perl Weekly Challenge 89" /><published>2020-11-30T00:00:00-06:00</published><updated>2020-12-01T07:40:30-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-089</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-089/">&lt;p&gt;Back again with challenge 89! I was able to tackle this one the day it was released, but I doubt that will be the case going forward.&lt;/p&gt;

&lt;p&gt;Once again, it seems the first task can be tackled easily in a functional way and the second one ends up being more imperative. Hoping I can try to do more things functionally in the future!&lt;/p&gt;

&lt;h2 id=&quot;task-1-gcd-sum&quot;&gt;Task 1: GCD Sum&lt;/h2&gt;

&lt;p&gt;You are given a positive integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to sum &lt;a href=&quot;https://en.wikipedia.org/wiki/Greatest_common_divisor&quot;&gt;GCD&lt;/a&gt; of all possible unique pairs between 1 and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 3
Output: 3

gcd(1,2) + gcd(1,3) + gcd(2,3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 4
Output: 7

gcd(1,2) + gcd(1,3) + gcd(1,4) + gcd(2,3) + gcd(2,4) + gcd(3,4)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-089/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any specific implementation comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub MAIN($N where $N ~~ Int &amp;amp;&amp;amp; $N &amp;gt; 0) {
    my @pairs = (1..$N).combinations(2);                    # [1]
    say [+] @pairs.map(-&amp;gt; @pair { @pair[0] gcd @pair[1] }); # [2][3]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 3
3

$ raku ch-1.raku 4
7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The thought process here is pretty straight forward:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Find all pairs from 1 to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Find the GCD of each pair&lt;/li&gt;
  &lt;li&gt;Sum the GCDs produced in step 2&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You’ll see my functional programming background bubbling up again. In fact, this could honestly be a one-liner if I weren’t going for readability:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;say [+] (1..$N).combinations(2).map(-&amp;gt; @pair { @pair[0] gcd @pair[1] });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Raku provided a great subroutine to find all the pairs in a list (&lt;a href=&quot;https://docs.raku.org/routine/combinations&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;combinations&lt;/code&gt;&lt;/a&gt;). In fact, it is generalized such that you can take more than just pairs (if I didn’t provide a number, it would find &lt;em&gt;all&lt;/em&gt; combinations from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size=0&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;size=$N&lt;/code&gt;), so it may come back in future problems!&lt;/li&gt;
  &lt;li&gt;This was an interesting one for me. In Scala, since it is so strongly and statically typed, we know that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@pairs&lt;/code&gt; list contains lists itself, so you could just say: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pairs.map(_._1 gcd _._2)&lt;/code&gt;. In Raku, I had to use the &lt;a href=&quot;https://docs.raku.org/language/functions#Blocks_and_lambdas&quot;&gt;pointy block&lt;/a&gt; notation to give the mapped items a name and, more importantly, a sigil to treat it as a list.&lt;/li&gt;
  &lt;li&gt;I &lt;em&gt;love&lt;/em&gt; that a lot of simple things (like &lt;a href=&quot;https://docs.raku.org/routine/gcd&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gcd&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.raku.org/routine/is-prime&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is-prime&lt;/code&gt;&lt;/a&gt;) are built right into Raku. It saves a lot of boilerplate code and potentially bad implementation of these functions.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-magic-matrix&quot;&gt;Task 2: Magic Matrix&lt;/h2&gt;

&lt;p&gt;Write a script to display matrix as below with numbers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 - 9&lt;/code&gt;. Please make sure numbers are used once.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ a b c ]
[ d e f ]
[ g h i ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So that it satisfies the following:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a + b + c = 15
d + e + f = 15
g + h + i = 15
a + d + g = 15
b + e + h = 15
c + f + i = 15
a + e + i = 15
c + e + g = 15
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-089/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset OddPositiveInt of Int where { $_ ~~ Int &amp;amp;&amp;amp; $_ &amp;gt; 0 &amp;amp;&amp;amp; !($_ %% 2) }

sub MAIN($side-length where $side-length ~~ OddPositiveInt = 3, $debug where $debug ~~ Bool = False) {
    my @matrix = generate-matrix($side-length);
    my @filled-in-matrix = fill-in-matrix(@matrix, $side-length);
    for @filled-in-matrix -&amp;gt; @row {
        say '[ ' ~ @row.join(' ') ~ ' ]';
    }
    if $debug {
        print &quot;\n&quot;;
        validate-matrix(@filled-in-matrix, $side-length);
    }
}

# Generate a 2D matrix that we can fill in with the proper numbers.
# For 3x3 it would output:
#  [0 0 0]
#  [0 0 0]
#  [0 0 0]
sub generate-matrix($side-length) {
    my @matrix = Array.new;
    for ^$side-length -&amp;gt; $i {
        my @row = Array.new;
        for (($i * $side-length) + 1..($i * $side-length) + $side-length) {
            @row.push(0);
        }
        @matrix.push(@row);
    }
    @matrix
}

# Actual business logic here. It takes the empty array and fills it in to be &quot;magic&quot;
# Such that all rows, columns, and the two diagonals add up to $side-length * ($side-length² + 1) / 2
sub fill-in-matrix(@matrix, $side-length) {
    my $num = 1;
    my $row = floor($side-length / 2);
    my $col = $side-length - 1;

    while $num &amp;lt;= $side-length² {                # [1]
        if $row == -1 &amp;amp;&amp;amp; $col == $side-length {  # Condition 3 (see below)
            $col = $side-length - 2;
            $row = 0;
        } else {
            if $col == $side-length {            # Condition 1 (see below)
                $col = 0;
            }
            if $row &amp;lt; 0 {
                $row = $side-length - 1;
            }
        }
        if @matrix[$row][$col] != 0 {           # Condition 2 (see below)
            $col -= 2;
            $row++;
        } else {
            @matrix[$row][$col] = $num;
            $num++;
            $col++;
            $row--;
        }
    }
    @matrix;
}

# Helper function to validate output matrix and print the validation
sub validate-matrix(@matrix, $side-length) {
    my @rows = @matrix;
    my @columns = [Z] @matrix;                                                   # [2]
    my @diagonal = @matrix.kv.map(-&amp;gt; $i, @row { @row[$i] });
    my @counter-diagonal = @matrix.kv.map(-&amp;gt; $i, @row { @row[*-$i-1] });

    my $target = ($side-length * ($side-length² + 1) / 2).Int;

    my $valid-rows = so @rows.map(-&amp;gt; @row { [+] @row }).all == $target;          # [3]
    my $valid-cols = so @columns.map(-&amp;gt; @column { [+] @column }).all == $target;
    my $valid-diag = so ([+] @diagonal) == $target;
    my $valid-counter-diag = so ([+] @counter-diagonal) == $target;

    if $valid-rows &amp;amp;&amp;amp; $valid-cols &amp;amp;&amp;amp; $valid-diag &amp;amp;&amp;amp; $valid-counter-diag {
        for @rows -&amp;gt; @row {
            say @row.join(' + ') ~ ' = ' ~ $target;
        }
        for @columns -&amp;gt; @column {
            say @column.join(' + ') ~ ' = ' ~ $target;
        }
        say @diagonal.join(' + ') ~ ' = ' ~ $target;
        say @counter-diagonal.join(' + ') ~ ' = ' ~ $target;
    } else {
        die &quot;Not a valid magic matrix&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku
[ 2 7 6 ]
[ 9 5 1 ]
[ 4 3 8 ]

# There is an optional `debug` parameter that can be supplied, but the `side-length` argument must also be provided
$ raku ch-2.raku 3 True
[ 2 7 6 ]
[ 9 5 1 ]
[ 4 3 8 ]

2 + 7 + 6 = 15
9 + 5 + 1 = 15
4 + 3 + 8 = 15
2 + 9 + 4 = 15
7 + 5 + 3 = 15
6 + 1 + 8 = 15
2 + 5 + 8 = 15
6 + 5 + 4 = 15
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It should be noted this program only works with odd side-length squares&lt;/p&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Full disclosure, I have done this problem before, so I basically just ported some old code. There are two steps to this problem before we even get to implementation:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Find the pattern for what the sum is
    &lt;ul&gt;
      &lt;li&gt;As seen in the code, you will find it is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N(N²+1)/2&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Draw some “magic matrices” to see if you can find any patterns&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;You will find 3 patterns hold true (I am copying these from &lt;a href=&quot;https://www.geeksforgeeks.org/magic-square/&quot;&gt;Geeks for Geeks&lt;/a&gt;):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The position of next number is calculated by decrementing row number of the previous number by 1, and incrementing the column number of the previous number by 1. At any time, if the calculated row position becomes -1, it will wrap around to n-1. Similarly, if the calculated column position becomes n, it will wrap around to 0.&lt;/li&gt;
  &lt;li&gt;If the magic square already contains a number at the calculated position, calculated column position will be decremented by 2, and calculated row position will be incremented by 1.&lt;/li&gt;
  &lt;li&gt;If the calculated row position is -1 &amp;amp; calculated column position is n, the new position would be: (0, n-2).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Basically, we just start in the middle right square and apply the above criteria iteratively and it works for any odd-side-lengthed square.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Raku supports Unicode, so you’ll notice I used &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$side-length²&lt;/code&gt; rather than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$side-length ** 2&lt;/code&gt;. It’s a small feature that I find helps readibilty (but can be hard to write)!&lt;/li&gt;
  &lt;li&gt;This has been called out as a &lt;a href=&quot;https://docs.raku.org/language/traps#Using_[%E2%80%A6]_metaoperator_with_a_list_of_lists&quot;&gt;trick to avoid&lt;/a&gt; because it fails when you get a matrix with 1 row. Since it is being used in a debugging function and if we &lt;em&gt;did&lt;/em&gt; get a 1-row matrix it would be 1x1, so I think it is safe to use here&lt;/li&gt;
  &lt;li&gt;I don’t really like that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;so&lt;/code&gt; is the subroutine used to cast input to a boolean, so I just wanted to call out that (a) that is what these lines are doing and (b) I don’t like the terminology.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I’m really glad I decided to start doing these challenges weekly, and I may even go back and attempt old challenges if I have time.&lt;/p&gt;

&lt;p&gt;With that being said, I am kind of disappointed in myself for just copying old code for task two. For one, I have grown as a programmer since writing that, and two, it seems past-me just copied that code from somewhere on the internet. While it was kind of challenging porting it to Raku, I feel like it was the lazy way out.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Back again with challenge 89! I was able to tackle this one the day it was released, but I doubt that will be the case going forward.</summary></entry><entry><title type="html">Perl Weekly Challenge 88</title><link href="http://localhost:4000/blog/perl-weekly-challenge-088/" rel="alternate" type="text/html" title="Perl Weekly Challenge 88" /><published>2020-11-29T00:00:00-06:00</published><updated>2020-12-01T07:40:30-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-088</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-088/">&lt;p&gt;I have always been a fan of Perl (and its younger brother Raku), but, since leaving the Bioinformatics world, have not found any real-world scenarios to flex those muscles.&lt;/p&gt;

&lt;p&gt;I recently stumbled upon the &lt;a href=&quot;https://perlweeklychallenge.org/&quot;&gt;Perl Weekly Challenge&lt;/a&gt; and decided it would be a great way to keep up-to-date with the community. I participated for the first time this week and thought it would be fun to do a write up of how I approached the problems. In the future, I will start publishing my blogs earlier in the week so that I can include a link to it in my PR.&lt;/p&gt;

&lt;p&gt;So, without further adieu, let’s dive in.&lt;/p&gt;

&lt;h2 id=&quot;task-1-array-of-product&quot;&gt;Task 1: Array of Product&lt;/h2&gt;

&lt;p&gt;You are given an array of positive integers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to return an array &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@M&lt;/code&gt; where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$M[i]&lt;/code&gt; is the product of all elements of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt; except the index &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N[i]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    @N = (5, 2, 1, 4, 3)
Output:
    @M = (24, 60, 120, 30, 40)

    $M[0] = 2 x 1 x 4 x 3 = 24
    $M[1] = 5 x 1 x 4 x 3 = 60
    $M[2] = 5 x 2 x 4 x 3 = 120
    $M[3] = 5 x 2 x 1 x 3 = 30
    $M[4] = 5 x 2 x 1 x 4 = 40
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    @N = (2, 1, 4, 3)
Output:
    @M = (12, 24, 6, 8)

    $M[0] = 1 x 4 x 3 = 12
    $M[1] = 2 x 4 x 3 = 24
    $M[2] = 2 x 1 x 3 = 6
    $M[3] = 2 x 1 x 4 = 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any specific implementation comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset PositiveInt of Int where { $_ ~~ Int &amp;amp;&amp;amp; $_ &amp;gt; 0 } # [1]

sub MAIN(*@N where all(@N) ~~ PositiveInt &amp;amp;&amp;amp; @N.elems &amp;gt; 0) {
    my $product = [*] @N;         # [2]
    my @M = @N.map: $product / *; # [3]
    say @M;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 5 2 1 4 3
[24 60 120 30 40]

$ raku ch-1.raku 2 1 4 3
[12 24 6 8]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;My day job is 100% Scala, so I try to approach everything with an immutable and functional approach, ideally with only one pass through the input list.&lt;/p&gt;

&lt;p&gt;The approach I took reminded me of multiplying fractions by the unit fraction to remove the denominator. For example &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1/4 x 4/4 = 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is the approach applied to example 1 above:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$M[0] = (5 x 2 x 1 x 4 x 3) / 5 = 24
$M[1] = (5 x 2 x 1 x 4 x 3) / 2 = 60
$M[2] = (5 x 2 x 1 x 4 x 3) / 1 = 120
$M[3] = (5 x 2 x 1 x 4 x 3) / 4 = 30
$M[4] = (5 x 2 x 1 x 4 x 3) / 3 = 40
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The problem states we are given an array of positive integers, but it never hurts to validate. Raku gives us the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subset&lt;/code&gt; keyword to easily define subsets of other types. In this case, the element has to be an integer and must be greater than 0. We then use this subset in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; subroutine’s signature.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As we can see from the modifications to example 1 above, we will always have the product of all items in the numerator and current item in the denominator. We just want to calculate that once, and Raku gives us a simple way of doing that through it’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[*]&lt;/code&gt; operator.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This line shows my functional programming background bubbling up. Basically, for each item in the list, we want &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$product / $item&lt;/code&gt;, and we want the output collected into a list. This is a &lt;em&gt;textbook&lt;/em&gt; case for a map function, so you can see that is what I went with.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;To a non-Raku user, this may be a little confusing because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; in a map &lt;em&gt;literally&lt;/em&gt; means &lt;a href=&quot;https://docs.raku.org/type/Whatever&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;whatever&lt;/code&gt;&lt;/a&gt; (more specifically, “whatever input I received”) and &lt;em&gt;not&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multiply&lt;/code&gt;. The Scala equivalent would be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N.map(item =&amp;gt; product / item)&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-spiral-matrix&quot;&gt;Task 2: Spiral Matrix&lt;/h2&gt;

&lt;p&gt;You are given &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m x n&lt;/code&gt; matrix of positive integers.&lt;/p&gt;

&lt;p&gt;Write a script to print spiral matrix as list.&lt;/p&gt;

&lt;h3 id=&quot;example-1-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    [ 1, 2, 3 ]
    [ 4, 5, 6 ]
    [ 7, 8, 9 ]
Ouput:
    [ 1, 2, 3, 6, 9, 8, 7, 4, 5 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2-1&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    [  1,  2,  3,  4 ]
    [  5,  6,  7,  8 ]
    [  9, 10, 11, 12 ]
    [ 13, 14, 15, 16 ]
Output:
    [ 1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any specific implementation comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset PositiveInt of Int where { $_ ~~ Int &amp;amp;&amp;amp; $_ &amp;gt; 0 }

enum Direction &amp;lt;NORTH EAST SOUTH WEST&amp;gt;;

sub MAIN(*@input where all(@input) ~~ PositiveInt &amp;amp;&amp;amp; @input.elems &amp;gt; 0) {
    # Ensure our input is exactly square
    my $side-length = @input.elems.sqrt;
    $side-length.Int == $side-length or die &quot;Must be a square matrix&quot;;

    # Turn our CLI input into a list of lists (containing both the value and a flag for if we have visted it)
    my @matrix = gather {
        loop (my $i = 0; $i &amp;lt; @input.elems; $i += $side-length) {
            my @row = @input[$i..^$i + $side-length].map({ Hash.new('value', $_, 'visited', False) });
            take @row;
        }
    }

    # Output list and helper function for adding to it
    my @output;
    sub visit-cell($i, $j) {
        my %cell = @matrix[$i][$j];
        if !%cell{'visited'} {
            @output.push(%cell{'value'});
        }
        @matrix[$i][$j]{'visited'} = True;
    }

    # Control vars used below
    my ($min-row, $min-col) = 0, 0;
    my ($max-row, $max-col) = @matrix.elems - 1, @matrix.tail.elems - 1;
    my ($current-row, $current-col, $current-direction) = $min-row, $min-col, EAST;

    # Iterate through matrix in the given directions. Check if we are in a corner or if we have already
    # visited the next cell to determine if we should turn
    while @output.elems != @input.elems {
        visit-cell($current-row, $current-col);
        given $current-direction {
            when EAST {
                if $current-col == $max-col || @matrix[$current-row][$current-col+1]{'visited'} {
                    $current-direction = SOUTH;
                    $current-row += 1;
                } else {
                    $current-col += 1;
                }
            }
            when SOUTH {
                if ($current-row == $max-row &amp;amp;&amp;amp; $current-col == $max-col) || @matrix[$current-row+1][$current-col]{'visited'} {
                    $current-direction = WEST;
                    $current-col -= 1;
                } else {
                    $current-row += 1;
                }
            }
            when WEST {
                if $current-col == $min-col || @matrix[$current-row][$current-col-1]{'visited'} {
                    $current-direction = NORTH;
                    $current-row -= 1;
                } else {
                    $current-col -= 1;
                }
            }
            when NORTH {
                # No need to check for special case here, because we always start in the top left
                if @matrix[$current-row-1][$current-col]{'visited'} {
                    $current-direction = EAST;
                    $current-col += 1;
                } else {
                    $current-row -= 1;
                }
            }
        }
    }
    say @output;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 1 2 3 4 5 6 7 8 9
[1 2 3 6 9 8 7 4 5]

$ raku ch-2.raku 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
[1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I &lt;em&gt;tried&lt;/em&gt; to do this one functionally, but I just couldn’t find a way to do it.&lt;/p&gt;

&lt;p&gt;The basics of the above program are as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We take some input and make sure it is square
    &lt;ul&gt;
      &lt;li&gt;Couldn’t find a better way to do this, but I am all ears if anyone knows. Scala has an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isWhole&lt;/code&gt; function on its number classes, so I basically did that check myself:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; my $side-length = @input.elems.sqrt;
 $side-length.Int == $side-length or die &quot;Must be a square matrix&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Convert that into an actual matrix that looks like this (using example 1):&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [
     [{value: 1, visited: False}, {value: 2, visited: False}, {value: 3, visited: False}],
     [{value: 4, visited: False}, {value: 5, visited: False}, {value: 6, visited: False}],
     [{value: 7, visited: False}, {value: 8, visited: False}, {value: 9, visited: False}],
 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Starting in the top left corner, walk to the right (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EAST&lt;/code&gt;) with the following logic: if we hit the edge or a visited cell, turn right, else keep going.
    &lt;ul&gt;
      &lt;li&gt;We always “visit” the current cell by marking it visted and adding it to the output&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;That’s it!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;What I like about this solution is that it is pretty simple. In fact, steps one and two could be drastically simplified if this program trusted that it would always get a square matrix rather than a 1D matrix from the command line. Additionally, as a fan of pattern matching, I am glad I got to use a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given/when&lt;/code&gt; clause here.&lt;/p&gt;

&lt;p&gt;What I dislike about this solution is the mutability (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output.push()&lt;/code&gt;) and the fragility of it. For example, if the problem were tweaked to walk counter clockwise, I would basically have to re-write the actual “business logic” of this solution.&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;This was a fun dive back into the world of Perl, and I am looking forward to more of these challenges and blogs going forward.&lt;/p&gt;

&lt;p&gt;I am hoping someone can prove me wrong and solve the second problem functionally. Looking forward to seeing everyone’s solutions and interacting more with the community!&lt;/p&gt;

&lt;h4 id=&quot;ps&quot;&gt;PS&lt;/h4&gt;

&lt;p&gt;It seems the theme I am using for my blog does not support &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;raku&lt;/code&gt; code highlighting yet. I am using Jekyll; any plugin I can use to circumvent this?&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">I have always been a fan of Perl (and its younger brother Raku), but, since leaving the Bioinformatics world, have not found any real-world scenarios to flex those muscles.</summary></entry></feed>