<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-05-08T15:04:21-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Aaron Smith</title><subtitle>Personal website and blog of Aaron Smith</subtitle><author><name>Aaron Smith</name></author><entry><title type="html">Perl Weekly Challenge 111</title><link href="http://localhost:4000/blog/perl-weekly-challenge-111/" rel="alternate" type="text/html" title="Perl Weekly Challenge 111" /><published>2021-05-08T00:00:00-05:00</published><updated>2021-05-08T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-111</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-111/">&lt;p&gt;I was apparently &lt;a href=&quot;https://perlweeklychallenge.org/blog/meet-the-champion-2021-04/&quot;&gt;the champion&lt;/a&gt; of the &lt;em&gt;Perl Weekly Challenge&lt;/em&gt; for last month, which is pretty cool! I encourage folks to go read my interview with Mohammad Anwar, who runs the &lt;em&gt;Perl Weekly Challenge&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;task-1-search-matrix&quot;&gt;Task 1: Search Matrix&lt;/h2&gt;

&lt;p&gt;You are given 5x5 matrix filled with integers such that each row is sorted from left to right, and the first integer of each row is greater than the last integer of the previous row.&lt;/p&gt;

&lt;p&gt;Write a script to find a given integer in the matrix using an efficient search algorithm.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Matrix: [  1,  2,  3,  5,  7 ]
        [  9, 11, 15, 19, 20 ]
        [ 23, 24, 25, 29, 31 ]
        [ 32, 33, 39, 40, 42 ]
        [ 45, 47, 48, 49, 50 ]

Input: 35
Output: 0 since it is missing in the matrix

Input: 39
Output: 1 as it exists in the matrix
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-111/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@list-of-lists, Int $N) returns Int {
  my $output = 0;
  for (0..^@list-of-lists.end) Z (0^..@list-of-lists.end) -&amp;gt; ($i, $j) { # [1]
    if @list-of-lists[$i].head == $N || @list-of-lists[$j].head == $N { # [2]
      $output = 1;
      last;
    } elsif @list-of-lists[$i].head &amp;lt; $N &amp;lt; @list-of-lists[$j].head {
      $output = (any(@list-of-lists[$i][1..*]) ~~ $N).Int;              # [3]
      last;
    } elsif $j == @list-of-lists.end &amp;amp;&amp;amp; $N &amp;gt; @list-of-lists[$j].head {  # [4]
      $output = (any(@list-of-lists[$j][1..*]) ~~ $N).Int;
      last;
    }
  }
  $output;
}

sub MAIN(Int $N) {
  my @list-of-lists = (   # [5]
    ( 1,  2,  3,  5,  7),
    ( 9, 11, 15, 19, 20),
    (23, 24, 25, 29, 31),
    (32, 33, 39, 40, 42),
    (45, 47, 48, 49, 50)
  );
  say challenge(@list-of-lists, $N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 35
0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I don‚Äôt know if this is the most efficient method, but it is &lt;em&gt;an&lt;/em&gt; efficient method, which is what the question calls for. The naive solution would be something like this, which has a complexity of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(n+k)&lt;/code&gt; where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; is the number of elements total (25) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt; is the cost of flattening the structure (likely just 4 appends).&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;any(@list-of-lists.flat) ~~ $N
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;My approach, instead, looks at the first element of each sublist to determine if it should even bother looking in that sublist. If so, it will drop down and check items 2 through 5 of the sublist (I assume this happens in order using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;any&lt;/code&gt;). if not, it will skip the list entirely and jump to the next sublist.&lt;/p&gt;

&lt;p&gt;I &lt;em&gt;think&lt;/em&gt; my approach has a complexity of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;O(n+k)&lt;/code&gt; where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; is the number of sub-lists (5) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;k&lt;/code&gt; is the number of elements in that list (minus the first one, so 4). So we will &lt;em&gt;at most&lt;/em&gt; do 9 checks and be able to determine if the item exists in a sublist. On average, we will have fewer checks than that.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;This looks complex, but this is just making a list that looks like this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((0, 1), (1, 2), (2, 3), (3, 4))&lt;/code&gt; so that we can look at two sublists at a time. The second sublist is necessary so we can check the top end of the range easily.&lt;/li&gt;
  &lt;li&gt;Check the head of the first list and head of the second sublist to see if we can skip searching a sublist.&lt;/li&gt;
  &lt;li&gt;If it is in the range of a sublist, we can drop into it and use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;any&lt;/code&gt;, which I am pretty sure just searches from left to right. At most this will search all 4 elements (we skip the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt; item), and will end early if it finds the element.&lt;/li&gt;
  &lt;li&gt;If this is the last iteration and we still haven‚Äôt found &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;, we need to drop into the last sublist, just for full coverage.&lt;/li&gt;
  &lt;li&gt;We could set this up to be dynamic and passed in at run time, but I figured it would be okay to hardcode for our purposes.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-ordered-letters&quot;&gt;Task 2: Ordered Letters&lt;/h2&gt;

&lt;p&gt;Given a word, you can sort its letters alphabetically (case-insensitive). For example, ‚Äúbeekeeper‚Äù becomes ‚Äúbeeeeekpr‚Äù and ‚Äúdictionary‚Äù becomes ‚Äúacdiinorty‚Äù.&lt;/p&gt;

&lt;p&gt;Write a script to find the longest English words that don‚Äôt change when their letters are sorted.&lt;/p&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-111/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use LibCurl::HTTP :subs; # Imports jget

sub get-english-words {
  my %words = jget('https://raw.githubusercontent.com/dwyl/english-words/master/words_dictionary.json'); # [1]
  %words.keys;                                                                                           # [2]
}

sub challenge(Int $threshold) {
  my @words = get-english-words;
  my @matching-words = gather for @words.race -&amp;gt; $word {         # [3]
    my @chars = $word.comb;
    if @chars.elems &amp;gt;= $threshold &amp;amp;&amp;amp; @chars.sort.join eq $word { # [4]
      take $word;
    }
  }
  @matching-words.sort;
}

multi sub MAIN(Int $threshold = 7) { # [5]
  for challenge($threshold) -&amp;gt; $word {
    say $word;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku
adelops
aegilops
alloquy
beefily
begorry
belloot
billowy
deglory
egilops
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;So this question is pretty vague. The first problem we have is, how do we get a list of all English words? Rather than ship a text file around with my code, we can pull some at run time from an API. I couldn‚Äôt find a decent free API, so I just found &lt;a href=&quot;https://github.com/dwyl/english-words&quot;&gt;this GitHub repo&lt;/a&gt; that has a JSON file full of words. Does it have all the words? I have no idea, but it will certainly work for our purposes.&lt;/p&gt;

&lt;p&gt;Basically, once that is pulled down, we just split each word into characters, sort them, and compare them to the original word. However, we check against &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$threshold&lt;/code&gt; first, so we don‚Äôt do the expensive computation on every word.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Passing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:sub&lt;/code&gt; flag to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;use LibCurl:HTTP&lt;/code&gt; imports its individual subroutines, including &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jget&lt;/code&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;jget&lt;/code&gt; calls the URL and unpacks the returns JSON into a hash.&lt;/li&gt;
  &lt;li&gt;I don‚Äôt know why the author of the above GitHub repo chose this format, but instead of using a JSON array, they used a format like this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{&quot;word&quot;: 1}&lt;/code&gt;, so we only need the keys.&lt;/li&gt;
  &lt;li&gt;Since we need to process all of these words, and the order doesn‚Äôt matter (since we will sort later), we can cast this list to a &lt;a href=&quot;https://docs.raku.org/type/RaceSeq&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RaceSeq&lt;/code&gt;&lt;/a&gt; that will process in parallel without definite order.&lt;/li&gt;
  &lt;li&gt;Check the threshold first, so we don‚Äôt do the expensive computation if it is short. If it passes that check, sort the characters and compare to the original word. If it also passes that check, we can take this work and add it to our output.&lt;/li&gt;
  &lt;li&gt;The question asks us to find the longest English &lt;strong&gt;words&lt;/strong&gt; (plural). The single longest word is 8 characters (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;aegilops&lt;/code&gt;, which is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Aegilops&quot;&gt;genus of plant&lt;/a&gt;), so I bumped the threshold down to 7 to give the longest English &lt;strong&gt;words&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I have never gotten to do web requests in Raku, so it was fun learning about different packages for that. There is even the &lt;a href=&quot;https://cro.services/&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cro&lt;/code&gt;&lt;/a&gt; project for setting up APIs; maybe I will get a chance to use that in the future. See y‚Äôall next week!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">I was apparently the champion of the Perl Weekly Challenge for last month, which is pretty cool! I encourage folks to go read my interview with Mohammad Anwar, who runs the Perl Weekly Challenge.</summary></entry><entry><title type="html">Perl Weekly Challenge 110</title><link href="http://localhost:4000/blog/perl-weekly-challenge-110/" rel="alternate" type="text/html" title="Perl Weekly Challenge 110" /><published>2021-05-01T00:00:00-05:00</published><updated>2021-05-01T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-110</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-110/">&lt;p&gt;A couple IO-related challenges this week with nice functional solutions. üôÇ&lt;/p&gt;

&lt;h2 id=&quot;task-1-valid-phone-numbers&quot;&gt;Task 1: Valid Phone Numbers&lt;/h2&gt;

&lt;p&gt;You are given a text file.&lt;/p&gt;

&lt;p&gt;Write a script to display all valid phone numbers in the given text file.&lt;/p&gt;

&lt;h3 id=&quot;acceptable-phone-number-formats&quot;&gt;Acceptable Phone Number Formats&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+nn  nnnnnnnnnn
(nn) nnnnnnnnnn
nnnn nnnnnnnnnn
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;input-file&quot;&gt;Input File&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0044 1148820341
 +44 1148820341
  44-11-4882-0341
(44) 1148820341
  00 1148820341
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0044 1148820341
 +44 1148820341
(44) 1148820341
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-110/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Str $file-path) returns Str {
  $file-path
    .IO
    .lines
    .grep(* ~~ /                                         # [1]
      ^                                                  # [2]
      &amp;lt;space&amp;gt;*                                           # [3]
      [\+&amp;lt;digit&amp;gt; ** 2 | \(&amp;lt;digit&amp;gt; ** 2\) | &amp;lt;digit&amp;gt; ** 4] # [4]
      &amp;lt;space&amp;gt;                                            # [5]
      &amp;lt;digit&amp;gt; ** 10                                      # [6]
      $                                                  # [7]
    /)
    .join(&quot;\n&quot;);
}

sub MAIN(Str $file-path) {
  say challenge($file-path);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku test.txt
0044 1148820341
 +44 1148820341
(44) 1148820341
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The basics here are pretty simple ‚Äì for each line in the file, check if it matches our regex. If so, keep it, otherwise, drop it. Finally, join all matching lines together using the newline character. See below for comments on the regex itself.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Spaces in regexes in Raku are insignificant unless we put the &lt;a href=&quot;https://docs.raku.org/language/regexes#Sigspace&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:s&lt;/code&gt; modifier&lt;/a&gt; (or ‚Äúratchet‚Äù) in front of the opening forward slash. This allows us to break the logic up over multiple lines and even add comments.&lt;/li&gt;
  &lt;li&gt;Match the beginning of the line; this is a universal regex metacharacter.&lt;/li&gt;
  &lt;li&gt;Match zero or more spaces. The example file had different levels of space at the beginning of each line, but all of it was insignificant.&lt;/li&gt;
  &lt;li&gt;This line matches what I will call our ‚Äúprefix.‚Äù It will match exactly one of the following:
    &lt;ul&gt;
      &lt;li&gt;A literal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+&lt;/code&gt; character follow by two digits.&lt;/li&gt;
      &lt;li&gt;A literal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&lt;/code&gt; character followed by two digits followed by a literal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;)&lt;/code&gt; character.&lt;/li&gt;
      &lt;li&gt;Four digits in a row.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Each valid phone number had a space between the prefix and the last 10 digits, so this matches a literal space.&lt;/li&gt;
  &lt;li&gt;All valid phone numbers end in exactly 10 numbers&lt;/li&gt;
  &lt;li&gt;Match the end of the line to verify there is nothing else in the matching line.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-transpose-file&quot;&gt;Task 2: Transpose File&lt;/h2&gt;

&lt;p&gt;You are given a text file.&lt;/p&gt;

&lt;p&gt;Write a script to transpose the contents of the given file.&lt;/p&gt;

&lt;h3 id=&quot;input-file-1&quot;&gt;Input File&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name,age,sex
Mohammad,45,m
Joe,20,m
Julie,35,f
Cristina,10,f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;output-1&quot;&gt;Output&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name,Mohammad,Joe,Julie,Cristina
age,45,20,35,10
sex,m,m,f,f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-110/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use Text::CSV; # Imports `csv` function

sub challenge(Str $file-path) returns Str {
  my @lines = csv(in =&amp;gt; $file-path, headers =&amp;gt; &quot;auto&quot;); # [1] 
  my $names = ('name', |@lines.map(*&amp;lt;name&amp;gt;)).join(','); # [2]
  my $ages  = ('age', |@lines.map(*&amp;lt;age&amp;gt;)).join(',');
  my $sexes = ('sex', |@lines.map(*&amp;lt;sex&amp;gt;)).join(',');
  ($names, $ages, $sexes).join(&quot;\n&quot;);                   # [3]
}

sub MAIN(Str $file-path) {
  say challenge($file-path);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku test.csv
name,Mohammad,Joe,Julie,Cristina
age,45,20,35,10
sex,m,m,f,f
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The bulk of the hard work is done for us by using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text::CSV&lt;/code&gt; module. It allows us to pull the file into a list of hashes, and then do the logical work on that list. See below for how we apply the logic.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;csv&lt;/code&gt; with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;headers&lt;/code&gt; option allows us to pull the CSV file into a list of hashes that looks like this:&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [
   {age =&amp;gt; 45, name =&amp;gt; Mohammad, sex =&amp;gt; m}
   {age =&amp;gt; 20, name =&amp;gt; Joe, sex =&amp;gt; m}
   {age =&amp;gt; 35, name =&amp;gt; Julie, sex =&amp;gt; f}
   {age =&amp;gt; 10, name =&amp;gt; Cristina, sex =&amp;gt; f}
 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Once we have the list of hashes above, we need three individual strings (one for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;age&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sex&lt;/code&gt; respectively). To do this, we just need to extract the respective key for each item in the list; we can do this via a &lt;a href=&quot;https://docs.raku.org/routine/map&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;&lt;/a&gt; function. Additionally, we prepend the respective key using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&quot;key&quot;, |@list)&lt;/code&gt; syntax. For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;, this is what the output list looks like: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(name Mohammad Joe Julie Cristina)&lt;/code&gt;. Finally, we join the output list using commas.&lt;/li&gt;
  &lt;li&gt;Once we have the 3 key lists, we simply have to join them using the newline character as shown in the example output.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I am going through an exercise at my day job where I refactor code from a more imperative approach to a more functional approach. Functional programming should not be used for everything, but when we can use it, it often allows for much more readable and predictable code.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">A couple IO-related challenges this week with nice functional solutions. üôÇ</summary></entry><entry><title type="html">Perl Weekly Challenge 109</title><link href="http://localhost:4000/blog/perl-weekly-challenge-109/" rel="alternate" type="text/html" title="Perl Weekly Challenge 109" /><published>2021-04-24T00:00:00-05:00</published><updated>2021-04-24T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-109</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-109/">&lt;p&gt;Two fun tasks this week that were both able to be solved in a functional manner üéâ&lt;/p&gt;

&lt;h2 id=&quot;task-1-chowla-numbers&quot;&gt;Task 1: Chowla Numbers&lt;/h2&gt;

&lt;p&gt;Write a script to generate first 20 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Chowla Numbers&lt;/code&gt;, named after, &lt;strong&gt;Sarvadaman D. S. Chowla&lt;/strong&gt;, a London born Indian American mathematician. It is defined as:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C(n) = sum of divisors of n except 1 and n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;output&quot;&gt;Output&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0, 0, 0, 2, 0, 5, 0, 6, 3, 7, 0, 15, 0, 9, 8, 14, 0, 20, 0, 21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-109/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Int $n) returns Int {
    (2..$n / 2).grep($n %% *).sum; # [1][2]
}

sub MAIN(Int $terms = 20) {
    say (1..$terms).map(&amp;amp;challenge).join(', '); # [3]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku
0, 0, 0, 2, 0, 5, 0, 6, 3, 7, 0, 15, 0, 9, 8, 14, 0, 20, 0, 21
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Basically we find all the factors of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; excluding (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt;), then just sum them. We do this for the range &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1..$terms&lt;/code&gt; (in this case 20) and join them all with a comma to match the provided output.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;To find the factors of a given number, we only have to look at numbers from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n / 2&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; itself. Since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; are excluded from Chowla numbers by definition, we just go from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n / 2&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt; is Raku‚Äôs version of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter&lt;/code&gt;. Additionally, Raku has a built-in operator for ‚Äúis divisible by‚Äù (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%%&lt;/code&gt;). Finally, we are able to use the ‚Äúwhatever star‚Äù since this is such a simple anonymous function. So basically, for each potential factor, we check if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; is divisible by that number.&lt;/li&gt;
  &lt;li&gt;Since the challenge operates on each number individually (rather than all 20 at once), we map the function over each number and join the output with a comma.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-four-squares-puzzle&quot;&gt;Task 2: Four Squares Puzzle&lt;/h2&gt;

&lt;p&gt;You are given four squares as below with numbers named a, b, c, d, e, f, g.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;              (1)                    (3)
        ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó      ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
        ‚ïë              ‚ïë      ‚ïë              ‚ïë
        ‚ïë      a       ‚ïë      ‚ïë      e       ‚ïë
        ‚ïë              ‚ïë (2)  ‚ïë              ‚ïë  (4)
        ‚ïë          ‚îå‚îÄ‚îÄ‚îÄ‚ï´‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ï´‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚ï´‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚ïë          ‚îÇ   ‚ïë      ‚ïë   ‚îÇ      ‚îÇ   ‚ïë         ‚îÇ
        ‚ïë          ‚îÇ b ‚ïë      ‚ïë d ‚îÇ      ‚îÇ f ‚ïë         ‚îÇ
        ‚ïë          ‚îÇ   ‚ïë      ‚ïë   ‚îÇ      ‚îÇ   ‚ïë         ‚îÇ
        ‚ïë          ‚îÇ   ‚ïë      ‚ïë   ‚îÇ      ‚îÇ   ‚ïë         ‚îÇ
        ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïù      ‚ïö‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï™‚ïê‚ïê‚ïê‚ïù         ‚îÇ
                   ‚îÇ       c      ‚îÇ      ‚îÇ      g      ‚îÇ
                   ‚îÇ              ‚îÇ      ‚îÇ             ‚îÇ
                   ‚îÇ              ‚îÇ      ‚îÇ             ‚îÇ
                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Write a script to place the given unique numbers in the square box so that sum of numbers in each box is the same.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 1,2,3,4,5,6,7

Output:

    a = 6
    b = 4
    c = 1
    d = 5
    e = 2
    f = 3
    g = 7

    Box 1: a + b = 6 + 4 = 10
    Box 2: b + c + d = 4 + 1 + 5 = 10
    Box 3: d + e + f = 5 + 2 + 3 = 10
    Box 4: f + g = 3 + 7 = 10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-109/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@nums where @nums.elems == 7) returns Str {
  my @solution = @nums
    .sort                                     # [1]
    .permutations                             # [2]
    .reverse                                  # [3]
    .first: -&amp;gt; ($a, $b, $c, $d, $e, $f, $g) { # [4][5]
      $a + $b == $b + $c + $d &amp;amp;&amp;amp;
      $b + $c + $d == $d + $e + $f &amp;amp;&amp;amp;
      $d + $e + $f == $f + $g
    };

  if @solution.elems == 1 {                       # [6]
    &quot;Unable to find a solution for given input.&quot;;
  } else {
    (&amp;lt;a b c d e f g&amp;gt; Z @solution)                 # [7][8]
      .map(-&amp;gt; ($key, $value) { &quot;$key = $value&quot; }) # [9]
      .join(&quot;\n&quot;);
  }
}

sub MAIN(*@nums where all(@nums) ~~ Int) {
  say challenge(@nums);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 1 2 3 4 5 6 7
a = 7
b = 3
c = 2
d = 5
e = 1
f = 4
g = 6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Raku helps us out quite a bit here with its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;permutations&lt;/code&gt; function. Basically, the actual squares are irrelevant and all we need to check is:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$a + $b == $b + $c + $d &amp;amp;&amp;amp;
$b + $c + $d == $d + $e + $f &amp;amp;&amp;amp;
$d + $e + $f == $f + $g
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So we just go through each permutation of the 7 numbers we are given (5040 permutations, so should be quick) and find the first instance where the above condition is true.&lt;/p&gt;

&lt;p&gt;You‚Äôll also notice our output is different from the example output. That is because the following pairs are interchangeable:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$g&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$b&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$f&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$c&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$e&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since we maximize &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt;, our output is different, but still correct.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$g&lt;/code&gt; have to be comparatively big numbers compared to the rest, so we sort our input (and later reverse it) and start checking those permutations first.&lt;/li&gt;
  &lt;li&gt;Raku will automatically generate all permutations of a list with this function. It only works with &amp;lt;20 terms, which is perfect for this use case.&lt;/li&gt;
  &lt;li&gt;As I said in (1), we are reversing our list of permutations to start with the ones where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt; is greatest.&lt;/li&gt;
  &lt;li&gt;I have decided to start using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first: -&amp;gt; {}&lt;/code&gt; syntax for multi-line anonymous functions rather than the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first(-&amp;gt;  {})&lt;/code&gt; syntax, as I feel the trailing parenthesis looks out of place.&lt;/li&gt;
  &lt;li&gt;Raku allows us to unpack our individual permutation into variables, so &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$a&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$g&lt;/code&gt; are all assigned in this one line.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first&lt;/code&gt; returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; if it can‚Äôt find a match. &lt;em&gt;However&lt;/em&gt;, assigning &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt; to a positional variable (denoted by the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@&lt;/code&gt; sigil) will generate a list that looks like this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(Any)]&lt;/code&gt;, so we check for size equal to 1 rather than checking if it is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Nil&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;To get our numbers assigned to their letters, we need to zip them with the sequence &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt; through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt;. The output of this is a list that looks like this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((a 7) (b 3) (c 2) (d 5) (e 1) (f 4) (g 6))&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;&amp;gt;&lt;/code&gt; syntax allows us to make a list of space-separated terms. It also makes each term a string automagically; it is basically shorthand for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;('a', 'b', 'c', 'd', 'e', 'f', 'g')&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;When we map over this list of pairs, we unpack each pair into its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$key&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$value&lt;/code&gt; and turn that into a string of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$key = $value&lt;/code&gt;. We then join this list of strings using newlines to match the provided output.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I‚Äôm always happy when I can find a functional solution to these problems, so I had fun this week. üôÇ See y‚Äôall next week!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Two fun tasks this week that were both able to be solved in a functional manner üéâ</summary></entry><entry><title type="html">Perl Weekly Challenge 108</title><link href="http://localhost:4000/blog/perl-weekly-challenge-108/" rel="alternate" type="text/html" title="Perl Weekly Challenge 108" /><published>2021-04-12T00:00:00-05:00</published><updated>2021-04-12T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-108</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-108/">&lt;p&gt;Task 1 this week is kind of a joke, but task 2 was interesting!&lt;/p&gt;

&lt;h2 id=&quot;task-1-locate-memory&quot;&gt;Task 1: Locate Memory&lt;/h2&gt;

&lt;p&gt;Write a script to declare a variable or constant and print its location in the memory.&lt;/p&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-108/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Any $variable) returns Int {
    $variable.WHERE;
}

sub MAIN {
    my $variable = rand;      # [1][2]
    say challenge($variable);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku
140444494947864
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Raku has the &lt;a href=&quot;https://docs.raku.org/routine/WHERE&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;WHERE&lt;/code&gt;&lt;/a&gt; method built into it that ‚ÄúReturns an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; representing the memory address of the object,‚Äù we simply need to utilize that.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rand&lt;/code&gt; is a built-in subroutine that returns a random integer.&lt;/li&gt;
  &lt;li&gt;Following the Scala style, I would normally use parentheses for subroutines that are not ‚Äúpure‚Äù and write this as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rand()&lt;/code&gt;, but Raku complains with the following error: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unsupported use of rand().  In Raku please use: rand.&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-bell-numbers&quot;&gt;Task 2: Bell Numbers&lt;/h2&gt;

&lt;p&gt;Write a script to display top 10 Bell Numbers. Please refer to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bell_number&quot;&gt;Wikipedia page&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;B&lt;sub&gt;0&lt;/sub&gt;: 1, as you can only have one partition of zero element set.&lt;/li&gt;
  &lt;li&gt;B&lt;sub&gt;1&lt;/sub&gt;: 1, as you can only have one partition of one element set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{a}&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B&lt;sub&gt;2&lt;/sub&gt;: 2&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{a}{b}
{a,b}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B&lt;sub&gt;3&lt;/sub&gt;: 5&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{a}{b}{c}
{a,b}{c}
{a}{b,c}
{a,c}{b}
{a,b,c}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B&lt;sub&gt;4&lt;/sub&gt;: 15&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{a}{b}{c}{d}
{a,b,c,d}
{a,b}{c,d}
{a,c}{b,d}
{a,d}{b,c}
{a,b}{c}{d}
{a,c}{b}{d}
{a,d}{b}{c}
{b,c}{a}{d}
{b,d}{a}{c}
{c,d}{a}{b}
{a}{b,c,d}
{b}{a,c,d}
{c}{a,b,d}
{d}{a,b,c}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-108/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use experimental :cached;

sub challenge(Int $n where $n &amp;gt;= 0) is cached returns Int {            # [1]
    given $n {
        when 0|1 { 1 }
        default {
            my $n-minus-one = $n - 1;
            gather for (0..$n-minus-one) -&amp;gt; $k {                       # [2]
                take (^$n-minus-one).combinations($k) * challenge($k); # [2]
            }.sum
        }
    }
}

sub MAIN(Int $n = 10) {
    say (^$n).map(&amp;amp;challenge);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku
(1 1 2 5 15 52 203 877 4140 21147)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;!-- Allow inlining of math functionality --&gt;
&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], [&quot;\\(&quot;,&quot;\\)&quot;] ],
      processEscapes: true
    }
  });
&lt;/script&gt;

&lt;!-- Import math functionality --&gt;
&lt;script type=&quot;text/javascript&quot; async=&quot;&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The question asks for the ‚Äútop 10 Bell Numbers.‚Äù Since this is an ever-increasing sequence, there is no ‚Äútop,‚Äù so I interpreted that to mean &lt;em&gt;first&lt;/em&gt; 10 Bell numbers.&lt;/p&gt;

&lt;p&gt;At first glance, this code has nothing to do with the input sequences, but digging into the above-linked Wikipedia entry, we find this equation:&lt;/p&gt;

&lt;p&gt;$ B_{n+1} = \sum_{k=0}^{n}{n \choose k}B_{k} $&lt;/p&gt;

&lt;p&gt;This tells us that each Bell number is built upon by the previous Bell numbers. And we know the first two Bell numbers, so we can follow this.&lt;/p&gt;

&lt;p&gt;Let‚Äôs re-write this to calculate $ B_{2} $ and see how it works; remember, since we are calculating for $ B_{n+1} $, we use $ n = 1 $.&lt;/p&gt;

&lt;p&gt;$ B_{2} = \sum_{k=0}^{1}{1 \choose k}B_{k} $&lt;/p&gt;

&lt;p&gt;Which can be expanded as:&lt;/p&gt;

&lt;p&gt;$ B_{2} = {1 \choose 0}B_{0} + {1 \choose 1}B_{1} $&lt;/p&gt;

&lt;p&gt;Which can be reduced to:&lt;/p&gt;

&lt;p&gt;$ B_{2} = (1)(1) + (1)(1) = 2 $&lt;/p&gt;

&lt;p&gt;So $ B_{2} = 2 $ and we can use that to calculate $ B_{3} $ and so on.&lt;/p&gt;

&lt;p&gt;Now that we have the algorithm figured out, and decided we are going to apply it to the &lt;em&gt;first&lt;/em&gt; 10 terms, it‚Äôs a simple matter to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; the function over the sequence from 0 (inclusive) to 10 (exclusive).&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Since this is a recursive function, once we calculate $ B_{2} $ we will use it in $ B_{3} $, $ B_{4} $ and so on. No use re-calculating it every time, so we memoize this function using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is cached&lt;/code&gt; trait.&lt;/li&gt;
  &lt;li&gt;gather/take is a construct to build up a sequence using a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Supply&lt;/code&gt; (in this case, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;for&lt;/code&gt; loop).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I love me some pattern matching and recursion, coming from a Scala day job, so it is fun to use those constructs in other languages, especially Raku. üôÇ&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Task 1 this week is kind of a joke, but task 2 was interesting!</summary></entry><entry><title type="html">Perl Weekly Challenge 107</title><link href="http://localhost:4000/blog/perl-weekly-challenge-107/" rel="alternate" type="text/html" title="Perl Weekly Challenge 107" /><published>2021-04-10T00:00:00-05:00</published><updated>2021-04-10T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-107</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-107/">&lt;p&gt;I wrote this week‚Äôs answers several days ago, but forgot to commit them. I ended up getting a new laptop and had to rewrite them. I think they ended up the same, but I guess no one knows for sure!&lt;/p&gt;

&lt;h2 id=&quot;task-1-self-descriptive-numbers&quot;&gt;Task 1: Self-descriptive Numbers&lt;/h2&gt;

&lt;p&gt;Write a script to display the first three self-descriptive numbers. As per &lt;a href=&quot;https://en.wikipedia.org/wiki/Self-descriptive_number&quot;&gt;wikipedia&lt;/a&gt;, the definition of ‚Äúself-descriptive number‚Äù is:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In mathematics, a self-descriptive number is an integer m that in a given base b is b digits long in which each digit d at position n (the most significant digit being at position 0, and the least significant at position b‚àí1) counts how many instances of digit n are in m.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 1210 is a four-digit self-descriptive number:

    Position 0 has value 1 i.e. there is only one 0 in the number
    Position 1 has value 2 i.e. there are two 1 in the number
    Position 2 has value 1 i.e. there is only one 2 in the number
    Position 3 has value 0 i.e. there is no 3 in the number
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Expected output:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1210, 2020, 21200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-107/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Int $n) returns Str { # [1]
    my @output;
    for (^‚àû) -&amp;gt; $i {                # [2][3]
        my @digits = $i.comb;
        my $valid = True;
        for @digits.kv -&amp;gt; $index, $value {
            $valid = @digits.grep($index).elems == $value;
            last unless $valid;     # [4]
        }
        @output.push($i) if $valid; # [5]
        last if @output.elems == $n;
    }
    @output.join(', ');
}

sub MAIN(Int $n = 3) {
    say challenge($n);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku
1210, 2020, 21200
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;We begin by defining a list to hold our output, then kick of an infinite loop starting at 0. For each number, we convert it to a list of digits (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.comb&lt;/code&gt;). For each index, value pair, we check if the input number has &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$value&lt;/code&gt; number of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$index&lt;/code&gt; digits. So for 1210 we would check if it had 1 zero, 2 ones, 1 two, and 0 threes. If it meets the conditions, we add it to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt;. Finally, if we have found all 3 that we are looking for, we break out of the infinite loop and return.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;We make this generic by accepting the argument &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt;, but the fourth self-describing number is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3,211,000&lt;/code&gt;, and the fifth is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;42,101,000&lt;/code&gt;, so this method would get slow very quickly.&lt;/li&gt;
  &lt;li&gt;We &lt;em&gt;could&lt;/em&gt; have said &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;loop&lt;/code&gt; to start an infinite loop, but then we wouldn‚Äôt have access to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$i&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;When using this method, we always have to use the carrot (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^&lt;/code&gt;) to say we are not including infinity. This is because it is impossible to be inclusive of infinity.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unless&lt;/code&gt; is just the opposite of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt;. I feel this reads better than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;last if !$valid&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;I find the post-fix way of using conditionals to read better a lot of the time in Raku, as seen here.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-list-methods&quot;&gt;Task 2: List Methods&lt;/h2&gt;

&lt;p&gt;Write a script to list methods of a package/class.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;p&gt;Class definition:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package Calc;

use strict;
use warnings;

sub new { bless {}, shift; }
sub add { }
sub mul { }
sub div { }

1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Expected output:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BEGIN
mul
div
new
add
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-107/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Used for testing
class Calc {      # [1]
    method add {}
    method mul {}
    method div {}
}

sub challenge(Any $class) returns Str {     # [2]
    $class.^methods.map(*.gist).join(&quot;\n&quot;); # [3][4]
}

sub MAIN {
    say challenge(Calc.new);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku
add
mul
div
BUILDALL
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The example shows a class definition in Perl, but we are using Raku, so we can just define our class using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt; keyword as shown. Additionally, we have a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BUILDALL&lt;/code&gt; method instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BEGIN&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Raku gives us the &lt;a href=&quot;https://docs.raku.org/language/classtut#Introspection&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^methods&lt;/code&gt;&lt;/a&gt; meta method to introspect an object‚Äôs methods, so we just have to utilize that on the input object!&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;In Perl, we have to define classes in their own file, but in Raku we can just use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt; keyword.&lt;/li&gt;
  &lt;li&gt;All objects inherit from &lt;a href=&quot;https://docs.raku.org/type/Any&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt;&lt;/a&gt;, so we are just saying we accept any class here.&lt;/li&gt;
  &lt;li&gt;Raku provides us a nice introspection method, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^methods&lt;/code&gt;, which returns a list of defined methods and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BUILDALL&lt;/code&gt;. We can also pass in the flag &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:local&lt;/code&gt; meaning ‚Äúonly show us methods defined in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Calc&lt;/code&gt; and not super classes,‚Äù or we could pass in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:all&lt;/code&gt; meaning ‚Äúshow us all methods that can act on this class.‚Äù&lt;/li&gt;
  &lt;li&gt;The returned type is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List[Method]&lt;/code&gt;, so to cast everything to a string, we need to call each method‚Äôs &lt;a href=&quot;https://docs.raku.org/routine/gist&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gist&lt;/code&gt;&lt;/a&gt; method.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Once again, Raku makes these challenges super easy. Looking forward to something tougher in the future!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">I wrote this week‚Äôs answers several days ago, but forgot to commit them. I ended up getting a new laptop and had to rewrite them. I think they ended up the same, but I guess no one knows for sure!</summary></entry><entry><title type="html">Perl Weekly Challenge 106</title><link href="http://localhost:4000/blog/perl-weekly-challenge-106/" rel="alternate" type="text/html" title="Perl Weekly Challenge 106" /><published>2021-03-29T00:00:00-05:00</published><updated>2021-03-29T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-106</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-106/">&lt;p&gt;Task 2 &lt;em&gt;seems&lt;/em&gt; like it would be difficult, but once again, Raku has built-in mechanisms to help us out!&lt;/p&gt;

&lt;h2 id=&quot;task-1-maximum-gap&quot;&gt;Task 1: Maximum Gap&lt;/h2&gt;

&lt;p&gt;You are given an array of integers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to display the maximum difference between two successive elements once the array is sorted.&lt;/p&gt;

&lt;p&gt;If the array contains only 1 element then display 0.&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @N = (2, 9, 3, 5)
Output: 4

Input: @N = (1, 3, 8, 2, 0)
Output: 5

Input: @N = (5)
Output: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-106/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@N where all(@N) ~~ Int) returns Int {   # [1]
    if @N.elems == 1 {
        0;
    } else {
        my @sorted = @N.sort;
        my @zipped = @sorted[0..*-1] Z @sorted[1..*];  # [2]
        @zipped.map(-&amp;gt; ($a, $b) { abs($b - $a) }).max; # [3]
    }
}

sub MAIN(*@N where all(@N) ~~ Int) {
    say challenge(@N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 2 9 3 5
4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This one is probably easier to walk through with an example. If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt; only has one element, we just return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;, so we won‚Äôt discuss that path.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We get this input: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N = (2, 9, 3, 5)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;We sort it so we have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@sorted = (2, 3, 5, 9)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;We generate two lists: One of everything but the last element (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@sorted[0..*-1] = (2, 3, 5)&lt;/code&gt;) and one of everything but the first element (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@sorted[1..*] = (3, 5, 9)&lt;/code&gt;). Then we zip them together so we have &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@zipped = ((2, 3), (3, 5), (5, 9))&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;For each pair, we find the difference between the numbers, so we end up with this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(1, 2, 4)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Finally, we call &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.max&lt;/code&gt; and return the maximum difference, which is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;4&lt;/code&gt; in this case.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Raku has so many different sequence types (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Positional&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Seq&lt;/code&gt;, etc.) that I have not figured out a good way to parameterize positional inputs. This is the best I can come up with, but for long sequences, it is incredibly slow.&lt;/li&gt;
  &lt;li&gt;The ‚Äúwhatever star‚Äù is signaling the last index of the list, in this case. So we are simply generating a list containing everything but the last item zipped with a list containing everything but the last item (see above for example).&lt;/li&gt;
  &lt;li&gt;In theory, we could have negative numbers in our input, so it is necessary to have the call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abs&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-decimal-string&quot;&gt;Task 2: Decimal String&lt;/h2&gt;

&lt;p&gt;You are given a numerator and denominator i.e. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$D&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to convert the fraction into decimal string. If the fractional part is recurring then put it in parentheses.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $N = 1, $D = 3
Output: &quot;0.(3)&quot;

Input: $N = 1, $D = 2
Output: &quot;0.5&quot;

Input: $N = 5, $D = 66
Output: &quot;0.0(75)&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-106/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Numeric $N, Numeric $D) returns Str {                  # [1]
    my ($base, $repeating) = ($N / $D).base-repeating;               # [2]
    $repeating = $repeating eq '' ?? $repeating !! &quot;\($repeating\)&quot;; # [3]
    $base ~ $repeating;                                              # [4]
}

sub MAIN(Numeric $N, Numeric $D) {
    say challenge($N, $D);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 1 7
0.(142857)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This looks suspiciously small for what seems like a complex problem. All the logic happens in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base-repeating&lt;/code&gt; (which I will detail below). All we have to do is supply the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;D&lt;/code&gt;, and the rest of the code is just for formatting!&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;In theory someone could pass in arbitrary decimal numbers, so we accept &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Numeric&lt;/code&gt; instead of just &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/base-repeating&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;base-repeating&lt;/code&gt;&lt;/a&gt; operates on a &lt;a href=&quot;https://docs.raku.org/type/Rational&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rational&lt;/code&gt;&lt;/a&gt;, which is Raku‚Äôs way of saying fraction. It splits the fraction into pieces ‚Äì the base and the repeating portion. For something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5 / 2&lt;/code&gt;, it would return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;('2.5', '')&lt;/code&gt;. For something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 / 3&lt;/code&gt;, we would get &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'0.', '3')&lt;/code&gt;. Once we have that, we just have to format like the question asks.&lt;/li&gt;
  &lt;li&gt;If the repeated section is empty, we want to just leave it alone. Otherwise, we want to wrap it in parentheses as the challenge states.&lt;/li&gt;
  &lt;li&gt;We could also have written &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;$base$repeating&quot;&lt;/code&gt; to concatenate the pieces, but that is harder to read, so I used the string concatenation operator (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I don‚Äôt know whether or not to consider it cheating when Raku has all the cool built-ins. I guess we‚Äôre just using the tools we are provided, but it feels too easy. üòÖ&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Task 2 seems like it would be difficult, but once again, Raku has built-in mechanisms to help us out!</summary></entry><entry><title type="html">Perl Weekly Challenge 105</title><link href="http://localhost:4000/blog/perl-weekly-challenge-105/" rel="alternate" type="text/html" title="Perl Weekly Challenge 105" /><published>2021-03-27T00:00:00-05:00</published><updated>2021-03-27T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-105</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-105/">&lt;p&gt;This week‚Äôs challenges are short and sweet, but still give us the opportunity to explore some interesting Raku-isms!&lt;/p&gt;

&lt;h2 id=&quot;task-1-nth-root&quot;&gt;Task 1: Nth root&lt;/h2&gt;

&lt;p&gt;You are given positive numbers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$k&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to find out the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;th root of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$k&lt;/code&gt;. For more information, please take a look at the &lt;a href=&quot;https://en.wikipedia.org/wiki/Nth_root#Computing_principal_roots&quot;&gt;wiki page&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $N = 5, $k = 248832
Output: 12

Input: $N = 5, $k = 34
Output: 2.02
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-105/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Numeric $N, Numeric $k) returns Str { # [1]
    my $root = $k ** (1 / $N);
    $root.round(.01).Str;                           # [2]
}

sub MAIN(Num $N, Num $k) {
    say challenge($N, $k);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 5 248832
12
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;!-- Allow inlining of math functionality --&gt;
&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], [&quot;\\(&quot;,&quot;\\)&quot;] ],
      processEscapes: true
    }
  });
&lt;/script&gt;

&lt;!-- Import math functionality --&gt;
&lt;script type=&quot;text/javascript&quot; async=&quot;&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;
&lt;/script&gt;

&lt;p&gt;This solution relies on the fact that $ \sqrt[N]{k} $ can be rewritten as $ k^{1/N} $ (which is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$k ** (1 / $N)&lt;/code&gt; in Raku). So we simply have to do that and round to the appropriate amount of decimal places (the example shows 2 or less, so that is what we do as well).&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;The examples just show integers, but this function should theoretically be able to take any numeric value, so we use &lt;a href=&quot;https://docs.raku.org/type/Numeric&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Numeric&lt;/code&gt;&lt;/a&gt; for both of our input types.&lt;/li&gt;
  &lt;li&gt;Raku‚Äôs &lt;a href=&quot;https://docs.raku.org/routine/round&quot;&gt;round&lt;/a&gt; function is interesting in that you don‚Äôt specify the number of decimals, you specify some arbitrary scale, and it will round to the &lt;em&gt;closest multiple of that scale&lt;/em&gt;. So &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; would round to an integer and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.01&lt;/code&gt; would round to two decimals. Additionally, it will drop trailing zeros (and even the decimal if the rounded number only has zeros as decimals).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-the-name-game&quot;&gt;Task 2: The Name Game&lt;/h2&gt;

&lt;p&gt;You are given a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$name&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to display the lyrics to the Shirley Ellis song The Name Game. Please checkout the &lt;a href=&quot;https://en.m.wikipedia.org/wiki/The_Name_Game&quot;&gt;wiki page&lt;/a&gt; for more information.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $name = &quot;Katie&quot;
Output:

    Katie, Katie, bo-batie,
    Bonana-fanna fo-fatie
    Fee fi mo-matie
    Katie!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-105/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Str $name) returns Str {
    my $X = $name.wordcase;                                             # [1]
    my $Y = $X ~~ /^[A|E|I|O|U|Y]&amp;lt;-[aeiouy]&amp;gt;/ ?? $X.lc !! $X.substr(1); # [2]

    qq:to/END/;                                                         # [3]
    $X, $X, bo-{$X.starts-with('B') ?? '' !! 'b'}$Y                     # [4]
    Bonana-fanna fo-{$X.starts-with('F') ?? '' !! 'f'}$Y
    Fee fi mo-{$X.starts-with('M') ?? '' !! 'm'}$Y
    $X!
    END
}

sub MAIN(Str $name) {
    say challenge($name);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku Aaron
Aaron, Aaron, bo-baron
Bonana-fanna fo-faron
Fee fi mo-maron
Aaron!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;According to the wikipedia page, the structure can be broken down like this:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(X), (X), bo-b(Y)
Bonana-fanna fo-f(Y)
Fee fi mo-m(Y)
(X)!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The only caveat it adds is:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;If the name starts with a b, f, or m, that sound simply is not repeated. For example: Billy becomes &quot;Billy Billy bo-illy&quot;; Fred becomes &quot;bonana fanna fo-red&quot;; Marsha becomes &quot;fee fi mo-arsha&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I actually don‚Äôt think this caveat is enough. For example, my son‚Äôs name is Everett, and if we just cut off the first letter of his name as the wiki suggests, we would get things like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bverett&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fverett&lt;/code&gt;. So, I added an additional stipulation: any name that starts with a vowel followed by a consonant should keep the &lt;em&gt;entirety&lt;/em&gt; of the name as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Y&lt;/code&gt;, otherwise it is just &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X&lt;/code&gt; minus the first letter.&lt;/p&gt;

&lt;p&gt;Once we have found &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Y&lt;/code&gt;, we just slot them into the song. Easy peasy!&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/wordcase&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;wordcase&lt;/code&gt;&lt;/a&gt; makes the first letter uppercase, and the rest lowercase.&lt;/li&gt;
  &lt;li&gt;This checks to see if the first letter is a vowel (including &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Y&lt;/code&gt;) directly followed a consonant. If that is the case, keep the entirety of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$X&lt;/code&gt; and just convert it to lowercase to make sense in the song. Otherwise, take the &lt;a href=&quot;https://docs.raku.org/routine/substr&quot;&gt;substring&lt;/a&gt; of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$X&lt;/code&gt; from index 1 to the end.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/language/quoting#Heredocs:_:to&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;qq&lt;/code&gt;&lt;/a&gt; is an easy way to make multi-line strings that include interpolation. In this case, we say ‚Äúthe rest of this up until &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;END&lt;/code&gt; is a literal string.‚Äù Additionally, since all lines are indented to the same depth, it strips of leading indentation.&lt;/li&gt;
  &lt;li&gt;Since this whole construct is interpolated, we are able to embed the special cases for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;F&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M&lt;/code&gt; directly into the output string.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Like I said, short and sweet! See y‚Äôall next week!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">This week‚Äôs challenges are short and sweet, but still give us the opportunity to explore some interesting Raku-isms!</summary></entry><entry><title type="html">Perl Weekly Challenge 104</title><link href="http://localhost:4000/blog/perl-weekly-challenge-104/" rel="alternate" type="text/html" title="Perl Weekly Challenge 104" /><published>2021-03-21T00:00:00-05:00</published><updated>2021-03-21T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-104</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-104/">&lt;p&gt;This week had some fun topics like &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_(computer_science)&quot;&gt;recursion&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoization&lt;/a&gt;, and IO/data validation!&lt;/p&gt;

&lt;h2 id=&quot;task-1-fusc-sequence&quot;&gt;Task 1: FUSC Sequence&lt;/h2&gt;

&lt;p&gt;Write a script to generate first 50 members of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FUSC&lt;/code&gt; Sequence. Please refer to &lt;a href=&quot;http://oeis.org/A002487&quot;&gt;OEIS&lt;/a&gt; for more information.&lt;/p&gt;

&lt;p&gt;The sequence defined as below:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fusc(0) = 0
fusc(1) = 1
for n &amp;gt; 1:
when n is even: fusc(n) = fusc(n / 2),
when n is odd: fusc(n) = fusc((n-1)/2) + fusc((n+1)/2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use experimental :cached; # [1]

sub fusc(Int(Rat) $n) is cached returns Int { # [2]
    given $n {
        when 0      { 0 }
        when 1      { 1 }
        when * %% 2 { fusc($n / 2) }                            # [3]
        default     { fusc(($n - 1) / 2) + fusc(($n + 1) / 2) } # [4]
    }
}

sub MAIN(Int $terms = 50) {
    say (^$terms).map(&amp;amp;fusc); # [4]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku
(0 1 1 2 1 3 2 3 1 4 3 5 2 5 3 4 1 5 4 7 3 8 5 7 2 7 5 8 3 7 4 5 1 6 5 9 4 11 7 10 3 11 8 13 5 12 7 9 2 9)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I feel like this is pretty straight forward, and aligns well to the definition of the FUSC sequence. When we look at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt;, we run through the following logic:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Is it 0? Return 0.&lt;/li&gt;
  &lt;li&gt;Is it 1? Return 1.&lt;/li&gt;
  &lt;li&gt;Is it even? Return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc($n / 2)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Otherwise, return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(($n - 1) / 2) + fusc(($n + 1) / 2)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The function recurses until it ends up in one of the two stopping conditions (0 or 1). So obviously &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(50)&lt;/code&gt; is going to go through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(49)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(48)&lt;/code&gt;, etc. See below for how we make this efficient.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Caching in Raku is an experimental feature, so we have to import it (and add the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is cached&lt;/code&gt; trait to our subroutine). The basic idea is that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc($n)&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; the same value, so once we calculate it once, we can just look it up later. Adding this trait essentially adds a hash behind the scenes that checks if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc($n)&lt;/code&gt; already exists. If it does, it just returns that value, otherwise, it will actually calculate the value and store it in the hash before returning.&lt;/li&gt;
  &lt;li&gt;Notice the function signature takes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int(Rat)&lt;/code&gt;. This means that this function will accept either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; &lt;em&gt;or&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rat&lt;/code&gt; (&lt;a href=&quot;https://docs.raku.org/type/Rat&quot;&gt;Rational number&lt;/a&gt;) types, but it will coerce the input to an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;. The reason for this is that division in Raku will generate a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rat&lt;/code&gt; type, even for something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2 / 1&lt;/code&gt;. So we need to convert it to an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; on the recursive calls. This saves use from having to write &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(($n / 2).Int)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Raku has a special ‚Äúis divisible by‚Äù operator. So instead of saying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n % 2 == 0&lt;/code&gt;, we can say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n %% 2&lt;/code&gt;. Also notice that in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; block, we have to use the ‚Äúwhatever star‚Äù (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;) to do this operation; this is because we can‚Äôt &lt;a href=&quot;https://docs.raku.org/language/operators#index-entry-smartmatch_operator&quot;&gt;smartmatch&lt;/a&gt; against &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%% 2&lt;/code&gt;, so we need to be more explicit.&lt;/li&gt;
  &lt;li&gt;Remember when passing a function as an argument (in this case to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;), it has a special &lt;a href=&quot;https://docs.raku.org/language/variables#index-entry-sigil_&amp;amp;&quot;&gt;sigil&lt;/a&gt; ‚Äì &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-nim-game&quot;&gt;Task 2: NIM Game&lt;/h2&gt;

&lt;p&gt;Write a script to simulate the NIM Game.&lt;/p&gt;

&lt;p&gt;It is played between 2 players. For the purpose of this task, let assume you play against the machine.&lt;/p&gt;

&lt;p&gt;There are 3 simple rules to follow:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) You have 12 tokens
b) Each player can pick 1, 2 or 3 tokens at a time
c) The player who picks the last token wins the game
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Formats a message defined as plural to be singular if $n == 1
sub format(Str $message, Int $n) returns Str {
    $n == 1 ?? $message.trans(['are', 'tokens'] =&amp;gt; ['is', 'token']) !! $message; # [1]
}

sub challenge(Int $n) {
    my $remaining = $n;

    # Defined within the challenge sub because it references $remaining
    sub default-prompt returns Any {
        prompt(format(&quot;There are $remaining tokens. How many would you like to pick up? (1, 2, 3) &quot;, $remaining)); # [2]
    }

    my $input = default-prompt;
    my $most-recent-move;
    while $remaining &amp;gt; 0 {
        given $input {
            when 1|2|3 {
                if $input &amp;gt; $remaining {
                    $input = prompt(&quot;There are only $remaining tokens left. Please enter a valid number &quot;)
                } else {
                    say format(&quot;You take $input tokens&quot;, $input);
                    $remaining -= $input;
                    $most-recent-move = 'You';

                    last if $remaining == 0;

                    # If there are only 3 or less tokens, take all of them. Otherwise, take a random number between 1 and 3
                    my $bot-move = $remaining ~~ 1|2|3 ?? $remaining !! (1..3).pick;
                    say format(&quot;The computer takes $bot-move tokens&quot;, $bot-move);
                    $remaining -= $bot-move;
                    $most-recent-move = 'Computer';

                    last if $remaining == 0;

                    $input = default-prompt;
                }
            }
            default { $input = prompt('Please enter 1, 2, or 3 ') }
        }
    }
    say $most-recent-move eq 'Computer' ?? 'The computer wins!' !! 'You win!'; # [3]
}

sub MAIN(Int $n where $n &amp;gt; 0 = 12) { # [4]
    challenge($n);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku
There are 12 tokens. How many would you like to pick up? (1, 2, 3) 3
You take 3 tokens
The computer takes 3 tokens
There are 6 tokens. How many would you like to pick up? (1, 2, 3) 2
You take 2 tokens
The computer takes 3 tokens
There is 1 token. How many would you like to pick up? (1, 2, 3) 1
You take 1 token
You win!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This task is basically an exercise in IO (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prompt&lt;/code&gt;) and data validation (did I get what I expect?). We follow the following steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Ask the user to give us a number (1, 2, or 3).
    &lt;ul&gt;
      &lt;li&gt;Did they give it to us? Move on to step 2.&lt;/li&gt;
      &lt;li&gt;Otherwise, keep asking for a valid input (doesn‚Äôt matter if they gave us an invalid number, a string, etc.).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Do a special check to see if their number is higher than the remaining tokens (only happens when there are 3 or fewer tokens). If so, keep prompting them for a valid input.&lt;/li&gt;
  &lt;li&gt;Now that we know we have valid input, decrement &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$remaining&lt;/code&gt; to reflect the number of token the user took.&lt;/li&gt;
  &lt;li&gt;If there are 0 tokens left, exit the loop and print that the user won.&lt;/li&gt;
  &lt;li&gt;Otherwise, there are tokens left, and it is the computer‚Äôs turn. Our bot is semi-smart, so if there are 3 or fewer tokens take all of them (and win). Otherwise, take a random valid number of tokens.&lt;/li&gt;
  &lt;li&gt;If there are 0 tokens left, exit the loop and print that th computer won.&lt;/li&gt;
  &lt;li&gt;Finally, if there are still tokens left, repeat steps 1-6 until there are 0 tokens left.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;This is simply a helper function, so we can write all of our prompts like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;There are $n tokens remaining&quot;&lt;/code&gt; and they will get properly formatted if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; is 1. This is very specific to this question, obviously, but it is useful. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trans&lt;/code&gt; basically just translates all &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;are&lt;/code&gt; instances to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is&lt;/code&gt; and all &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tokens&lt;/code&gt; instances to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;token&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;You‚Äôll notice a few things about this subroutine. First, we don‚Äôt have to define it with parentheses if it doesn‚Äôt take any arguments. Second, it returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt; because we don‚Äôt know what we are going to get from the user. Third, it is defined &lt;em&gt;inside&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; because it is acting as a &lt;a href=&quot;https://simple.wikipedia.org/wiki/Closure_(computer_science)&quot;&gt;closure&lt;/a&gt;, meaning it references variables defined outside itself (in this case, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$remaining&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Raku is kind of strange in that if you want to do string equality you have to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eq&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;This function signature specifies that it takes an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; that is greater than 0, and if it is not provided, it defaults to 12.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Raku gives us some cool tools to make these challenges easier. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; syntax was especially helpful in both of these challenges (and in others)!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">This week had some fun topics like recursion, memoization, and IO/data validation!</summary></entry><entry><title type="html">Perl Weekly Challenge 103</title><link href="http://localhost:4000/blog/perl-weekly-challenge-103/" rel="alternate" type="text/html" title="Perl Weekly Challenge 103" /><published>2021-03-13T00:00:00-06:00</published><updated>2021-03-13T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-103</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-103/">&lt;p&gt;Challenge two this week was‚Ä¶ interesting, to say the least. But, we are through it, and it‚Äôs the weekend! üçª&lt;/p&gt;

&lt;h2 id=&quot;task-1-chinese-zodiac&quot;&gt;Task 1: Chinese Zodiac&lt;/h2&gt;

&lt;p&gt;You are given a year &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$year&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to determine the Chinese Zodiac for the given year &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$year&lt;/code&gt;. Please check out &lt;a href=&quot;https://en.wikipedia.org/wiki/Chinese_zodiac&quot;&gt;wikipage&lt;/a&gt; for more information about it.&lt;/p&gt;

&lt;p&gt;The animal cycle: Rat, Ox, Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig.&lt;br /&gt;
The element cycle: Wood, Fire, Earth, Metal, Water.&lt;/p&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-103/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Int $year) returns Str {
    constant $root-year = 1924; # From Wikipedia

    my $difference         = $year - $root-year;
    my $element-difference = $difference &amp;lt; 0 ?? $difference + 10 !! $difference; # [1]
    my $animal-difference  = $difference &amp;lt; 0 ?? $difference + 12 !! $difference;

    my $element = do given $element-difference % 10 { # [2][3]
        when 0|1 { 'Wood'  }
        when 2|3 { 'Fire'  }
        when 4|5 { 'Earth' }
        when 6|7 { 'Metal' }
        when 8|9 { 'Water' }
    }
    my $animal = do given $animal-difference % 12 {
        when 0  { 'Rat'     }
        when 1  { 'Ox'      }
        when 2  { 'Tiger'   }
        when 3  { 'Rabbit'  }
        when 4  { 'Dragon'  }
        when 5  { 'Snake'   }
        when 6  { 'Horse'   }
        when 7  { 'Goat'    }
        when 8  { 'Monkey'  }
        when 9  { 'Rooster' }
        when 10 { 'Dog'     }
        when 11 { 'Pig'     }
    }

    &quot;$element $animal&quot;; # [4]
}

sub MAIN(Int $year) {
    say challenge($year);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 2017
Fire Rooster
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I‚Äôm sure there is a better root than 1924, but that is the first year in the table on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Chinese_zodiac&quot;&gt;Wikipedia page&lt;/a&gt;. Reading through the Wikipedia page, we can see two things:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The element cycle has 5 rotations (Wood, Fire, Earth, Metal, and Water), and each one lasts for 2 years (a Yin year and a Yang year [which we don‚Äôt care about]).&lt;/li&gt;
  &lt;li&gt;The animal cycle has 12 rotations (Rat, Ox,  Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig), and each one lasts for 1 year.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This makes our logic pretty simple ‚Äì we just need to find our distance from the known year of 1924 and find which cycle that year falls in. For element, we find the difference and then find the remainder after dividing by 10 (5 cycles x 2 years each). If it is 0 or 1, it is Wood, if it is 2 or 3 it is Fire, etc. Similarly, we find the difference and find the remainder after dividing by 12 for the animals. If it is 0 it is Rat, if it is 1 it is Ox, etc. That‚Äôs it!&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;We can‚Äôt just do &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abs($year - $root-year)&lt;/code&gt; because for years before &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$root-year&lt;/code&gt;, it would yield the wrong cycle (for example, 1923 would have a remainder of 1 for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$element&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;9&lt;/code&gt;). Because of this, if the difference is negative, we need to add the size of the cycle (10 and 12, respectively) to put it in its correct place.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; is a flow control keyword and doesn‚Äôt actually return anything. To make the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; block return its value, we need to add the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; keyword before it.&lt;/li&gt;
  &lt;li&gt;You‚Äôll notice there is no &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt; block for these &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt;s. That is intentional, since we know all the possible outcomes. Best practice would probably be something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default { die &quot;Unexpected input: $_&quot; }&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Double quotes tell the Raku compiler to interpolate this string, so we get &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;Fire Rooster&quot;&lt;/code&gt; instead of the literal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'$element $animal'&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-whats-playing&quot;&gt;Task 2: What‚Äôs playing?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Note: This was copied directly from &lt;a href=&quot;https://perlweeklychallenge.org/blog/perl-weekly-challenge-103/#TASK2&quot;&gt;perlweeklychallenge.org&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Working from home, you decided that on occasion you wanted some background noise while working. You threw together a network streamer to continuously loop through the files and launched it in a tmux (or screen) session, giving it a directory tree of files to play. During the day, you connected an audio player to the stream, listening through the workday, closing it when done.&lt;/p&gt;

&lt;p&gt;For weeks you connect to the stream daily, slowly noticing a gradual drift of the media. After several weeks, you take vacation. When you return, you are pleasantly surprised to find the streamer still running. Before connecting, however, if you consider the puzzle of determining which track is playing.&lt;/p&gt;

&lt;p&gt;After looking at a few modules to read info regarding the media, a quick bit of coding gave you a file list. The file list is in a simple CSV format, each line containing two fields: the first the number of milliseconds in length, the latter the media‚Äôs title (this example is of several episodes available from the MercuryTheatre.info):&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1709363,&quot;Les Miserables Episode 1: The Bishop (broadcast date: 1937-07-23)&quot;
1723781,&quot;Les Miserables Episode 2: Javert (broadcast date: 1937-07-30)&quot;
1723781,&quot;Les Miserables Episode 3: The Trial (broadcast date: 1937-08-06)&quot;
1678356,&quot;Les Miserables Episode 4: Cosette (broadcast date: 1937-08-13)&quot;
1646043,&quot;Les Miserables Episode 5: The Grave (broadcast date: 1937-08-20)&quot;
1714640,&quot;Les Miserables Episode 6: The Barricade (broadcast date: 1937-08-27)&quot;
1714640,&quot;Les Miserables Episode 7: Conclusion (broadcast date: 1937-09-03)&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For this script, you can assume to be provided the following information:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* the value of $^T ($BASETIME) of the streamer script,
* the value of time(), and
* a CSV file containing the media to play consisting of the length in milliseconds and an identifier for the media (title, filename, or other).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Write a program to output which file is currently playing. For purposes of this script, you may assume gapless playback, and format the output as you see fit.&lt;/p&gt;

&lt;p&gt;Optional: Also display the current position in the media as a time-like value.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 3 command line parameters: start time, current time, file name

    # starttime
    1606134123

    # currenttime
    1614591276

    # filelist.csv

Output:

    &quot;Les Miserables Episode 1: The Bishop (broadcast date: 1937-07-23)&quot;
    00:10:24
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-103/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use Text::CSV; # imports `csv` function

sub challenge(Int $start-time, Int $current-time, Str $file-name) returns Str {
    my @playlist          = csv(in =&amp;gt; $file-name);
    my $playlist-length   = @playlist[*;0].sum;                                      # [1]
    my $playlist-position = ($current-time - $start-time) * 1000 % $playlist-length;

    my ($track, $timestamp);
    for @playlist -&amp;gt; ($track-length, $track-name) {
        # If we are &amp;lt;= the playlist position, skip to the next track
        if $track-length &amp;lt;= $playlist-position {
            $playlist-position -= $track-length;
            next;                                                                    # [2]
        }

        # We know we are in the right track now, so find how far in we are
        $track            = $track-name;
        my $total-seconds = ($playlist-position / 1000).Int;
        my $hour          = ($total-seconds / 3600).Int;
        my $minutes       = ($total-seconds % 3600 / 60).Int;
        my $seconds       = $total-seconds % 60;
        $timestamp        = sprintf('%02d:%02d:%02d', $hour, $minutes, $seconds);
        last;                                                                        # [3]
    }

    &quot;$track\n$timestamp&quot;;
}

sub MAIN(Int $start-time, Int $current-time, Str $file-name) {
    say challenge($start-time, $current-time, $file-name);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Assumes `filelist.csv` contains the above input
$ raku ch-2.raku 1606134123 1614591276 filelist.csv
Les Miserables Episode 1: The Bishop (broadcast date: 1937-07-23)
00:10:24
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I found this question to be &lt;em&gt;incredibly&lt;/em&gt; confusing. Maybe it is the wording, or the fact that it was written by a guest author, but it didn‚Äôt make sense to me at first. Additionally, we are &lt;em&gt;explicitly&lt;/em&gt; told that one set of numbers (the ones in the CSV) are in milliseconds, and the others are not specified; I started programming this assuming they are &lt;em&gt;also&lt;/em&gt; in milliseconds only to have to figure out later on they are in seconds. With that out of the way, let‚Äôs look at the actual logic:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Read the CSV into a list of lists.&lt;/li&gt;
  &lt;li&gt;Find the total length of the playlist.&lt;/li&gt;
  &lt;li&gt;Find the position that we are in the playlist (in milliseconds).&lt;/li&gt;
  &lt;li&gt;Iterate through each track in the playlist:
    &lt;ul&gt;
      &lt;li&gt;If the length of the track is less than the position in the playlist, decrement the position in the playlist by the length of the track and continue&lt;/li&gt;
      &lt;li&gt;Otherwise, we are &lt;em&gt;in&lt;/em&gt; the track we need to be in, and we need to find the position in the track. We do this by calculating the total seconds we are into the track, then formatting that using some simple division. It‚Äôs also important we remember to break after we have found what track we are in.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;This is an interesting way to find the sum of a particular index in the list. This says ‚Äúgive me position 0 for the whole list, then sum it.‚Äù&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt; is the equivalent of something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;continue&lt;/code&gt; in other languages.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;last&lt;/code&gt; is the equivalent of something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;break&lt;/code&gt; in other languages.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Overall, not my favorite set of questions this week, but what can you do! Hope y‚Äôall enjoy the rest of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Metal Ox&lt;/code&gt; year!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Challenge two this week was‚Ä¶ interesting, to say the least. But, we are through it, and it‚Äôs the weekend! üçª</summary></entry><entry><title type="html">Perl Weekly Challenge 102</title><link href="http://localhost:4000/blog/perl-weekly-challenge-102/" rel="alternate" type="text/html" title="Perl Weekly Challenge 102" /><published>2021-03-07T00:00:00-06:00</published><updated>2021-03-07T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-102</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-102/">&lt;p&gt;Part one was an exercise in efficiency and &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;short-circuiting&lt;/a&gt;; I am sure there are more optimizations I could add, but it works as is. üôÇ Let me know if you see any obvious ones I could add!&lt;/p&gt;

&lt;h2 id=&quot;task-1-rare-numbers&quot;&gt;Task 1: Rare Numbers&lt;/h2&gt;

&lt;p&gt;You are given a positive integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to generate all Rare numbers of size &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; if exists. Please checkout the &lt;a href=&quot;http://www.shyamsundergupta.com/rare.htm&quot;&gt;page&lt;/a&gt; for more information about it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you don‚Äôt want to go to the link above, a rare number basically has the following characteristics:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$N + $N.reverse = &amp;lt;perfect square&amp;gt;
$N - $N.reverse = &amp;lt;perfect square&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a) 2 digits: 65
(b) 6 digits: 621770
(c) 9 digits: 281089082
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-102/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub digital-root(Int $N) returns Int {
    my @digits = $N.comb;
    my $digital-root = [+] @digits;
    while @digits.elems &amp;gt; 1 {
        @digits = $digital-root.comb;
        $digital-root = [+] @digits;
    }
    $digital-root;
}

sub is-rare(Int $N) returns Bool {
    return False if $N.comb.head % 2 != 0;
    return False if digital-root($N) ~~ 0|1|3|4|6|7; # [1][2]

    my $reversed   = $N.flip.Int;
    my $difference = $N - $reversed;

    if $difference &amp;gt;= 0 &amp;amp;&amp;amp; $difference.sqrt.narrow ~~ Int { # [3]
        # Only calculate this if the difference is valid
        my $sum = $N + $reversed;
        $sum.sqrt.narrow ~~ Int;
    } else {
        False;
    }
}

sub challenge(Int $N) returns Str {
    my $min = ('2' ~ ('0' x $N - 1)).Int;
    my $max = ('8' ~ ('9' x $N - 1)).Int;
    ($min..$max).hyper.grep(&amp;amp;is-rare).join(', '); # [4][5]
}

sub MAIN(Int $N) {
    say challenge($N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 6
621770
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This implementation is not overly clever; it basically just goes through every number of size &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; and checks if it is a rare number. It does use some Raku-isms as well as some logic to short-circuit. For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N = 6&lt;/code&gt; it runs in ~8 seconds on my machine.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Find the minimum and maximum number of size &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; it &lt;em&gt;could&lt;/em&gt; be (according to the link in the challenge, rare numbers cannot start with an odd digit, so for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N = 6&lt;/code&gt; or range becomes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;200000..899999&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;For each candidate:
    &lt;ul&gt;
      &lt;li&gt;Skip this candidate if the first digit is not even.&lt;/li&gt;
      &lt;li&gt;Skip this candidate if the &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_root&quot;&gt;digital root&lt;/a&gt; is not one of 2, 5, 8, or 9 (again, this fact comes from the link in the challenge).&lt;/li&gt;
      &lt;li&gt;Find the reversed number and the difference (only the difference for now. My thought is it is easier to calculate the square root of smaller numbers, so there is no reason to calculate the square root of the larger number if the smaller one fails).&lt;/li&gt;
      &lt;li&gt;If the difference is greater-than-or-equal-to zero &lt;em&gt;and&lt;/em&gt; its square root is an integer, calculate the sum and check if it is also a perfect square.
        &lt;ul&gt;
          &lt;li&gt;If so, return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;.&lt;/li&gt;
          &lt;li&gt;If any step is false, return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Given that my day job is all Scala, where &lt;a href=&quot;https://blog.knoldus.com/scala-best-practices-say-no-to-return/&quot;&gt;using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; is discouraged&lt;/a&gt;, you‚Äôll notice that bleeds into my Raku as well. The reason we use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; here is to explicitly short-circuit this function in idiomatic Raku (with the condition following the actual declaration [&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return False&lt;/code&gt;]).&lt;/li&gt;
  &lt;li&gt;This is an anonymous way to create a &lt;a href=&quot;https://docs.raku.org/type/Junction&quot;&gt;Junction&lt;/a&gt;. In this case, we are saying ‚Äúif the digital root matches any of 0 or 1 or 3 or 4 or 6 or 7‚Äù in a more idiomatic way.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/narrow&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;narrow&lt;/code&gt;&lt;/a&gt; is a way to find the narrowest type a number fits into. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N.sqrt&lt;/code&gt; returns a &lt;a href=&quot;https://docs.raku.org/type/Num&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Num&lt;/code&gt;&lt;/a&gt; object, even if the value is an integer. This is the idiomatic way to check that the returned value is an integer.
    &lt;ul&gt;
      &lt;li&gt;I am glad I found this, because in the past I would have done something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N.sqrt.Int == $N.sqrt&lt;/code&gt;, which requires me to duplicate computations.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/hyper&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hyper&lt;/code&gt;&lt;/a&gt; allows us to perform some action (in this case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt;) on a sequence &lt;em&gt;in parallel&lt;/em&gt; while still keeping the output in the original order of the sequence (see &lt;a href=&quot;https://docs.raku.org/routine/race&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;race&lt;/code&gt;&lt;/a&gt; if order doesn‚Äôt matter).&lt;/li&gt;
  &lt;li&gt;We are able to pass a function to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt;. Since functions are first-class citizens in Raku, they come with their own &lt;a href=&quot;https://docs.raku.org/language/variables#index-entry-sigil_&amp;amp;&quot;&gt;sigil&lt;/a&gt;, so we pass it in as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;function-name&lt;/code&gt;. This is the equivalent of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.grep(-&amp;gt; $candidate { is-rare($candidate) })&lt;/code&gt;, but easier to write.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-hash-counting-string&quot;&gt;Task 2: Hash-counting String&lt;/h2&gt;

&lt;p&gt;You are given a positive integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to produce Hash-counting string of that length.&lt;/p&gt;

&lt;p&gt;The definition of a hash-counting string is as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the string consists only of digits 0-9 and hashes, ‚Äò#‚Äô&lt;/li&gt;
  &lt;li&gt;there are no two consecutive hashes: ‚Äò##‚Äô does not appear in your string&lt;/li&gt;
  &lt;li&gt;the last character is a hash&lt;/li&gt;
  &lt;li&gt;the number immediately preceding each hash (if it exists) is the position of that hash in the string, with the position being counted up from 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It can be shown that for every positive integer N there is exactly one such length-N string.&lt;/p&gt;

&lt;h3 id=&quot;examples-1&quot;&gt;Examples&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a) &quot;#&quot; is the counting string of length 1
(b) &quot;2#&quot; is the counting string of length 2
(c) &quot;#3#&quot; is the string of length 3
(d) &quot;#3#5#7#10#&quot; is the string of length 10
(e) &quot;2#4#6#8#11#14#&quot; is the string of length 14
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-102/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Int $N) returns Str {
    my @output;
    my $index = $N - 1;
    while $index &amp;gt;= 0 {
        @output[$index] = '#';
        my $position = $index + 1; # Position is 1-based while index is 0-based
        for $position.flip.comb.kv -&amp;gt; $offset, $digit {
            @output[$index - ($offset + 1)] = $digit;
        }
        $index -= ($position.chars + 1);
    }
    @output.join;
}

sub MAIN(Int $N) {
    say challenge($N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 14
2#4#6#8#11#14#
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;We are given two really concrete details about the sequence:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the last character is a hash&lt;/li&gt;
  &lt;li&gt;the number immediately preceding each hash (if it exists) is the position of that hash in the string, with the position being counted up from 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given that, we follow the following steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Define an array (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt;) and start from the end (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$index = $N - 1&lt;/code&gt;, since the array is 0-indexed).&lt;/li&gt;
  &lt;li&gt;While &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$index&lt;/code&gt; is greater-than-or-equal-to zero:
    &lt;ul&gt;
      &lt;li&gt;Set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output[$index]&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Find the 1-based index (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$position&lt;/code&gt;) of that hash character (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$index + 1&lt;/code&gt;).&lt;/li&gt;
      &lt;li&gt;Iterate &lt;strong&gt;backwards&lt;/strong&gt; through the 1-based index and fill in the indices in front of the newly-placed &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#&lt;/code&gt; with the digits of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$position&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Decrement &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$index&lt;/code&gt; by the amount of characters in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$position + 1&lt;/code&gt; (the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; is for the hash character).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;p&gt;Nothing to add here; this one is pretty straight forward.&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;It‚Äôs pretty cool that Raku has &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.sqrt&lt;/code&gt; built right in, but I find it odd that it doesn‚Äôt have some sort of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.is-whole&lt;/code&gt; functionality (Python has &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.is_integer()&lt;/code&gt;, Scala has &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.isWhole&lt;/code&gt;). Maybe it does, and the documentation is just bad; it would not be the first time I have run into that! Honestly, if you read back through my blog, I think I have found 3 separate ways to check if a floating-point number (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Num&lt;/code&gt;) is an integer (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;) in Raku. Oh well, I guess it is all part of the journey!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Part one was an exercise in efficiency and short-circuiting; I am sure there are more optimizations I could add, but it works as is. üôÇ Let me know if you see any obvious ones I could add!</summary></entry></feed>