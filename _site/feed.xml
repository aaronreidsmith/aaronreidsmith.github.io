<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-03-21T10:42:36-05:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Aaron Smith</title><subtitle>Personal website and blog of Aaron Smith</subtitle><author><name>Aaron Smith</name></author><entry><title type="html">Perl Weekly Challenge 104</title><link href="http://localhost:4000/blog/perl-weekly-challenge-104/" rel="alternate" type="text/html" title="Perl Weekly Challenge 104" /><published>2021-03-21T00:00:00-05:00</published><updated>2021-03-21T00:00:00-05:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-104</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-104/">&lt;p&gt;This week had some fun topics like &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_(computer_science)&quot;&gt;recursion&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Memoization&quot;&gt;memoization&lt;/a&gt;, and IO/data validation!&lt;/p&gt;

&lt;h2 id=&quot;task-1-fusc-sequence&quot;&gt;Task 1: FUSC Sequence&lt;/h2&gt;

&lt;p&gt;Write a script to generate first 50 members of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FUSC&lt;/code&gt; Sequence. Please refer to &lt;a href=&quot;http://oeis.org/A002487&quot;&gt;OEIS&lt;/a&gt; for more information.&lt;/p&gt;

&lt;p&gt;The sequence defined as below:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fusc(0) = 0
fusc(1) = 1
for n &amp;gt; 1:
when n is even: fusc(n) = fusc(n / 2),
when n is odd: fusc(n) = fusc((n-1)/2) + fusc((n+1)/2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use experimental :cached; # [1]

sub fusc(Int(Rat) $n) is cached returns Int { # [2]
    given $n {
        when 0      { 0 }
        when 1      { 1 }
        when * %% 2 { fusc($n / 2) }                            # [3]
        default     { fusc(($n - 1) / 2) + fusc(($n + 1) / 2) } # [4]
    }
}

sub MAIN(Int $terms = 50) {
    say (^$terms).map(&amp;amp;fusc); # [4]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku
(0 1 1 2 1 3 2 3 1 4 3 5 2 5 3 4 1 5 4 7 3 8 5 7 2 7 5 8 3 7 4 5 1 6 5 9 4 11 7 10 3 11 8 13 5 12 7 9 2 9)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I feel like this is pretty straight forward, and aligns well to the definition of the FUSC sequence. When we look at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt;, we run through the following logic:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Is it 0? Return 0.&lt;/li&gt;
  &lt;li&gt;Is it 1? Return 1.&lt;/li&gt;
  &lt;li&gt;Is it even? Return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc($n / 2)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Otherwise, return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(($n - 1) / 2) + fusc(($n + 1) / 2)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The function recurses until it ends up in one of the two stopping conditions (0 or 1). So obviously &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(50)&lt;/code&gt; is going to go through &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(49)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(48)&lt;/code&gt;, etc. See below for how we make this efficient.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Caching in Raku is an experimental feature, so we have to import it (and add the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is cached&lt;/code&gt; trait to our subroutine). The basic idea is that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc($n)&lt;/code&gt; is &lt;em&gt;always&lt;/em&gt; the same value, so once we calculate it once, we can just look it up later. Adding this trait essentially adds a hash behind the scenes that checks if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc($n)&lt;/code&gt; already exists. If it does, it just returns that value, otherwise, it will actually calculate the value and store it in the hash before returning.&lt;/li&gt;
  &lt;li&gt;Notice the function signature takes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int(Rat)&lt;/code&gt;. This means that this function will accept either &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; &lt;em&gt;or&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rat&lt;/code&gt; (&lt;a href=&quot;https://docs.raku.org/type/Rat&quot;&gt;Rational number&lt;/a&gt;) types, but it will coerce the input to an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;. The reason for this is that division in Raku will generate a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Rat&lt;/code&gt; type, even for something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2 / 1&lt;/code&gt;. So we need to convert it to an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; on the recursive calls. This saves use from having to write &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fusc(($n / 2).Int)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Raku has a special “is divisible by” operator. So instead of saying &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n % 2 == 0&lt;/code&gt;, we can say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n %% 2&lt;/code&gt;. Also notice that in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; block, we have to use the “whatever star” (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;) to do this operation; this is because we can’t &lt;a href=&quot;https://docs.raku.org/language/operators#index-entry-smartmatch_operator&quot;&gt;smartmatch&lt;/a&gt; against &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%% 2&lt;/code&gt;, so we need to be more explicit.&lt;/li&gt;
  &lt;li&gt;Remember when passing a function as an argument (in this case to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt;), it has a special &lt;a href=&quot;https://docs.raku.org/language/variables#index-entry-sigil_&amp;amp;&quot;&gt;sigil&lt;/a&gt; – &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-nim-game&quot;&gt;Task 2: NIM Game&lt;/h2&gt;

&lt;p&gt;Write a script to simulate the NIM Game.&lt;/p&gt;

&lt;p&gt;It is played between 2 players. For the purpose of this task, let assume you play against the machine.&lt;/p&gt;

&lt;p&gt;There are 3 simple rules to follow:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a) You have 12 tokens
b) Each player can pick 1, 2 or 3 tokens at a time
c) The player who picks the last token wins the game
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-104/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Formats a message defined as plural to be singular if $n == 1
sub format(Str $message, Int $n) returns Str {
    $n == 1 ?? $message.trans(['are', 'tokens'] =&amp;gt; ['is', 'token']) !! $message; # [1]
}

sub challenge(Int $n) {
    my $remaining = $n;

    # Defined within the challenge sub because it references $remaining
    sub default-prompt returns Any {
        prompt(format(&quot;There are $remaining tokens. How many would you like to pick up? (1, 2, 3) &quot;, $remaining)); # [2]
    }

    my $input = default-prompt;
    my $most-recent-move;
    while $remaining &amp;gt; 0 {
        given $input {
            when 1|2|3 {
                if $input &amp;gt; $remaining {
                    $input = prompt(&quot;There are only $remaining tokens left. Please enter a valid number &quot;)
                } else {
                    say format(&quot;You take $input tokens&quot;, $input);
                    $remaining -= $input;
                    $most-recent-move = 'You';

                    last if $remaining == 0;

                    # If there are only 3 or less tokens, take all of them. Otherwise, take a random number between 1 and 3
                    my $bot-move = $remaining ~~ 1|2|3 ?? $remaining !! (1..3).pick;
                    say format(&quot;The computer takes $bot-move tokens&quot;, $bot-move);
                    $remaining -= $bot-move;
                    $most-recent-move = 'Computer';

                    last if $remaining == 0;

                    $input = default-prompt;
                }
            }
            default { $input = prompt('Please enter 1, 2, or 3 ') }
        }
    }
    say $most-recent-move eq 'Computer' ?? 'The computer wins!' !! 'You win!'; # [3]
}

sub MAIN(Int $n where $n &amp;gt; 0 = 12) { # [4]
    challenge($n);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku
There are 12 tokens. How many would you like to pick up? (1, 2, 3) 3
You take 3 tokens
The computer takes 3 tokens
There are 6 tokens. How many would you like to pick up? (1, 2, 3) 2
You take 2 tokens
The computer takes 3 tokens
There is 1 token. How many would you like to pick up? (1, 2, 3) 1
You take 1 token
You win!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This task is basically an exercise in IO (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prompt&lt;/code&gt;) and data validation (did I get what I expect?). We follow the following steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Ask the user to give us a number (1, 2, or 3).
    &lt;ul&gt;
      &lt;li&gt;Did they give it to us? Move on to step 2.&lt;/li&gt;
      &lt;li&gt;Otherwise, keep asking for a valid input (doesn’t matter if they gave us an invalid number, a string, etc.).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Do a special check to see if their number is higher than the remaining tokens (only happens when there are 3 or fewer tokens). If so, keep prompting them for a valid input.&lt;/li&gt;
  &lt;li&gt;Now that we know we have valid input, decrement &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$remaining&lt;/code&gt; to reflect the number of token the user took.&lt;/li&gt;
  &lt;li&gt;If there are 0 tokens left, exit the loop and print that the user won.&lt;/li&gt;
  &lt;li&gt;Otherwise, there are tokens left, and it is the computer’s turn. Our bot is semi-smart, so if there are 3 or fewer tokens take all of them (and win). Otherwise, take a random valid number of tokens.&lt;/li&gt;
  &lt;li&gt;If there are 0 tokens left, exit the loop and print that th computer won.&lt;/li&gt;
  &lt;li&gt;Finally, if there are still tokens left, repeat steps 1-6 until there are 0 tokens left.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;This is simply a helper function, so we can write all of our prompts like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;There are $n tokens remaining&quot;&lt;/code&gt; and they will get properly formatted if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; is 1. This is very specific to this question, obviously, but it is useful. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trans&lt;/code&gt; basically just translates all &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;are&lt;/code&gt; instances to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is&lt;/code&gt; and all &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tokens&lt;/code&gt; instances to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;token&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;You’ll notice a few things about this subroutine. First, we don’t have to define it with parentheses if it doesn’t take any arguments. Second, it returns &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Any&lt;/code&gt; because we don’t know what we are going to get from the user. Third, it is defined &lt;em&gt;inside&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; because it is acting as a &lt;a href=&quot;https://simple.wikipedia.org/wiki/Closure_(computer_science)&quot;&gt;closure&lt;/a&gt;, meaning it references variables defined outside itself (in this case, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$remaining&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Raku is kind of strange in that if you want to do string equality you have to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eq&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;This function signature specifies that it takes an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt; that is greater than 0, and if it is not provided, it defaults to 12.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Raku gives us some cool tools to make these challenges easier. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; syntax was especially helpful in both of these challenges (and in others)!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">This week had some fun topics like recursion, memoization, and IO/data validation!</summary></entry><entry><title type="html">Perl Weekly Challenge 103</title><link href="http://localhost:4000/blog/perl-weekly-challenge-103/" rel="alternate" type="text/html" title="Perl Weekly Challenge 103" /><published>2021-03-13T00:00:00-06:00</published><updated>2021-03-13T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-103</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-103/">&lt;p&gt;Challenge two this week was… interesting, to say the least. But, we are through it, and it’s the weekend! 🍻&lt;/p&gt;

&lt;h2 id=&quot;task-1-chinese-zodiac&quot;&gt;Task 1: Chinese Zodiac&lt;/h2&gt;

&lt;p&gt;You are given a year &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$year&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to determine the Chinese Zodiac for the given year &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$year&lt;/code&gt;. Please check out &lt;a href=&quot;https://en.wikipedia.org/wiki/Chinese_zodiac&quot;&gt;wikipage&lt;/a&gt; for more information about it.&lt;/p&gt;

&lt;p&gt;The animal cycle: Rat, Ox, Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig.&lt;br /&gt;
The element cycle: Wood, Fire, Earth, Metal, Water.&lt;/p&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-103/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Int $year) returns Str {
    constant $root-year = 1924; # From Wikipedia

    my $difference         = $year - $root-year;
    my $element-difference = $difference &amp;lt; 0 ?? $difference + 10 !! $difference; # [1]
    my $animal-difference  = $difference &amp;lt; 0 ?? $difference + 12 !! $difference;

    my $element = do given $element-difference % 10 { # [2][3]
        when 0|1 { 'Wood'  }
        when 2|3 { 'Fire'  }
        when 4|5 { 'Earth' }
        when 6|7 { 'Metal' }
        when 8|9 { 'Water' }
    }
    my $animal = do given $animal-difference % 12 {
        when 0  { 'Rat'     }
        when 1  { 'Ox'      }
        when 2  { 'Tiger'   }
        when 3  { 'Rabbit'  }
        when 4  { 'Dragon'  }
        when 5  { 'Snake'   }
        when 6  { 'Horse'   }
        when 7  { 'Goat'    }
        when 8  { 'Monkey'  }
        when 9  { 'Rooster' }
        when 10 { 'Dog'     }
        when 11 { 'Pig'     }
    }

    &quot;$element $animal&quot;; # [4]
}

sub MAIN(Int $year) {
    say challenge($year);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 2017
Fire Rooster
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I’m sure there is a better root than 1924, but that is the first year in the table on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Chinese_zodiac&quot;&gt;Wikipedia page&lt;/a&gt;. Reading through the Wikipedia page, we can see two things:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The element cycle has 5 rotations (Wood, Fire, Earth, Metal, and Water), and each one lasts for 2 years (a Yin year and a Yang year [which we don’t care about]).&lt;/li&gt;
  &lt;li&gt;The animal cycle has 12 rotations (Rat, Ox,  Tiger, Rabbit, Dragon, Snake, Horse, Goat, Monkey, Rooster, Dog, Pig), and each one lasts for 1 year.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This makes our logic pretty simple – we just need to find our distance from the known year of 1924 and find which cycle that year falls in. For element, we find the difference and then find the remainder after dividing by 10 (5 cycles x 2 years each). If it is 0 or 1, it is Wood, if it is 2 or 3 it is Fire, etc. Similarly, we find the difference and find the remainder after dividing by 12 for the animals. If it is 0 it is Rat, if it is 1 it is Ox, etc. That’s it!&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;We can’t just do &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;abs($year - $root-year)&lt;/code&gt; because for years before &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$root-year&lt;/code&gt;, it would yield the wrong cycle (for example, 1923 would have a remainder of 1 for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$element&lt;/code&gt; instead of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;9&lt;/code&gt;). Because of this, if the difference is negative, we need to add the size of the cycle (10 and 12, respectively) to put it in its correct place.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; is a flow control keyword and doesn’t actually return anything. To make the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt; block return its value, we need to add the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do&lt;/code&gt; keyword before it.&lt;/li&gt;
  &lt;li&gt;You’ll notice there is no &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt; block for these &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given&lt;/code&gt;s. That is intentional, since we know all the possible outcomes. Best practice would probably be something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default { die &quot;Unexpected input: $_&quot; }&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Double quotes tell the Raku compiler to interpolate this string, so we get &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;Fire Rooster&quot;&lt;/code&gt; instead of the literal &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'$element $animal'&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-whats-playing&quot;&gt;Task 2: What’s playing?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Note: This was copied directly from &lt;a href=&quot;https://perlweeklychallenge.org/blog/perl-weekly-challenge-103/#TASK2&quot;&gt;perlweeklychallenge.org&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Working from home, you decided that on occasion you wanted some background noise while working. You threw together a network streamer to continuously loop through the files and launched it in a tmux (or screen) session, giving it a directory tree of files to play. During the day, you connected an audio player to the stream, listening through the workday, closing it when done.&lt;/p&gt;

&lt;p&gt;For weeks you connect to the stream daily, slowly noticing a gradual drift of the media. After several weeks, you take vacation. When you return, you are pleasantly surprised to find the streamer still running. Before connecting, however, if you consider the puzzle of determining which track is playing.&lt;/p&gt;

&lt;p&gt;After looking at a few modules to read info regarding the media, a quick bit of coding gave you a file list. The file list is in a simple CSV format, each line containing two fields: the first the number of milliseconds in length, the latter the media’s title (this example is of several episodes available from the MercuryTheatre.info):&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1709363,&quot;Les Miserables Episode 1: The Bishop (broadcast date: 1937-07-23)&quot;
1723781,&quot;Les Miserables Episode 2: Javert (broadcast date: 1937-07-30)&quot;
1723781,&quot;Les Miserables Episode 3: The Trial (broadcast date: 1937-08-06)&quot;
1678356,&quot;Les Miserables Episode 4: Cosette (broadcast date: 1937-08-13)&quot;
1646043,&quot;Les Miserables Episode 5: The Grave (broadcast date: 1937-08-20)&quot;
1714640,&quot;Les Miserables Episode 6: The Barricade (broadcast date: 1937-08-27)&quot;
1714640,&quot;Les Miserables Episode 7: Conclusion (broadcast date: 1937-09-03)&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For this script, you can assume to be provided the following information:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* the value of $^T ($BASETIME) of the streamer script,
* the value of time(), and
* a CSV file containing the media to play consisting of the length in milliseconds and an identifier for the media (title, filename, or other).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Write a program to output which file is currently playing. For purposes of this script, you may assume gapless playback, and format the output as you see fit.&lt;/p&gt;

&lt;p&gt;Optional: Also display the current position in the media as a time-like value.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 3 command line parameters: start time, current time, file name

    # starttime
    1606134123

    # currenttime
    1614591276

    # filelist.csv

Output:

    &quot;Les Miserables Episode 1: The Bishop (broadcast date: 1937-07-23)&quot;
    00:10:24
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-103/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use Text::CSV; # imports `csv` function

sub challenge(Int $start-time, Int $current-time, Str $file-name) returns Str {
    my @playlist          = csv(in =&amp;gt; $file-name);
    my $playlist-length   = @playlist[*;0].sum;                                      # [1]
    my $playlist-position = ($current-time - $start-time) * 1000 % $playlist-length;

    my ($track, $timestamp);
    for @playlist -&amp;gt; ($track-length, $track-name) {
        # If we are &amp;lt;= the playlist position, skip to the next track
        if $track-length &amp;lt;= $playlist-position {
            $playlist-position -= $track-length;
            next;                                                                    # [2]
        }

        # We know we are in the right track now, so find how far in we are
        $track            = $track-name;
        my $total-seconds = ($playlist-position / 1000).Int;
        my $hour          = ($total-seconds / 3600).Int;
        my $minutes       = ($total-seconds % 3600 / 60).Int;
        my $seconds       = $total-seconds % 60;
        $timestamp        = sprintf('%02d:%02d:%02d', $hour, $minutes, $seconds);
        last;                                                                        # [3]
    }

    &quot;$track\n$timestamp&quot;;
}

sub MAIN(Int $start-time, Int $current-time, Str $file-name) {
    say challenge($start-time, $current-time, $file-name);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Assumes `filelist.csv` contains the above input
$ raku ch-2.raku 1606134123 1614591276 filelist.csv
Les Miserables Episode 1: The Bishop (broadcast date: 1937-07-23)
00:10:24
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I found this question to be &lt;em&gt;incredibly&lt;/em&gt; confusing. Maybe it is the wording, or the fact that it was written by a guest author, but it didn’t make sense to me at first. Additionally, we are &lt;em&gt;explicitly&lt;/em&gt; told that one set of numbers (the ones in the CSV) are in milliseconds, and the others are not specified; I started programming this assuming they are &lt;em&gt;also&lt;/em&gt; in milliseconds only to have to figure out later on they are in seconds. With that out of the way, let’s look at the actual logic:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Read the CSV into a list of lists.&lt;/li&gt;
  &lt;li&gt;Find the total length of the playlist.&lt;/li&gt;
  &lt;li&gt;Find the position that we are in the playlist (in milliseconds).&lt;/li&gt;
  &lt;li&gt;Iterate through each track in the playlist:
    &lt;ul&gt;
      &lt;li&gt;If the length of the track is less than the position in the playlist, decrement the position in the playlist by the length of the track and continue&lt;/li&gt;
      &lt;li&gt;Otherwise, we are &lt;em&gt;in&lt;/em&gt; the track we need to be in, and we need to find the position in the track. We do this by calculating the total seconds we are into the track, then formatting that using some simple division. It’s also important we remember to break after we have found what track we are in.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;This is an interesting way to find the sum of a particular index in the list. This says “give me position 0 for the whole list, then sum it.”&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt; is the equivalent of something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;continue&lt;/code&gt; in other languages.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;last&lt;/code&gt; is the equivalent of something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;break&lt;/code&gt; in other languages.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Overall, not my favorite set of questions this week, but what can you do! Hope y’all enjoy the rest of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Metal Ox&lt;/code&gt; year!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Challenge two this week was… interesting, to say the least. But, we are through it, and it’s the weekend! 🍻</summary></entry><entry><title type="html">Perl Weekly Challenge 102</title><link href="http://localhost:4000/blog/perl-weekly-challenge-102/" rel="alternate" type="text/html" title="Perl Weekly Challenge 102" /><published>2021-03-07T00:00:00-06:00</published><updated>2021-03-07T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-102</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-102/">&lt;p&gt;Part one was an exercise in efficiency and &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;short-circuiting&lt;/a&gt;; I am sure there are more optimizations I could add, but it works as is. 🙂 Let me know if you see any obvious ones I could add!&lt;/p&gt;

&lt;h2 id=&quot;task-1-rare-numbers&quot;&gt;Task 1: Rare Numbers&lt;/h2&gt;

&lt;p&gt;You are given a positive integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to generate all Rare numbers of size &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; if exists. Please checkout the &lt;a href=&quot;http://www.shyamsundergupta.com/rare.htm&quot;&gt;page&lt;/a&gt; for more information about it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you don’t want to go to the link above, a rare number basically has the following characteristics:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$N + $N.reverse = &amp;lt;perfect square&amp;gt;
$N - $N.reverse = &amp;lt;perfect square&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a) 2 digits: 65
(b) 6 digits: 621770
(c) 9 digits: 281089082
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-102/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub digital-root(Int $N) returns Int {
    my @digits = $N.comb;
    my $digital-root = [+] @digits;
    while @digits.elems &amp;gt; 1 {
        @digits = $digital-root.comb;
        $digital-root = [+] @digits;
    }
    $digital-root;
}

sub is-rare(Int $N) returns Bool {
    return False if $N.comb.head % 2 != 0;
    return False if digital-root($N) ~~ 0|1|3|4|6|7; # [1][2]

    my $reversed   = $N.flip.Int;
    my $difference = $N - $reversed;

    if $difference &amp;gt;= 0 &amp;amp;&amp;amp; $difference.sqrt.narrow ~~ Int { # [3]
        # Only calculate this if the difference is valid
        my $sum = $N + $reversed;
        $sum.sqrt.narrow ~~ Int;
    } else {
        False;
    }
}

sub challenge(Int $N) returns Str {
    my $min = ('2' ~ ('0' x $N - 1)).Int;
    my $max = ('8' ~ ('9' x $N - 1)).Int;
    ($min..$max).hyper.grep(&amp;amp;is-rare).join(', '); # [4][5]
}

sub MAIN(Int $N) {
    say challenge($N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 6
621770
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This implementation is not overly clever; it basically just goes through every number of size &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; and checks if it is a rare number. It does use some Raku-isms as well as some logic to short-circuit. For &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N = 6&lt;/code&gt; it runs in ~8 seconds on my machine.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Find the minimum and maximum number of size &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; it &lt;em&gt;could&lt;/em&gt; be (according to the link in the challenge, rare numbers cannot start with an odd digit, so for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N = 6&lt;/code&gt; or range becomes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;200000..899999&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;For each candidate:
    &lt;ul&gt;
      &lt;li&gt;Skip this candidate if the first digit is not even.&lt;/li&gt;
      &lt;li&gt;Skip this candidate if the &lt;a href=&quot;https://en.wikipedia.org/wiki/Digital_root&quot;&gt;digital root&lt;/a&gt; is not one of 2, 5, 8, or 9 (again, this fact comes from the link in the challenge).&lt;/li&gt;
      &lt;li&gt;Find the reversed number and the difference (only the difference for now. My thought is it is easier to calculate the square root of smaller numbers, so there is no reason to calculate the square root of the larger number if the smaller one fails).&lt;/li&gt;
      &lt;li&gt;If the difference is greater-than-or-equal-to zero &lt;em&gt;and&lt;/em&gt; its square root is an integer, calculate the sum and check if it is also a perfect square.
        &lt;ul&gt;
          &lt;li&gt;If so, return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;.&lt;/li&gt;
          &lt;li&gt;If any step is false, return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Given that my day job is all Scala, where &lt;a href=&quot;https://blog.knoldus.com/scala-best-practices-say-no-to-return/&quot;&gt;using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; is discouraged&lt;/a&gt;, you’ll notice that bleeds into my Raku as well. The reason we use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return&lt;/code&gt; here is to explicitly short-circuit this function in idiomatic Raku (with the condition following the actual declaration [&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return False&lt;/code&gt;]).&lt;/li&gt;
  &lt;li&gt;This is an anonymous way to create a &lt;a href=&quot;https://docs.raku.org/type/Junction&quot;&gt;Junction&lt;/a&gt;. In this case, we are saying “if the digital root matches any of 0 or 1 or 3 or 4 or 6 or 7” in a more idiomatic way.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/narrow&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;narrow&lt;/code&gt;&lt;/a&gt; is a way to find the narrowest type a number fits into. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N.sqrt&lt;/code&gt; returns a &lt;a href=&quot;https://docs.raku.org/type/Num&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Num&lt;/code&gt;&lt;/a&gt; object, even if the value is an integer. This is the idiomatic way to check that the returned value is an integer.
    &lt;ul&gt;
      &lt;li&gt;I am glad I found this, because in the past I would have done something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N.sqrt.Int == $N.sqrt&lt;/code&gt;, which requires me to duplicate computations.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/hyper&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hyper&lt;/code&gt;&lt;/a&gt; allows us to perform some action (in this case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt;) on a sequence &lt;em&gt;in parallel&lt;/em&gt; while still keeping the output in the original order of the sequence (see &lt;a href=&quot;https://docs.raku.org/routine/race&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;race&lt;/code&gt;&lt;/a&gt; if order doesn’t matter).&lt;/li&gt;
  &lt;li&gt;We are able to pass a function to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;grep&lt;/code&gt;. Since functions are first-class citizens in Raku, they come with their own &lt;a href=&quot;https://docs.raku.org/language/variables#index-entry-sigil_&amp;amp;&quot;&gt;sigil&lt;/a&gt;, so we pass it in as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;function-name&lt;/code&gt;. This is the equivalent of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.grep(-&amp;gt; $candidate { is-rare($candidate) })&lt;/code&gt;, but easier to write.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-hash-counting-string&quot;&gt;Task 2: Hash-counting String&lt;/h2&gt;

&lt;p&gt;You are given a positive integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to produce Hash-counting string of that length.&lt;/p&gt;

&lt;p&gt;The definition of a hash-counting string is as follows:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the string consists only of digits 0-9 and hashes, ‘#’&lt;/li&gt;
  &lt;li&gt;there are no two consecutive hashes: ‘##’ does not appear in your string&lt;/li&gt;
  &lt;li&gt;the last character is a hash&lt;/li&gt;
  &lt;li&gt;the number immediately preceding each hash (if it exists) is the position of that hash in the string, with the position being counted up from 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It can be shown that for every positive integer N there is exactly one such length-N string.&lt;/p&gt;

&lt;h3 id=&quot;examples-1&quot;&gt;Examples&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(a) &quot;#&quot; is the counting string of length 1
(b) &quot;2#&quot; is the counting string of length 2
(c) &quot;#3#&quot; is the string of length 3
(d) &quot;#3#5#7#10#&quot; is the string of length 10
(e) &quot;2#4#6#8#11#14#&quot; is the string of length 14
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-102/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Int $N) returns Str {
    my @output;
    my $index = $N - 1;
    while $index &amp;gt;= 0 {
        @output[$index] = '#';
        my $position = $index + 1; # Position is 1-based while index is 0-based
        for $position.flip.comb.kv -&amp;gt; $offset, $digit {
            @output[$index - ($offset + 1)] = $digit;
        }
        $index -= ($position.chars + 1);
    }
    @output.join;
}

sub MAIN(Int $N) {
    say challenge($N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 14
2#4#6#8#11#14#
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;We are given two really concrete details about the sequence:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the last character is a hash&lt;/li&gt;
  &lt;li&gt;the number immediately preceding each hash (if it exists) is the position of that hash in the string, with the position being counted up from 1&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given that, we follow the following steps:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Define an array (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt;) and start from the end (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$index = $N - 1&lt;/code&gt;, since the array is 0-indexed).&lt;/li&gt;
  &lt;li&gt;While &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$index&lt;/code&gt; is greater-than-or-equal-to zero:
    &lt;ul&gt;
      &lt;li&gt;Set &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output[$index]&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Find the 1-based index (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$position&lt;/code&gt;) of that hash character (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$index + 1&lt;/code&gt;).&lt;/li&gt;
      &lt;li&gt;Iterate &lt;strong&gt;backwards&lt;/strong&gt; through the 1-based index and fill in the indices in front of the newly-placed &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#&lt;/code&gt; with the digits of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$position&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;Decrement &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$index&lt;/code&gt; by the amount of characters in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$position + 1&lt;/code&gt; (the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; is for the hash character).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;p&gt;Nothing to add here; this one is pretty straight forward.&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;It’s pretty cool that Raku has &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.sqrt&lt;/code&gt; built right in, but I find it odd that it doesn’t have some sort of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.is-whole&lt;/code&gt; functionality (Python has &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.is_integer()&lt;/code&gt;, Scala has &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.isWhole&lt;/code&gt;). Maybe it does, and the documentation is just bad; it would not be the first time I have run into that! Honestly, if you read back through my blog, I think I have found 3 separate ways to check if a floating-point number (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Num&lt;/code&gt;) is an integer (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;) in Raku. Oh well, I guess it is all part of the journey!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Part one was an exercise in efficiency and short-circuiting; I am sure there are more optimizations I could add, but it works as is. 🙂 Let me know if you see any obvious ones I could add!</summary></entry><entry><title type="html">Perl Weekly Challenge 101</title><link href="http://localhost:4000/blog/perl-weekly-challenge-101/" rel="alternate" type="text/html" title="Perl Weekly Challenge 101" /><published>2021-02-27T00:00:00-06:00</published><updated>2021-02-27T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-101</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-101/">&lt;p&gt;This week was pretty fun – solution one ends up re-using some code from &lt;a href=&quot;https://aaronreidsmith.github.io/blog/perl-weekly-challenge-088/&quot;&gt;my first post&lt;/a&gt; (Challenge 88), and solution two explores &lt;a href=&quot;https://en.wikipedia.org/wiki/Barycentric_coordinate_system&quot;&gt;Barycentric coordinates&lt;/a&gt;! No ugly one-liners this week. 🙂&lt;/p&gt;

&lt;h2 id=&quot;task-1-pack-a-spiral&quot;&gt;Task 1: Pack a Spiral&lt;/h2&gt;

&lt;p&gt;You are given an array &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@A&lt;/code&gt; of items (integers say, but they can be anything).&lt;/p&gt;

&lt;p&gt;Your task is to pack that array into an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MxN&lt;/code&gt; matrix spirally &lt;strong&gt;counterclockwise&lt;/strong&gt;, as tightly as possible. “Tightly” means the absolute value of the difference between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|M-N|&lt;/code&gt;) has to be as small as possible.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @A = (1,2,3,4)

Output:

    4 3
    1 2

Since the given array is already a 1x4 matrix on its own, but that's not as tight as possible. Instead, you'd spiral it counterclockwise into

    4 3
    1 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @A = (1,2,3,4,5,6)

Output:

    6 5 4
    1 2 3

or

    5 4
    6 3
    1 2

Either will do as an answer, because they're equally tight.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-3&quot;&gt;Example 3&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @A = (1,2,3,4,5,6,7,8,9,10,11,12)

Output:

       9  8  7 6
      10 11 12 5
       1  2  3 4

or

       8  7 6
       9 12 5
      10 11 4
       1  2 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Finds all factor pairs of a given numbers
sub factors(Int $n) returns Positional {
    my $max = $n.sqrt.floor;
    my $number = 1;
    my @factors;
    while $number &amp;lt;= $max {
        my $potential-factor = $n / $number;
        if $potential-factor == $potential-factor.Int {
            @factors.push(($number.clone, $potential-factor)); # [1]
        }
        $number++;
    }
    @factors;
}

# Formats a 2D array into a multi-line string
sub format(@two-d) returns Str {
    my $width = @two-d[*;*].max(*.chars).chars;                                # [2]
    my @formatted = gather {
        for @two-d -&amp;gt; @row {
            take @row.map(-&amp;gt; $num { sprintf('%*s', $width, $num) }).join(' '); # [3]
        }
    }
    @formatted.join(&quot;\n&quot;);
}

sub challenge(@A) returns Str {
    enum Direction &amp;lt;NORTH EAST SOUTH WEST&amp;gt;;

    my @factors = factors(@A.elems);
    my ($m, $n) = @factors.min(-&amp;gt; ($a, $b) { abs($a - $b) });
    my (@matrix, @output);
    for ^$m {
        my (@matrix-row, @output-row);
        for ^$n {
            @matrix-row.push({ :!visited });
            @output-row.push(Nil)
        }
        @matrix.push(@matrix-row);
        @output.push(@output-row);
    }

    sub visit-cell($i, $j, $element) { # [4]
        my %cell = @matrix[$i][$j];
        if !%cell&amp;lt;visited&amp;gt; {
            @output[$i][$j] = $element;
        }
        @matrix[$i][$j]&amp;lt;visited&amp;gt; = True;
    }

    my ($min-row, $min-col) = 0, 0;
    my ($max-row, $max-col) = @matrix.elems - 1, @matrix.tail.elems - 1;
    my ($current-row, $current-col, $current-direction) = $min-row, $min-col, EAST;

    for @A -&amp;gt; $element {
        visit-cell($current-row, $current-col, $element);
        given $current-direction {
            when EAST {
                if $current-col == $max-col || @matrix[$current-row][$current-col+1]&amp;lt;visited&amp;gt; {
                    $current-direction = SOUTH;
                    $current-row += 1;
                } else {
                    $current-col += 1;
                }
            }
            when SOUTH {
                if ($current-row == $max-row &amp;amp;&amp;amp; $current-col == $max-col) || @matrix[$current-row+1][$current-col]&amp;lt;visited&amp;gt; {
                    $current-direction = WEST;
                    $current-col -= 1;
                } else {
                    $current-row += 1;
                }
            }
            when WEST {
                if $current-col == $min-col || @matrix[$current-row][$current-col-1]&amp;lt;visited&amp;gt; {
                    $current-direction = NORTH;
                    $current-row -= 1;
                } else {
                    $current-col -= 1;
                }
            }
            when NORTH {
                # No need to check for special case here, because we always start in the top left
                if @matrix[$current-row-1][$current-col]&amp;lt;visited&amp;gt; {
                    $current-direction = EAST;
                    $current-col += 1;
                } else {
                    $current-row -= 1;
                }
            }
        }
    }

    format(@output.reverse);
}

sub MAIN(*@A) {
    say challenge(@A);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 1 2 3 4
4 3
2 1

$ raku ch-1.raku 1 2 3 4 5 6
6 5 4
1 2 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The problem says to wrap the spiral counterclockwise (i.e., start at the bottom left, and fill-in counterclockwise), this is pretty hard to do, given a dynamic-sized array. What I did instead was start at the top left, fill in clockwise, then reverse (mirror) the outer array, so the spiral started at the bottom left.&lt;/p&gt;

&lt;p&gt;Here is the basic logic:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Find all the factors of the length of the input array.&lt;/li&gt;
  &lt;li&gt;Find the pair of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; such that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|M-N|&lt;/code&gt; is minimized
    &lt;ul&gt;
      &lt;li&gt;Because of the way we find the factors, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M&lt;/code&gt; will always be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt;= N&lt;/code&gt;, so we will have horizontal output as opposed to the vertical output.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Define the 2D array with empty cells (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt;), as well as a separate companion array (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@matrix&lt;/code&gt;) that keeps track of visited cells.&lt;/li&gt;
  &lt;li&gt;Traverse through the input array, keeping track of visited cells in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@matrix&lt;/code&gt;, and filling in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Once &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt; has been filled in, reverse it, and format it into the expected output string.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;I found it interesting that I had to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$number.clone&lt;/code&gt; here, but if I just used &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$number&lt;/code&gt;, all the pairs in the output ended up with the same &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;M&lt;/code&gt; value.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[*;*]&lt;/code&gt; is the way to flatten a 2D array. If it were a 3D array you would use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[*;*;*]&lt;/code&gt; and the pattern continues for more-nested arrays. An interesting quirk of Raku.&lt;/li&gt;
  &lt;li&gt;Normally in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sprintf&lt;/code&gt; we would do something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%2s&lt;/code&gt; to say we want to pad something to two characters. However, since the width is variable, we are able to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%*s&lt;/code&gt; and pass the width in as an argument.&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;visit-cell&lt;/code&gt; subroutine needs to be defined within &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; because it is a &lt;a href=&quot;https://stackoverflow.com/a/7464475/10696164&quot;&gt;closure&lt;/a&gt;, meaning it has access to the variables defined within &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt;, but outside &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;visit-cell&lt;/code&gt;. In this case, it is accessing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@matrix&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-origin-containing-triangle&quot;&gt;Task 2: Origin-containing Triangle&lt;/h2&gt;

&lt;p&gt;You are given three points in the plane, as a list of six coordinates: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A=(x1,y1)&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B=(x2,y2)&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C=(x3,y3)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to find out if the triangle formed by the given three coordinates contain origin &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(0,0)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Print &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; if found otherwise &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example-1-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: A=(0,1), B=(1,0) and C=(2,2)

Output: 0 because that triangle does not contain (0,0).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2-1&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: A=(1,1), B=(-1,1) and C=(0,-3)

Output: 1 because that triangle contains (0,0) in its interior.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-3-1&quot;&gt;Example 3&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: A=(0,1), B=(2,0) and C=(-6,0)

Output: 1 because (0,0) is on the edge connecting B and C.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-101/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Point {
    has Int $.x;
    has Int $.y;

    multi method new($x, $y) { # [1]
        self.bless(:$x, :$y);
    }
}

sub challenge(Point $A, Point $B, Point $C, Point $target = Point.new(0, 0)) returns Int {
    my $area = 0.5 * (-$B.y * $C.x + $A.y * (-$B.x + $C.x) + $A.x * ($B.y - $C.y) + $B.x * $C.y);
    my $s = 1 / (2 * $area) * ($A.y * $C.x - $A.x * $C.y + ($C.y - $A.y) * $target.x + ($A.x - $C.x) * $target.y);
    my $t = 1 / (2 * $area) * ($A.x * $B.y - $A.y * $B.x + ($A.y - $B.y) * $target.x + ($B.x - $A.x) * $target.y);
    (0 &amp;lt;= $s &amp;lt;= 1 &amp;amp;&amp;amp; 0 &amp;lt;= $t &amp;lt;= 1 &amp;amp;&amp;amp; $s + $t &amp;lt;= 1).Int;
}

sub MAIN(Int $x1, Int $y1, Int $x2, Int $y2, Int $x3, Int $y3) {
    say challenge(
        Point.new($x1, $y1),
        Point.new($x2, $y2),
        Point.new($x3, $y3)
    );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 0 1 1 0 2 2
0

$ raku ch-2.raku 1 1 -1 1 0 -3
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This solution is essentially &lt;a href=&quot;https://stackoverflow.com/a/14382692/10696164&quot;&gt;this StackOverflow answer&lt;/a&gt; combined with &lt;a href=&quot;https://stackoverflow.com/a/2049712/10696164&quot;&gt;this StackOverflow answer&lt;/a&gt; with classes instead of individual points. I won’t pretend I understand &lt;a href=&quot;https://en.wikipedia.org/wiki/Barycentric_coordinate_system&quot;&gt;Barycentric coordinates&lt;/a&gt;, but it was easy enough to translate the solution into Raku. We do the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Turn our six integers into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Point&lt;/code&gt; objects, so we can reference them via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$point.x&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$point.y&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Find the area of the triangle defined by the three points.&lt;/li&gt;
  &lt;li&gt;Use the area to find the Barycentric values &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;t&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 &amp;lt;= s &amp;lt;= 1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 &amp;lt;= t &amp;lt;= 1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s + t &amp;lt;= 1&lt;/code&gt;, then the target point (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(0,0)&lt;/code&gt; by default, but can be anything) is in the triangle, otherwise it is not.&lt;/li&gt;
  &lt;li&gt;Cast the above boolean to an integer, because that is what is requested in the challenge.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;p&gt;I think the linked StackOverflow questions do a better job of describing Barycentric coordinates than I can, so I just have one implementation comment.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It’s much easier to deal with this problem with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Point&lt;/code&gt; object. However, defining instances of classes in Raku is quite verbose; by default, it would be like this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Point.new(x =&amp;gt; $x1, y =&amp;gt; $y1)&lt;/code&gt;. We define our own &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new&lt;/code&gt; method that just takes positional arguments and internally calls the named arguments via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bless&lt;/code&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self.bless(:$x, :$y)&lt;/code&gt; is shorthand for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;self.bless(x =&amp;gt; $x, y =&amp;gt; $y)&lt;/code&gt;. In fact, this &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Point&lt;/code&gt; implementation is actually &lt;a href=&quot;https://docs.raku.org/routine/bless&quot;&gt;the example&lt;/a&gt; for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bless&lt;/code&gt; method.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Nothing much to add this week. See y’all next week!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">This week was pretty fun – solution one ends up re-using some code from my first post (Challenge 88), and solution two explores Barycentric coordinates! No ugly one-liners this week. 🙂</summary></entry><entry><title type="html">Perl Weekly Challenge 100</title><link href="http://localhost:4000/blog/perl-weekly-challenge-100/" rel="alternate" type="text/html" title="Perl Weekly Challenge 100" /><published>2021-02-20T00:00:00-06:00</published><updated>2021-02-20T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-100</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-100/">&lt;p&gt;This week was a lot of fun! Challenge 1 threw an additional curve ball at us – the solution should be a “one-liner.” I did my best to fit my solution on one line; the solution itself is 163 characters long.&lt;/p&gt;

&lt;h2 id=&quot;task-1-fun-time&quot;&gt;Task 1: Fun Time&lt;/h2&gt;

&lt;p&gt;You are given a time (12 hour / 24 hour).&lt;/p&gt;

&lt;p&gt;Write a script to convert the given time from a 12-hour format to 24-hour format and vice versa.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Ideally we expect a one-liner.&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 05:15 pm or 05:15pm
Output: 17:15
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 19:15
Output: 07:15 pm or 07:15pm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-100/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Str \t) returns Str {
    t~~/(\d+)\:(\d+)\s?([a|p]m)?/;my (\h,\m,\q)=$/[*];sprintf('%02d:%02d%s',q??h==12??q eq'am'??0!!h!!h+(12*(q eq'pm'))!!h==0|12??12!!h%12,m,q??''!!h&amp;gt;=12??'pm'!!'am');
}

# Implementation comments will go in this version of the above solution
sub challenge-expanded(Str \t) returns Str {
    t ~~ /
      (\d+)     # One or more digits (should technically use \d ** {2}, but this is shorter
      \:        # A literal colon character
      (\d+)     # One or more digits (again, should use \d ** {2})
      \s?       # An optional space (to support HH:MMam or HH:MM am)
      ([a|p]m)? # An optional 'am' or 'pm' (to support both 12- and 24-hour time)
    /;

    my (\h, \m, \q) = $/[*]; # [1][2][3]

	 # The logic in here is the same as above, with added parentheses for clarity
    sprintf(
      '%02d:%02d%s', # [4]
      q ??
        (h == 12 ??
          (q  eq 'am' ?? 0 !! h) !!
          h + (12 * ( q eq 'pm'))) !!
        h == 0|12 ?? 12 !! h % 12,
      m,
      q ?? '' !! (h &amp;gt;= 12 ?? 'pm' !! 'am')
    );
}

sub MAIN(Str $time) {
    say challenge($time);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 05:15 pm
17:15

$ raku ch-1.raku 19:15
7:15pm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This one is ugly, so I apologize in advance! When I hear “one-liner” I immediately think &lt;a href=&quot;https://en.wikipedia.org/wiki/Code_golf&quot;&gt;“code golf”&lt;/a&gt;. I used every trick I know to make my solution as short as possible while handling all the edge cases (it’s pretty easy to handle the given test cases, but the boundaries make things tricky. I tested every possible time in my full solution on GitHub). You’ll notice I &lt;em&gt;heavily&lt;/em&gt; lean on the ternary operator for all my branching logic.&lt;/p&gt;

&lt;p&gt;For what it’s worth, this still has some flaws (for example, it will accept the time &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;99:99am&lt;/code&gt;), but it accepts &lt;strong&gt;all&lt;/strong&gt; valid input, so that is good enough for me.&lt;/p&gt;

&lt;p&gt;First, we look for a string matching the regex provided (see embedded comment on what we are looking for). From this regex, we extract 3 elements: the hour, the minute, and the qualifier (am/pm) if it exists. Once we have those 3 elements, we pass them to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sprintf&lt;/code&gt; function for all the logic.&lt;/p&gt;

&lt;p&gt;For the hour, we follow the following logic:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Is there a qualifier?
    &lt;ul&gt;
      &lt;li&gt;If yes:
        &lt;ul&gt;
          &lt;li&gt;Is the hour equal to 12?
            &lt;ul&gt;
              &lt;li&gt;If yes:
                &lt;ul&gt;
                  &lt;li&gt;Is the qualifier equal to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;am&lt;/code&gt;?
                    &lt;ul&gt;
                      &lt;li&gt;If yes: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hour = 12&lt;/code&gt;&lt;/li&gt;
                      &lt;li&gt;If no: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hour&lt;/code&gt; is left alone&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
              &lt;li&gt;If no:
                &lt;ul&gt;
                  &lt;li&gt;Is the qualifier equal to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pm&lt;/code&gt;?
                    &lt;ul&gt;
                      &lt;li&gt;If yes: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hour = 12 + hour&lt;/code&gt;&lt;/li&gt;
                      &lt;li&gt;If no: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hour&lt;/code&gt; is left alone&lt;/li&gt;
                    &lt;/ul&gt;
                  &lt;/li&gt;
                &lt;/ul&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;If no:
        &lt;ul&gt;
          &lt;li&gt;Is the hour equal to 0 or 12?
            &lt;ul&gt;
              &lt;li&gt;If yes: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hour = 12&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;If no: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hour = hour % 12&lt;/code&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Minute will always be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0-59&lt;/code&gt;, so we leave it alone.&lt;/p&gt;

&lt;p&gt;For the qualifier, we follow the following logic:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Is there a qualifier?
    &lt;ul&gt;
      &lt;li&gt;If yes, we are converting to a 24-hour format, so the new qualifier is empty&lt;/li&gt;
      &lt;li&gt;If no:
        &lt;ul&gt;
          &lt;li&gt;Is the hour greater than or equal to 12?
            &lt;ul&gt;
              &lt;li&gt;If yes: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;qualifier = 'pm'&lt;/code&gt;&lt;/li&gt;
              &lt;li&gt;If no: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;qualifier = 'am'&lt;/code&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Finally, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sprintf&lt;/code&gt; handles all the formatting (discussed below).&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Everywhere where I used a variable, you’ll notice I use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\variable-name&lt;/code&gt;. In Raku, there are several &lt;a href=&quot;https://docs.raku.org/language/variables#Sigils&quot;&gt;sigils&lt;/a&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt; for scalars, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@&lt;/code&gt; for positionals, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%&lt;/code&gt; for associatives, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; for functions. There is also the special &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\&lt;/code&gt; sigil for &lt;a href=&quot;https://docs.raku.org/type/Scalar#index-entry-%5c_(sigilless_scalar)&quot;&gt;sigilless scalars&lt;/a&gt;. Basically, if a variable is defined as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;\variable-name&lt;/code&gt;, we are able to reference it as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;variable-name&lt;/code&gt;. This saved me 11 characters, by my count.&lt;/li&gt;
  &lt;li&gt;A match object (returned by the smartmatch operator [&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~~&lt;/code&gt;]) creates a variable names &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$/&lt;/code&gt;, so that is where that came from. I could just have easily said &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;my $match = t ~~ &amp;lt;the rest&amp;gt;&lt;/code&gt;, but that would cost my characters.&lt;/li&gt;
  &lt;li&gt;We used &lt;a href=&quot;https://docs.raku.org/language/regexes#Capturing&quot;&gt;regex capturing&lt;/a&gt; to pull out the hour, minute, and qualifier. Those end up in the match object (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$/&lt;/code&gt;) as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hour = $/[0]&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;minute = $/[1]&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;qualifier = $/[2]&lt;/code&gt;. We are able to extract &lt;em&gt;all 3&lt;/em&gt; elements by using the special &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; index to reference &lt;em&gt;all&lt;/em&gt; elements in the array.&lt;/li&gt;
  &lt;li&gt;Raku’s &lt;a href=&quot;https://docs.raku.org/routine/sprintf&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sprintf&lt;/code&gt; function&lt;/a&gt; is similar to Unix’s. It takes a formatting string (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'%02d:%02d%s'&lt;/code&gt;) that describes the output. In this case, we say we want a 2-digit number, then a colon, then another 2-digit number, then a string. Those three elements are filled in with arguments 2-4 (hour, minute, qualifier).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-triangle-sum&quot;&gt;Task 2: Triangle Sum&lt;/h2&gt;

&lt;p&gt;You are given triangle array.&lt;/p&gt;

&lt;p&gt;Write a script to find the minimum path sum from top to bottom.&lt;/p&gt;

&lt;p&gt;When you are on index &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt; on the current row then you may move to either index &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt; or index &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i + 1&lt;/code&gt; on the next row.&lt;/p&gt;

&lt;h3 id=&quot;example-1-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: Triangle = [ [1], [2,4], [6,4,9], [5,1,7,2] ]
Output: 8

Explanation: The given triangle

            1
           2 4
          6 4 9
         5 1 7 2

The minimum path sum from top to bottom:  1 + 2 + 4 + 1 = 8

             [1]
           [2]  4
           6 [4] 9
          5 [1] 7 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2-1&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: Triangle = [ [3], [3,1], [5,2,3], [4,3,1,3] ]
Output: 7

Explanation: The given triangle

            3
           3 1
          5 2 3
         4 3 1 3

The minimum path sum from top to bottom: 3 + 1 + 2 + 1 = 7

             [3]
            3  [1]
           5 [2] 3
          4 3 [1] 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-100/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@triangle) {
    my @layers = (0..@triangle.end); # [1]
    my @indices = gather {           # [2]
        for @triangle -&amp;gt; @layer {
            take (0..@layer.end).List;
        }
    }
    my @paths = gather {
        for ([X] @indices) -&amp;gt; @path {         # [3]
            my @zipped = @path Z @path[1..*]; # [4]
            my $valid = True;
            for @zipped -&amp;gt; ($a, $b) {
                if $b &amp;lt; $a || $b &amp;gt; $a + 1 {
                    $valid = False;
                    last;
                }
            }
            take @path if $valid;             # [5]
        }
    }
    my @sums = gather {
        my $sum = 0;
        for @paths -&amp;gt; @path {
            for @layers Z @path -&amp;gt; ($layer, $index) {
                $sum += @triangle[$layer][$index];
            }
            take $sum;
            $sum = 0;
        }
    }
    @sums.min;
}

sub MAIN(*@N where all(@N) ~~ Int) {
	 # Some extra logic to turn a list into a triangle
    my ($index, $size) = (0, 1);
    my @triangle;
    while $index &amp;lt;= @N.end {
        my $end-index = $index + $size;

        my @layer = @N[$index..^$end-index];
        @triangle.push(@layer);

        $index = $end-index;
        $size++;
    }
    say challenge(@triangle);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 1 2 4 6 4 9 5 1 7 2
8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The logic here is pretty straightforward:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Find how many layers to the triangle there are&lt;/li&gt;
  &lt;li&gt;Find the valid indices of each layer. So, for example 1, this would be something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;((0), (0, 1), (0, 1, 2), (0, 1, 2, 3))&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Find all valid paths. “Valid” in this case means that we always move from position &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt; to position &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i+1&lt;/code&gt; on the next layer.&lt;/li&gt;
  &lt;li&gt;Find the sum of each valid path.&lt;/li&gt;
  &lt;li&gt;Return the minimum sum out of the valid paths.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Raku has a great method for positionals called &lt;a href=&quot;https://docs.raku.org/routine/end&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;end&lt;/code&gt;&lt;/a&gt;. It returns the last index in a list and saves us from confusion (similar to something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;len(list) - 1&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/syntax/gather%20take&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gather&lt;/code&gt;&lt;/a&gt; is a way to build up a list based on some logic. It can be thought of as a more powerful list comprehension (from Python).&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/X&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X&lt;/code&gt;&lt;/a&gt; is the cross product operator. When used like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[X] @list&lt;/code&gt;, it works like this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[X] ((1, 2, 3), (4, 5, 6), (7, 8, 9)) == (1, 2, 3) X (4, 5, 6) X (7, 8, 9)&lt;/code&gt;. In this case, it creates all possible paths through the triangle (which we filter down to valid paths).&lt;/li&gt;
  &lt;li&gt;To make sure we only move from position &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt; to position &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i+1&lt;/code&gt; from layer to layer, we “zip” against our path from position &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i+1&lt;/code&gt; to the end.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;if&lt;/code&gt; can be used in a postfix form to save space. In this case, we only want to take a path if it is valid (as defined above).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I had a lot of fun with this week’s challenges, especially challenge 1! Let me know if you think of a shorter solution. Otherwise, see y’all next week!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">This week was a lot of fun! Challenge 1 threw an additional curve ball at us – the solution should be a “one-liner.” I did my best to fit my solution on one line; the solution itself is 163 characters long.</summary></entry><entry><title type="html">Perl Weekly Challenge 99</title><link href="http://localhost:4000/blog/perl-weekly-challenge-099/" rel="alternate" type="text/html" title="Perl Weekly Challenge 99" /><published>2021-02-13T00:00:00-06:00</published><updated>2021-02-13T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-099</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-099/">&lt;p&gt;This week’s theme is &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;&lt;em&gt;regex&lt;/em&gt;&lt;/a&gt;, which is something the Perl family of languages has always been known for.&lt;/p&gt;

&lt;h2 id=&quot;task-1-pattern-match&quot;&gt;Task 1: Pattern Match&lt;/h2&gt;

&lt;p&gt;You are given a string &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; and a pattern &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$P&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to check if the given pattern matches the entire string. Print &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; if so, otherwise &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The patterns can also have the following characters:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt; - Match any single character.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; - Match any sequence of characters.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S = &quot;abcde&quot; $P = &quot;a*e&quot;
Output: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S = &quot;abcde&quot; $P = &quot;a*d&quot;
Output: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-3&quot;&gt;Example 3&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S = &quot;abcde&quot; $P = &quot;?b*d&quot;
Output: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-4&quot;&gt;Example 4&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S = &quot;abcde&quot; $P = &quot;a*c?e&quot;
Output: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Str $S, Str $P) returns Int {
    my $regex = '^' ~ $P.trans(['*', '?'] =&amp;gt; ['.*', '.']) ~ '$'; # [1][2][3]
    ($S ~~ /&amp;lt;$regex&amp;gt;/).Bool.Int;                                 # [4][5]
}

sub MAIN(Str $S, Str $P) {
    say challenge($S, $P);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku abcde a*e
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This one is pretty simple – we essentially just translate our pattern characters to their regex counterparts (see table below), then check if it matches &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt;. If so, we return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;, otherwise &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Pattern Character&lt;/th&gt;
      &lt;th&gt;Regex Counterpart&lt;/th&gt;
      &lt;th&gt;Meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Any single character&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.*&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Any single character &lt;em&gt;zero or more times&lt;/em&gt; (the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; means “zero or more” in regex)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;The question says the pattern has to match the entire string, so we add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;^&lt;/code&gt; (which means “start of string”) and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt; (which means “end of string”) to the pattern.&lt;/li&gt;
  &lt;li&gt;The &lt;a href=&quot;https://docs.raku.org/routine/trans&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trans&lt;/code&gt;&lt;/a&gt; method can take either two strings or two lists. If we provide two strings, they must be of the same length. Since one of our characters maps to &lt;em&gt;two&lt;/em&gt; regex characters (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.*&lt;/code&gt;), we have to use the list style.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~&lt;/code&gt; is the Raku &lt;a href=&quot;https://docs.raku.org/routine/~&quot;&gt;concatenate operator&lt;/a&gt; so that we create just one string.&lt;/li&gt;
  &lt;li&gt;To reference a regex stored in a variable, we have to use the &lt;a href=&quot;https://docs.raku.org/language/regexes#Regex_interpolation&quot;&gt;bracket notation&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;The &lt;a href=&quot;https://docs.raku.org/routine/~~&quot;&gt;smart match operator&lt;/a&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~~&lt;/code&gt;) returns a &lt;a href=&quot;https://docs.raku.org/type/Match&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Match&lt;/code&gt;&lt;/a&gt; object, which we cast to a boolean (to see &lt;em&gt;if&lt;/em&gt; it matched) and then an integer (a boolean will cast to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; if false, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; if true).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-unique-subsequence&quot;&gt;Task 2: Unique Subsequence&lt;/h2&gt;

&lt;p&gt;You are given two strings &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$T&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to find out count of different unique subsequences matching &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$T&lt;/code&gt; without changing the position of characters.&lt;/p&gt;

&lt;h3 id=&quot;example-1-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S = &quot;littleit', $T = 'lit'
Output: 5

    1: [lit] tleit
    2: [li] t [t] leit
    3: [li] ttlei [t]
    4: litt [l] e [it]
    5: [l] ittle [it]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2-1&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S = &quot;london', $T = 'lon'
Output: 3

    1: [lon] don
    2: [lo] ndo [n]
    3: [l] ond [on]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-099/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Str $S, Str $T) returns Int {
    my $regex = $T.comb.join('.*');     # [1]
    ($S ~~ m:exhaustive/&amp;lt;$regex&amp;gt;/).Int; # [2][3]
}

sub MAIN(Str $S, Str $T) {
    say challenge($S, $T);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku littleit lit
5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;We basically take our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$T&lt;/code&gt; and convert it to a regex that looks like this: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;l.*i.*t&lt;/code&gt;. Which, as we know from Task 1, means that we want to match the word &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lit&lt;/code&gt; with &lt;em&gt;zero or more characters&lt;/em&gt; between each letter. We then do an exhaustive match against &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; and count the number of matches.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comb&lt;/code&gt; converts the string to a list of characters (i.e. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;'foo'&lt;/code&gt; -&amp;gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;['f', 'o', 'o']&lt;/code&gt;), which we then join together with our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.*&lt;/code&gt; regex.&lt;/li&gt;
  &lt;li&gt;We supply the &lt;a href=&quot;https://docs.raku.org/language/regexes#Adverbs&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exhaustive&lt;/code&gt; adverb&lt;/a&gt; (we have to say this is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;match&lt;/code&gt; adverb with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m&lt;/code&gt;, or else it would think it is a &lt;em&gt;regex&lt;/em&gt; adverb), which tells the regex to keep going after the first match and find an exhaustive list of matches.&lt;/li&gt;
  &lt;li&gt;Calling &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.Int&lt;/code&gt; on a match object directly will return the number of matches it found.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Perl has always been the king of regex, which is why it got (and continues to stay) so popular. Raku continues that legacy and made these problems relatively simple.&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">This week’s theme is regex, which is something the Perl family of languages has always been known for.</summary></entry><entry><title type="html">Perl Weekly Challenge 98</title><link href="http://localhost:4000/blog/perl-weekly-challenge-098/" rel="alternate" type="text/html" title="Perl Weekly Challenge 98" /><published>2021-02-06T00:00:00-06:00</published><updated>2021-02-06T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-098</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-098/">&lt;p&gt;This week’s solutions explore some more obscure parts of the Raku ecosystem, namely &lt;a href=&quot;https://docs.raku.org/syntax/state&quot;&gt;state variables&lt;/a&gt; and &lt;a href=&quot;https://docs.raku.org/language/glossary#index-entry-Adverb&quot;&gt;adverbs&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;task-1-read-n-characters&quot;&gt;Task 1: Read N-characters&lt;/h2&gt;

&lt;p&gt;You are given file &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$FILE&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Create subroutine &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readN($FILE, $number)&lt;/code&gt; that returns the first n-characters and moves the pointer to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(n+1)th&lt;/code&gt; character.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: Suppose the file (input.txt) contains &quot;1234567890&quot;
Output:
    print readN(&quot;input.txt&quot;, 4); # returns &quot;1234&quot;
    print readN(&quot;input.txt&quot;, 4); # returns &quot;5678&quot;
    print readN(&quot;input.txt&quot;, 4); # returns &quot;90&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-098/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub readN(Str $file-name, Int $chars-to-read where $chars-to-read &amp;gt; 0) returns Str {
    state %file-map;                                          # [1]

    if %file-map{$file-name}:!exists {                        # [2]
        %file-map{$file-name} = IO::CatHandle.new($file-name) # [3]
    }

    %file-map{$file-name}.readchars($chars-to-read);          # [4]
}

sub MAIN(Str $FILE, Int $N) {
    say readN($FILE, $N);
    say readN($FILE, $N);
    say readN($FILE, $N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Assuming input.txt contains '1234567890'
$ raku ch-1.raku input.txt 4
1234
5678
90
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;All of this relies on two very cool aspects of Raku: &lt;a href=&quot;https://docs.raku.org/syntax/state&quot;&gt;state variables&lt;/a&gt; and &lt;a href=&quot;https://docs.raku.org/type/IO::CatHandle&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CatHandles&lt;/code&gt;&lt;/a&gt;, which I will detail below. Basically, we just create a new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CatHandle&lt;/code&gt; and pass all the heavy lifting to it via &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readchars&lt;/code&gt;; it keeps track of where it is in the file and will not attempt to read past the end of the file.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;A state variable in Raku is similar to a static variable in other languages, with the additional caveat that it can be instantiated in subroutines in addition to classes. This variable will be instantiated once and shared across all invocations of the subroutine. So, if we wanted to, we could do the following:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# input1.txt
# maryalamb

# input2.txt
# hadlittle

sub MAIN {
  my $input1 = 'input1.txt';
  my $input2 = 'input2.txt';
  
  say readN($input1, 4);
  say readN($input2, 3);
  say readN($input1, 1);
  say readN($input2, 6);
  say readN($input1, 4);
}

# Output:
# mary
# had
# a
# little
# lamb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;This is a special case of the &lt;a href=&quot;https://docs.raku.org/type/Hash#:exists&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exists&lt;/code&gt;&lt;/a&gt; adverb. Adverbs are just named arguments. In this case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:exists&lt;/code&gt; is essentially the pair &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exists =&amp;gt; True&lt;/code&gt;, so to negate it we use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!:exists&lt;/code&gt;. I found this pretty interesting, because I thought it would have been &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!%file-map{$file-name}:exists&lt;/code&gt;, but Raku complains about that.&lt;/li&gt;
  &lt;li&gt;A &lt;a href=&quot;https://docs.raku.org/type/IO::CatHandle&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CatHandle&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;normally&lt;/em&gt; used to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cat&lt;/code&gt; together several file handles and read them all at once. In this case, we are using it to take advantage of its &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readchars&lt;/code&gt; function discussed below.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/type/IO::CatHandle#method_readchars&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;readchars&lt;/code&gt;&lt;/a&gt; essentially just tracks our offset in the given handle and always outputs the next &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;n&lt;/code&gt; characters that we request, and just returns an empty string if we are at the end of the file. Super convenient for this challenge!&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-search-insert-position&quot;&gt;Task 2: Search Insert Position&lt;/h2&gt;

&lt;p&gt;You are given a sorted array of distinct integers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt; and a target &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to return the index of the given target if found otherwise place the target in the sorted array and return the index.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @N = (1, 2, 3, 4) and $N = 3
Output: 2 since the target 3 is in the array at the index 2.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @N = (1, 3, 5, 7) and $N = 6
Output: 3 since the target 6 is missing and should be placed at the index 3.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-3&quot;&gt;Example 3&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @N = (12, 14, 16, 18) and $N = 10
Output: 0 since the target 10 is missing and should be placed at the index 0.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-4&quot;&gt;Example 4&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: @N = (11, 13, 15, 17) and $N = 19
Output: 4 since the target 19 is missing and should be placed at the index 4.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-098/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(@N is copy, Int $N) returns Int { # [1]
    my @new = $N ∉ @N ?? (|@N, $N).sort !! @N;  # [2]
    @new.first($N, :k);                         # [3]
}

sub MAIN(Int $N, *@N where all(@N) ~~ Int) {
    say challenge(@N, $N)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# $N followed by @N
$ raku ch-2.raku 3 1 2 3 4 
2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This is pretty straight forward; we check if &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; is in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt; (if not, we add it and re-sort), then return the index of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;. That’s it!&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;In Raku, the sigil (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%&lt;/code&gt;, etc.) is &lt;em&gt;part of&lt;/em&gt; the variable declaration. Because of that, for better or for worse, it is not a problem (as far as the compiler is concerned) that we have to variables named &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Rather than mark &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt; as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is copy&lt;/code&gt; so we could use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N.push($N).sort&lt;/code&gt;, since we assign it to a new variable anyway (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@new&lt;/code&gt;), we can use a &lt;a href=&quot;https://docs.raku.org/type/Slip&quot;&gt;slip&lt;/a&gt; to append &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first&lt;/code&gt; returns the first instance of the argument in the list (in this case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;). We supply the &lt;a href=&quot;https://docs.raku.org/routine/first#class_List&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:k&lt;/code&gt; adverb&lt;/a&gt; to have it return the &lt;em&gt;index&lt;/em&gt; of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; rather than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; itself.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Raku has a lot of cool stuff built in to it. I find the hardest part of navigating this language is the documentation. Things are &lt;em&gt;mostly&lt;/em&gt; well documented, but things like Stack Overflow posts and how-tos can be few and far between. Hopefully this blog is helpful for anyone trying to learn the language!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">This week’s solutions explore some more obscure parts of the Raku ecosystem, namely state variables and adverbs.</summary></entry><entry><title type="html">Perl Weekly Challenge 97</title><link href="http://localhost:4000/blog/perl-weekly-challenge-097/" rel="alternate" type="text/html" title="Perl Weekly Challenge 97" /><published>2021-01-30T00:00:00-06:00</published><updated>2021-01-30T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-097</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-097/">&lt;p&gt;My solution to challenge two builds on last week’s challenge two, so I encourage you to go read &lt;a href=&quot;https://aaronreidsmith.github.io/blog/perl-weekly-challenge-096/&quot;&gt;last week’s post&lt;/a&gt; if you haven’t already!&lt;/p&gt;

&lt;h2 id=&quot;task-1-caesar-cipher&quot;&gt;Task 1: Caesar Cipher&lt;/h2&gt;

&lt;p&gt;You are given string &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; containing alphabets &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A..Z&lt;/code&gt; only and a number &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to encrypt the given string &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; using a &lt;a href=&quot;https://en.wikipedia.org/wiki/Caesar_cipher&quot;&gt;Caesar Cipher&lt;/a&gt; with left shift of size &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S = &quot;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&quot;, $N = 3
Output: &quot;QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD&quot;

Plain:  ABCDEFGHIJKLMNOPQRSTUVWXYZ
Cipher: XYZABCDEFGHIJKLMNOPQRSTUVW

Plaintext:  THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG
Ciphertext: QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-097/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;constant @alphabet = ('A'..'Z').List; # [1]

sub challenge(
    Str $S where $S ~~ /^[&amp;lt;alpha&amp;gt;|&amp;lt;space&amp;gt;]+$/, # [2]
    Int $N where $N &amp;gt;= 0
) {
    $S.uc.trans(@alphabet =&amp;gt; @alphabet.rotate(-$N)); # [3][4]
}

sub MAIN(Str $S, Int $N) {
    say challenge($S, $N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 'THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG' 3
QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;We use some cool built-in functionality to make this so simple. Here is the logic:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Make sure the string is uppercase (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.uc&lt;/code&gt;). They say we will always get uppercase, but might as well validate.&lt;/li&gt;
  &lt;li&gt;For each letter in the string, translate it to a different version of the alphabet that is rotated by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; spaces.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;That’s it!&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Since the alphabet is always going to be constant we can instantiate it at the top level as a &lt;a href=&quot;https://docs.raku.org/language/terms#Constants&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;constant&lt;/code&gt;&lt;/a&gt;. Constants are evaluated at compile time, so this speeds up the program (even if just marginally).&lt;/li&gt;
  &lt;li&gt;You have likely seen me use this syntax before; these are called anonymous type constraints, and allow us to be a little more specific than just &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Str&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Int&lt;/code&gt;. In this case, we want a string that only contains letters and spaces, and an int that is greater than or equal to zero.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/trans&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trans&lt;/code&gt;&lt;/a&gt; is a cool subroutine; it takes two lists (or strings) defining replacements to be made in the supplied string. Given the example above, it is the equivalent of something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S.subst('a', 'x').subst('b', 'y')...&lt;/code&gt;. The left argument, in our case, will always be the alphabet, and the right argument is the alphabet rotated by &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt; spaces.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/rotate&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rotate&lt;/code&gt;&lt;/a&gt; takes a list and rotates it to the left. Since we need our letters shifted to the right, we use a negative number (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-$N&lt;/code&gt;).&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-binary-substrings&quot;&gt;Task 2: Binary Substrings&lt;/h2&gt;

&lt;p&gt;You are given a binary string &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$B&lt;/code&gt; and an integer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to split the binary string &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$B&lt;/code&gt; of size &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; and then find the minimum number of flips required to make it all the same.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $B = “101100101”, $S = 3
Output: 1

Binary Substrings:
  &quot;101&quot;: 0 flip
  &quot;100&quot;: 1 flip to make it &quot;101&quot;
  &quot;101&quot;: 0 flip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input $B = “10110111”, $S = 4
Output: 2

Binary Substrings:
  &quot;1011&quot;: 0 flip
  &quot;0111&quot;: 2 flips to make it &quot;1011&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-097/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use Text::Levenshtein; # imports `distance`

sub challenge(
    Str $B where $B ~~ /^[0|1]+$/,
    Int $S where $S &amp;gt; 0
) {
    my @segments = $B.comb.rotor($S, :partial).map(-&amp;gt; @chars { # [1]
        my $segment = @chars.join;
        $segment ~ '0' x ($S - $segment.chars) # [2][3]
    });
    distance(|@segments).sum; # [4]
}

multi sub MAIN(Str $B, Int $S) {
    say challenge($B, $S);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku 101100101 3
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;The number of flips seems oddly similar to the edit distance from last week, no? I was able to reuse &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text::Levenshtein.distance&lt;/code&gt; from last week to find the “edit distance” between binary strings! We do a little work to split the string into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; pieces (padding with zeros, if necessary), then leave all the heaving lifting to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distance&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/rotor&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rotor&lt;/code&gt;&lt;/a&gt; splits a list into pieces based on the argument (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; in this case). We pass it the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:partial&lt;/code&gt; flag so that it keeps any pieces that are less than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt; in size (rather than throwing them away).&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/~&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;~&lt;/code&gt;&lt;/a&gt; is Raku’s string concatenation subroutine.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.raku.org/routine/x&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x&lt;/code&gt;&lt;/a&gt; is Raku’s string repetition operator. I couldn’t an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rpad&lt;/code&gt; method in Raku, so this is my workaround.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distance&lt;/code&gt; does not take a single list of arguments, it takes a variable amount of top-level arguments. To achieve that behavior, we use a &lt;a href=&quot;https://docs.raku.org/routine/%7C&quot;&gt;slip (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt;)&lt;/a&gt; to unpack the list we built.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;As I was writing this blog I realized it may have been better for me to left pad the binary strings in challenge two; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1001 != 100100&lt;/code&gt; but &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1001 == 001001&lt;/code&gt;. Oh well, the question doesn’t talk about the “partial” case anyway!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">My solution to challenge two builds on last week’s challenge two, so I encourage you to go read last week’s post if you haven’t already!</summary></entry><entry><title type="html">Perl Weekly Challenge 96</title><link href="http://localhost:4000/blog/perl-weekly-challenge-096/" rel="alternate" type="text/html" title="Perl Weekly Challenge 96" /><published>2021-01-22T00:00:00-06:00</published><updated>2021-01-22T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-096</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-096/">&lt;p&gt;I admittedly took a shortcut for part two this week, but it allowed me to introduce modules here (I don’t &lt;em&gt;believe&lt;/em&gt; I have used them before in a blog), so I think it makes up for it. 🙂&lt;/p&gt;

&lt;h2 id=&quot;task-1-reverse-words&quot;&gt;Task 1: Reverse Words&lt;/h2&gt;

&lt;p&gt;You are given a string &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to reverse the order of words in the given string. The string may contain leading/trailing spaces. The string may have more than one space between words in the string. Print the result without leading/trailing spaces and there should be only one space between words.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S = &quot;The Weekly Challenge&quot;
Output: &quot;Challenge Weekly The&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S = &quot;    Perl and   Raku are  part of the same family  &quot;
Output: &quot;family same the of part are Raku and Perl&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-096/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Str $S) returns Str {
    $S.trim.words.reverse.join(' ');
}

sub MAIN(Str $S) {
    say challenge($S);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 'The Weekly Challenge'
Challenge Weekly The
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Pretty easy one-liner here. Here is the logic:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Take the string and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;trim&lt;/code&gt; whitespace off of the beginning and the end.&lt;/li&gt;
  &lt;li&gt;Split it into individual words using the handy &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;words&lt;/code&gt; method (the equivalent of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;split(/&amp;lt;space&amp;gt;+/)&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Reverse the list generated from Step 2&lt;/li&gt;
  &lt;li&gt;Re-join the list into a space-separated string using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.join(' ')&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-edit-distance&quot;&gt;Task 2: Edit Distance&lt;/h2&gt;

&lt;p&gt;You are given two strings &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S1&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S2&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to find out the minimum operations required to convert &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S1&lt;/code&gt; into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$S2&lt;/code&gt;. The operations can be “insert,” “remove,” or “replace” a character. Check out &lt;a href=&quot;https://en.wikipedia.org/wiki/Edit_distance&quot;&gt;Wikipedia page&lt;/a&gt; for more information.&lt;/p&gt;

&lt;h3 id=&quot;example-1-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S1 = &quot;kitten&quot;; $S2 = &quot;sitting&quot;
Output: 3

Explanation:
Operation 1: replace 'k' with 's'
Operation 2: replace 'e' with 'i'
Operation 3: insert 'g' at the end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2-1&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: $S1 = &quot;sunday&quot;; $S2 = &quot;monday&quot;
Output: 2

Explanation:
Operation 1: replace 's' with 'm'
Operation 2: replace 'u' with 'o'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-096/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;use Text::Levenshtein; # imports `distance` # [1]

sub challenge(Str $S1, Str $S2) returns Int {
    distance($S1.lc, $S2.lc).head; # [2][3]
}

sub MAIN(Str $S1, Str $S2) {
    say challenge($S1, $S2);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-2.raku kitten sitting
3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;This was definitely a cop-out. Edit distance is also known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Levenshtein_distance&quot;&gt;&lt;em&gt;Levenshtein Distance&lt;/em&gt;&lt;/a&gt;; when an algorithm has someone’s name attached to it, it is usually better to find an existing implementation. 😅 With that being said, if anyone &lt;em&gt;is&lt;/em&gt; interested in the Raku implementation of the algorithm, &lt;a href=&quot;https://github.com/thundergnat/Text-Levenshtein/blob/master/lib/Text/Levenshtein.pm6#L3-L28&quot;&gt;here is the source code for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text::Levenshtein&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In case it is not obvious, we simply pass the input strings to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distance&lt;/code&gt; and let it do the work.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;I encourage anyone reading this to read the &lt;a href=&quot;https://docs.raku.org/language/modules&quot;&gt;Raku documentation on modules&lt;/a&gt;. Basically, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;use&lt;/code&gt; is one of several keywords to import modules, and is probably the most common you will see in the wild. You can import specific elements, if the author allows it, or you can write it as we did here and get the default imports.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distance&lt;/code&gt; will treat uppercase and lowercase letters differently, which I did not want, so we explicitly cast everything to lowercase (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.lc&lt;/code&gt;) before passing them to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distance&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;distance&lt;/code&gt; will accept a variable number of arguments and compare the 2nd to Nth arguments to the first one, returning an array of Levenshtein distances. Since we only have two arguments, we need to extract the first (and only) distance in the array using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;head&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;In my day-to-day I always encourage folks to use modules where possible. In puzzles like these, I usually prefer to write my own implementation, even if it is less efficient. But it was a long week, so I took the lazy way out. 😉 See y’all next week!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">I admittedly took a shortcut for part two this week, but it allowed me to introduce modules here (I don’t believe I have used them before in a blog), so I think it makes up for it. 🙂</summary></entry><entry><title type="html">Perl Weekly Challenge 95</title><link href="http://localhost:4000/blog/perl-weekly-chellanege-095/" rel="alternate" type="text/html" title="Perl Weekly Challenge 95" /><published>2021-01-16T00:00:00-06:00</published><updated>2021-01-16T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-chellanege-095</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-chellanege-095/">&lt;p&gt;Two pretty simple challenges this week! I tried ot focus on strongly typed subroutines and methods to shake things up.&lt;/p&gt;

&lt;h2 id=&quot;task-1-palindrome-number&quot;&gt;Task 1: Palindrome Number&lt;/h2&gt;

&lt;p&gt;You are given a number &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to figure out if the given number is a palindrome. Print &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; if true otherwise &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 1221
Output: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: -101
Output: 0 (since -101 and 101- are not the same)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-3&quot;&gt;Example 3&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input: 90
Output: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-095/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sub challenge(Int $N) {
    ($N.Str.flip eq $N.Str).Int; # [1]
}

sub MAIN(Int $N) {
    say challenge($N);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ raku ch-1.raku 1221
1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;Pretty simple solution here. THe &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;challenge&lt;/code&gt; subroutine takes the input, casts it to a string, reverses it and compares it to the input argument (returning a boolean). Finally, it casts that boolean to a number to match the challenges output.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Casting to a string allows us to account for any negative sign easily.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-demo-stack&quot;&gt;Task 2: Demo Stack&lt;/h2&gt;

&lt;p&gt;Write a script to demonstrate stack operations like below:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;push($n)&lt;/code&gt; - add &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$n&lt;/code&gt; to the stack&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop()&lt;/code&gt; - remove the top element&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;top()&lt;/code&gt; - get the top element&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;min()&lt;/code&gt; - return the minimum element&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;example&quot;&gt;Example&lt;/h3&gt;

&lt;p&gt;Note: This is shown with Perl 5 syntax.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my $stack = Stack-&amp;gt;new;
$stack-&amp;gt;push(2);
$stack-&amp;gt;push(-1);
$stack-&amp;gt;push(0);
$stack-&amp;gt;pop;       # removes 0
print $stack-&amp;gt;top; # prints -1
$stack-&amp;gt;push(0);
print $stack-&amp;gt;min; # prints -1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-095/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any implementation-specific comments.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Stack {
    has @!internal-state of Int;

    method push(Int $elem --&amp;gt; True) {
        @!internal-state.push($elem);
    }

    method pop() returns Int {
        if @!internal-state.elems == 0 {
            warn &quot;Cannot pop an empty stack!&quot;;
        } else {
            @!internal-state.pop;
        }
    }

    method top returns Int {
        if @!internal-state.elems == 0 {
            warn &quot;Cannot find top of empty stack!&quot;;
        } else {
            @!internal-state.tail;
        }
    }

    method min returns Int {
        if @!internal-state.elems == 0 {
            warn &quot;Cannot find minimum of empty stack!&quot;;
        } else {
            @!internal-state.min;
        }
    }

    method Str returns Str {
        &quot;({@!internal-state.join(', ')}) &amp;lt;-- Top&quot;;
    }
}

sub MAIN(*@push where all(@push) ~~ Int, Int :$pop = 2) {
     # Can't put a default on &quot;slurpy&quot; args, so this is our work around
    @push = @push.elems &amp;gt; 0 ?? @push !! (1, 2, 3, 4);

    my $stack = Stack.new;
    for @push -&amp;gt; $elem {
        $stack.push($elem);
    }
    say &quot;     Stack after pushing: $stack&quot;;
    for ^$pop {
        $stack.pop();
    }
    say &quot;     Stack after popping: $stack&quot;;
    say &quot;    Top element of stack: {$stack.top}&quot;;
    say &quot;Minimum element of stack: {$stack.min}&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# All default
$ raku ch-2.raku 
     Stack after pushing: (1, 2, 3, 4) &amp;lt;-- Top
     Stack after popping: (1, 2) &amp;lt;-- Top
    Top element of stack: 2
Minimum element of stack: 1

# Override pop default
$ raku ch-2.raku --pop=1
     Stack after pushing: (1, 2, 3, 4) &amp;lt;-- Top
     Stack after popping: (1, 2, 3) &amp;lt;-- Top
    Top element of stack: 3
Minimum element of stack: 1

# Override pop and push defaults
$ raku ch-2.raku --pop=1 1 2 3
     Stack after pushing: (1, 2, 3) &amp;lt;-- Top
     Stack after popping: (1, 2) &amp;lt;-- Top
    Top element of stack: 2
Minimum element of stack: 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;A stack is a last in, first out (LIFO) structure, where we can only interact with the top. You can think of it like a stack of plates; it’s not easy to grab the middle plate from the stack!&lt;/p&gt;

&lt;p&gt;In this case, we decided to make the stack homogenous (i.e., it can only hold integers). A Raku &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; already has a stack-like interface, so we basically just wrap that and add some warnings.&lt;/p&gt;

&lt;p&gt;We simply define a class with a private &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array&lt;/code&gt; of integers such that the user can only interact with it via the methods described in the challenge. Then, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; subroutine simply demos those methods.&lt;/p&gt;

&lt;h4 id=&quot;specific-comments-1&quot;&gt;Specific Comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Raku classes have something called &lt;a href=&quot;https://docs.raku.org/language/variables#Twigils&quot;&gt;twigils&lt;/a&gt;. The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!&lt;/code&gt; twigil here indicates that this variable is private to the class, and cannot be seen by any outside callers.&lt;/li&gt;
  &lt;li&gt;This could also be written as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;has Int @!internal-state&lt;/code&gt;, but I feel that doesn’t read as well. It can be written like this since the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@&lt;/code&gt; sigil already denotes it is a positional variable, so you only need to constrain the members.&lt;/li&gt;
  &lt;li&gt;This is a &lt;a href=&quot;https://docs.raku.org/routine/say#(Independent_routines)_sub_say&quot;&gt;common pattern&lt;/a&gt; for methods and subroutines that don’t actually return anything. Similar to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Unit&lt;/code&gt; in Scala, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;void&lt;/code&gt; in Java, or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt; in Python. And of course &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&amp;gt;&lt;/code&gt; is the way we define the return type.&lt;/li&gt;
  &lt;li&gt;The returns type can &lt;em&gt;also&lt;/em&gt; be defined using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;returns &amp;lt;type&amp;gt;&lt;/code&gt; as shown here. The difference between &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&amp;gt;&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;returns&lt;/code&gt; is that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;returns&lt;/code&gt; can only specify abstract types, whereas &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&amp;gt;&lt;/code&gt; can specify both abstract type or specific values, which is why we needed to use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;--&amp;gt;&lt;/code&gt; to return the &lt;em&gt;specific value&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;You’ll notice we don’t add the empty parentheses here. They are optional if there are no arguments to the method. In this case, I am using the Scala convention of having parentheses if the method has &lt;a href=&quot;https://en.wikipedia.org/wiki/Side_effect_(computer_science)&quot;&gt;side effects&lt;/a&gt;, and leaving them off otherwise.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Str&lt;/code&gt; is a magic method, similar to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__str__&lt;/code&gt; in Python or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;toString&lt;/code&gt; in Java and Scala. It is called whenever this variable is coerced to a string. So we don’t have to say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;Stack: {$stack.Str}&quot;&lt;/code&gt;, we can just say &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;Stack: $stack&quot;&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;Strongly typed Raku is much faster than gradually typed Raku, but I find it to be more cumbersome. Scalars are fairly easy (which is the majority of what we dealt with here), but I find positional (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Lists&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Arrays&lt;/code&gt;, etc.) and associatives (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hashes&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Maps&lt;/code&gt;, etc.) to be more challenging. For example, the way you constrain a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;List&lt;/code&gt; and an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Array&lt;/code&gt; is &lt;em&gt;slightly&lt;/em&gt; different. And &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Maps&lt;/code&gt; &lt;em&gt;always&lt;/em&gt; have to have string keys, which makes things both cumbersome and slow. In fact, there was some interesting discussion around Raku’s speed (or lack thereof) on the &lt;a href=&quot;https://www.reddit.com/r/rakulang/comments/kxjsca/raku_is_friggin_slow/&quot;&gt;Raku subreddit&lt;/a&gt;, and I encourage anyone reading this to spend a little time over there. Anyway, that’s enough rambling from me. Until next time!&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">Two pretty simple challenges this week! I tried ot focus on strongly typed subroutines and methods to shake things up.</summary></entry></feed>