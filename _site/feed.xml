<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-11-29T18:44:40-06:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Aaron Smith</title><subtitle>Personal website and blog of Aaron Smith</subtitle><author><name>Aaron Smith</name></author><entry><title type="html">Perl Weekly Challenge 88</title><link href="http://localhost:4000/blog/perl-weekly-challenge-088/" rel="alternate" type="text/html" title="Perl Weekly Challenge 88" /><published>2020-11-29T00:00:00-06:00</published><updated>2020-11-29T00:00:00-06:00</updated><id>http://localhost:4000/blog/perl-weekly-challenge-088</id><content type="html" xml:base="http://localhost:4000/blog/perl-weekly-challenge-088/">&lt;p&gt;I have always been a fan of Perl (and its younger brother Raku), but, since leaving the Bioinformatics world, have not found any real-world scenarios to flex those muscles.&lt;/p&gt;

&lt;p&gt;I recently stumbled upon the &lt;a href=&quot;https://perlweeklychallenge.org/&quot;&gt;Perl Weekly Challenge&lt;/a&gt; and decided it would be a great way to keep up-to-date with the community. I participated for the first time this week and thought it would be fun to do a write up of how I approached the problems. In the future, I will start publishing my blogs earlier in the week so that I can include a link to it in my PR.&lt;/p&gt;

&lt;p&gt;So, without further adieu, let’s dive in.&lt;/p&gt;

&lt;h2 id=&quot;task-1-array-of-product&quot;&gt;Task 1: Array of Product&lt;/h2&gt;

&lt;p&gt;You are given an array of positive integers &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Write a script to return an array &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@M&lt;/code&gt; where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$M[i]&lt;/code&gt; is the product of all elements of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@N&lt;/code&gt; except the index &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$N[i]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;example-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    @N = (5, 2, 1, 4, 3)
Output:
    @M = (24, 60, 120, 30, 40)

    $M[0] = 2 x 1 x 4 x 3 = 24
    $M[1] = 5 x 1 x 4 x 3 = 60
    $M[2] = 5 x 2 x 4 x 3 = 120
    $M[3] = 5 x 2 x 1 x 3 = 30
    $M[4] = 5 x 2 x 1 x 4 = 40
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    @N = (2, 1, 4, 3)
Output:
    @M = (12, 24, 6, 8)

    $M[0] = 1 x 4 x 3 = 12
    $M[1] = 2 x 4 x 3 = 24
    $M[2] = 2 x 1 x 3 = 6
    $M[3] = 2 x 1 x 4 = 8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/aaronreidsmith/raku/ch-1.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any specific implementation comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset PositiveInt of Int where { $_ ~~ Int &amp;amp;&amp;amp; $_ &amp;gt; 0 } # [1]

sub MAIN(*@N where all(@N) ~~ PositiveInt &amp;amp;&amp;amp; @N.elems &amp;gt; 0) {
    my $product = [*] @N;         # [2]
    my @M = @N.map: $product / *; # [3]
    say @M;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;raku ch-1.raku 5 2 1 4 3
[24 60 120 30 40]

raku ch-1.raku 2 1 4 3
[12 24 6 8]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;My day job is 100% Scala, so I try to approach everything with an immutable and functional approach, ideally with only one pass through the input list.&lt;/p&gt;

&lt;p&gt;The approach I took reminded me of multiplying fractions by the unit fraction to remove the denominator. For example &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1/4 x 4/4 = 1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is the approach applied to example 1 above:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$M[0] = (5 x 2 x 1 x 4 x 3) / 5 = 24
$M[1] = (5 x 2 x 1 x 4 x 3) / 2 = 60
$M[2] = (5 x 2 x 1 x 4 x 3) / 1 = 120
$M[3] = (5 x 2 x 1 x 4 x 3) / 4 = 30
$M[4] = (5 x 2 x 1 x 4 x 3) / 3 = 40
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;specific-comments&quot;&gt;Specific comments&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The problem states we are given an array of positive integers, but it never hurts to validate. Raku gives us the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subset&lt;/code&gt; keyword to easily define subsets of other types. In this case, the element has to be an integer and must be greater than 0. We then use this subset in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MAIN&lt;/code&gt; subroutine’s signature&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;As we can see from the modifications to example 1 above, we will always have the product of all items in the numerator and current item in the denominator. We just want to calculate that once, and Raku gives us a simple way of doing that through it’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[*]&lt;/code&gt; operator.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;This line shows my functional programming background bubbling up. Basically, for each item in the list, we want &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$product / $item&lt;/code&gt;, and we want the output collected into a list. This is a &lt;em&gt;textbook&lt;/em&gt; case for a map function, so you can see that is what I went with.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;To a non-Raku user, this may be a little confusing because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*&lt;/code&gt; in a map &lt;em&gt;literally&lt;/em&gt; means &lt;a href=&quot;https://docs.raku.org/type/Whatever&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;whatever&lt;/code&gt;&lt;/a&gt; (more specifically, “whatever input I received”) and &lt;em&gt;not&lt;/em&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multiply&lt;/code&gt;. The Scala equivalent would be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N.map(item =&amp;gt; product / item)&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;task-2-spiral-matrix&quot;&gt;Task 2: Spiral Matrix&lt;/h2&gt;

&lt;p&gt;You are given &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;m x n&lt;/code&gt; matrix of positive integers.&lt;/p&gt;

&lt;p&gt;Write a script to print spiral matrix as list.&lt;/p&gt;

&lt;h3 id=&quot;example-1-1&quot;&gt;Example 1&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    [ 1, 2, 3 ]
    [ 4, 5, 6 ]
    [ 7, 8, 9 ]
Ouput:
    [ 1, 2, 3, 6, 9, 8, 7, 4, 5 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;example-2-1&quot;&gt;Example 2&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Input:
    [  1,  2,  3,  4 ]
    [  5,  6,  7,  8 ]
    [  9, 10, 11, 12 ]
    [ 13, 14, 15, 16 ]
Output:
    [ 1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solution-1&quot;&gt;Solution&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/manwar/perlweeklychallenge-club/blob/master/challenge-088/aaronreidsmith/raku/ch-2.raku&quot;&gt;GitHub Link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;See below for explanation and any specific implementation comments&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;subset PositiveInt of Int where { $_ ~~ Int &amp;amp;&amp;amp; $_ &amp;gt; 0 }

enum Direction &amp;lt;NORTH EAST SOUTH WEST&amp;gt;;

sub MAIN(*@input where all(@input) ~~ PositiveInt &amp;amp;&amp;amp; @input.elems &amp;gt; 0) {
    # Ensure our input is exactly square
    my $side-length = @input.elems.sqrt;
    $side-length.Int == $side-length or die &quot;Must be a square matrix&quot;;

    # Turn our CLI input into a list of lists (containing both the value and a flag for if we have visted it)
    my @matrix = gather {
        loop (my $i = 0; $i &amp;lt; @input.elems; $i += $side-length) {
            my @row = @input[$i..^$i + $side-length].map({ Hash.new('value', $_, 'visited', False) });
            take @row;
        }
    }

    # Output list and helper function for adding to it
    my @output;
    sub visit-cell($i, $j) {
        my %cell = @matrix[$i][$j];
        if !%cell{'visited'} {
            @output.push(%cell{'value'});
        }
        @matrix[$i][$j]{'visited'} = True;
    }

    # Control vars used below
    my ($min-row, $min-col) = 0, 0;
    my ($max-row, $max-col) = @matrix.elems - 1, @matrix.tail.elems - 1;
    my ($current-row, $current-col, $current-direction) = $min-row, $min-col, EAST;

    # Iterate through matrix in the given directions. Check if we are in a corner or if we have already
    # visited the next cell to determine if we should turn
    while @output.elems != @input.elems {
        visit-cell($current-row, $current-col);
        given $current-direction {
            when EAST {
                if $current-col == $max-col || @matrix[$current-row][$current-col+1]{'visited'} {
                    $current-direction = SOUTH;
                    $current-row += 1;
                } else {
                    $current-col += 1;
                }
            }
            when SOUTH {
                if ($current-row == $max-row &amp;amp;&amp;amp; $current-col == $max-col) || @matrix[$current-row+1][$current-col]{'visited'} {
                    $current-direction = WEST;
                    $current-col -= 1;
                } else {
                    $current-row += 1;
                }
            }
            when WEST {
                if $current-col == $min-col || @matrix[$current-row][$current-col-1]{'visited'} {
                    $current-direction = NORTH;
                    $current-row -= 1;
                } else {
                    $current-col -= 1;
                }
            }
            when NORTH {
                # No need to check for special case here, because we always start in the top left
                if @matrix[$current-row-1][$current-col]{'visited'} {
                    $current-direction = EAST;
                    $current-col += 1;
                } else {
                    $current-row -= 1;
                }
            }
        }
    }
    say @output;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This program runs as such:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;raku ch-2.raku 1 2 3 4 5 6 7 8 9
[1 2 3 6 9 8 7 4 5]

raku ch-2.raku 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
[1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;explanation-1&quot;&gt;Explanation&lt;/h3&gt;

&lt;p&gt;I &lt;em&gt;tried&lt;/em&gt; to do this one functionally, but I just couldn’t find a way to do it.&lt;/p&gt;

&lt;p&gt;The basics of the above program are as follows:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We take some input and make sure it is square
    &lt;ul&gt;
      &lt;li&gt;Couldn’t find a better way to do this, but I am all ears if any knows. Scala has a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;isWhole&lt;/code&gt; function on its number classes, so I basically did that check myself:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; my $side-length = @input.elems.sqrt;
 $side-length.Int == $side-length or die &quot;Must be a square matrix&quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Convert that into an actual matrix that looks like this (using example 1):&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [
     [{value: 1, visited: False}, {value: 2, visited: False}, {value: 3, visited: False}],
     [{value: 4, visited: False}, {value: 5, visited: False}, {value: 6, visited: False}],
     [{value: 7, visited: False}, {value: 8, visited: False}, {value: 9, visited: False}],
 ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Starting in the top left corner, walk to the right (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EAST&lt;/code&gt;) with the following logic: if we hit the edge or a visited cell, turn right, else keep going.
    &lt;ul&gt;
      &lt;li&gt;We always “visit” the current cell by marking it visted and adding it to the output&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;That’s it!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;What I like about this solution is that it is pretty simple. In fact, steps one and two could be drastically simplified if this program trusted that it would always get a square matrix rather than a 1D matrix from the command line. Additionally, as a fan of pattern matching, I am glad I got to use a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;given/when&lt;/code&gt; clause here.&lt;/p&gt;

&lt;p&gt;What I dislike about this solution is the mutability (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@output.push()&lt;/code&gt;) and the fragility of it. For example, if the problem were tweaked to walk counter clockwise, I would basically have to re-write the actual “business logic” of this solution.&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;This was a fun dive back into the world of Perl, and I am looking forward to more of these challenges and blogs going forward.&lt;/p&gt;

&lt;p&gt;I am hoping someone can prove me wrong and solve the second problem functionally. Looking forward to seeing everyone’s solutions and interacting more with the community!&lt;/p&gt;

&lt;h4 id=&quot;ps&quot;&gt;PS&lt;/h4&gt;

&lt;p&gt;It seems the theme I am using for my blog does not support &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;raku&lt;/code&gt; code highlighting yet. I am using Jekyll; any plugin I can use to circumvent this?&lt;/p&gt;</content><author><name>Aaron Smith</name></author><category term="Blog" /><category term="Perl Weekly Challenge" /><category term="Raku" /><summary type="html">I have always been a fan of Perl (and its younger brother Raku), but, since leaving the Bioinformatics world, have not found any real-world scenarios to flex those muscles.</summary></entry></feed>